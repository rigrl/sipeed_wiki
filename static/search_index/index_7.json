{"/soft/maixpy3/zh/install/install.html": {"title": "安装 MaixPy3", "content": "---\ntitle: 安装 MaixPy3\nkeywords: linux, MaixII-Dock, MaixSense, 安装MaixPy3\ndesc: maixpy doc: linux_x86_64 如何安装？\n---\n\n## 可适配平台\n\n目前 MaixPy3 所能兼容的平台有 [MaixII-Dock](/hardware/zh/maixII/M2/introduce.html)、[MaixSense](/hardware/zh/maixII/M2A/R329.html)、Linux，后续会推出更加多可适配的平台\n\n\n\n### MaixII-Dock 上安装 MaixPy3\n\n在 MaixII-Dock 的最新[镜像](https://dl.sipeed.com/shareURL/MaixII/MaixII-Dock/SDK/release)中是已已经将 MaixPy3 安装好，烧录即可使用。不一定是最新版本的 MaixPy3，需要手动[更新 MaixPy3](/hardware/zh/maixII/M2/tools/0.MaixII-Dock.html#%E6%9B%B4%E6%96%B0-MaixPy3).\n\n也可以在[连接网络](/hardware/zh/maixII/M2/tools/0.MaixII-Dock.html#%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C)之后进行更新，通过 `pip install maixpy3` 进行安装，或者通过 `pip install -U Maixpy3` 进行更新\n\n```shell\nroot@sipeed:/# pip install maixpy3 -U\nRequirement already up-to-date: maixpy3 in /usr/lib/python3.8/site-packages (0.3.5)\nRequirement already satisfied, skipping upgrade: Pillow in /usr/lib/python3.8/site-packages (from maixpy3) (7.2.0)\nRequirement already satisfied, skipping upgrade: evdev in /usr/lib/python3.8/site-packages (from maixpy3) (1.4.0)\nRequirement already satisfied, skipping upgrade: gpiod in /usr/lib/python3.8/site-packages (from maixpy3) (1.4.0)\nRequirement already satisfied, skipping upgrade: pyserial in /usr/lib/python3.8/site-packages (from maixpy3) (3.4)\nRequirement already satisfied, skipping upgrade: rpyc in /usr/lib/python3.8/site-packages (from maixpy3) (5.0.1)\nRequirement already satisfied, skipping upgrade: spidev in /usr/lib/python3.8/site-packages (from maixpy3) (3.5)\nRequirement already satisfied, skipping upgrade: zbarlight in /usr/lib/python3.8/site-packages (from maixpy3) (3.0)\nRequirement already satisfied, skipping upgrade: plumbum in /usr/lib/python3.8/site-packages (from rpyc->maixpy3) (1.6.9)\nWARNING: You are using pip version 20.1.1; however, version 21.3.1 is available.\nYou should consider upgrading via the '/usr/bin/python3 -m pip install --upgrade pip' command.\nroot@sipeed:/#\n```\n\n输出以上信息则是代表安装好了\n\n### MaixSense 安装 MaixPy3\n\nMaixSense 需要是烧录官方提供最新的 Armbian 镜像，旧的镜像在安装 MaixPy3 的时候会缺很多文件而导致的报错。\n> MaixSense 的 Tina 没有做 MaixPy3 的移植，有需要的可以自行移植\n\n```shell\nroot@maixsense:~# pip install maixpy3\nRequirement already satisfied: maixpy3 in /usr/local/lib/python3.9/dist-packages (0.3.4)\nRequirement already satisfied: Pillow in /usr/lib/python3/dist-packages (from maixpy3) (8.1.2)\nRequirement already satisfied: zbarlight in /usr/local/lib/python3.9/dist-packages (from maixpy3) (3.0)\nRequirement already satisfied: evdev in /usr/local/lib/python3.9/dist-packages (from maixpy3) (1.4.0)\nRequirement already satisfied: spidev in /usr/local/lib/python3.9/dist-packages (from maixpy3) (3.5)\nRequirement already satisfied: pyserial in /usr/local/lib/python3.9/dist-packages (from maixpy3) (3.5)\nRequirement already satisfied: rpyc in /usr/local/lib/python3.9/dist-packages (from maixpy3) (5.0.1)\nRequirement already satisfied: gpiod in /usr/local/lib/python3.9/dist-packages (from maixpy3) (1.5.0)\nRequirement already satisfied: plumbum in /usr/local/lib/python3.9/dist-packages (from rpyc->maixpy3) (1.7.0)\nroot@maixsense:~# python\nPython 3.9.2 (default, Feb 28 2021, 17:03:44)\n[GCC 10.2.1 20210110] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import maix\n>>>\n```\n\n### Linux 上安装MaixPy3\n\n> 2021年02月21日 在 ubuntu20 与 manjaro20 上测试通过。\n\n通过 `pip3 install maixpy3` 安装。\n\n```bash\njuwan@juwan-N85-N870HL:~/Desktop/v831_toolchain_linux_x86/MaixPy3$ pip3 install .Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple\nProcessing /home/juwan/Desktop/v831_toolchain_linux_x86/MaixPy3\nRequirement already satisfied: Pillow in /usr/lib/python3/dist-packages (from MaixPy3==0.2.9) (7.0.0)\nRequirement already satisfied: evdev in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (1.4.0)\nRequirement already satisfied: gpiod in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (1.4.0)\nRequirement already satisfied: numpy in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (1.19.4)\nRequirement already satisfied: opencv-python in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (4.5.1.48)\nRequirement already satisfied: pyserial in /usr/local/lib/python3.8/dist-packages (from MaixPy3==0.2.9) (3.4)\nRequirement already satisfied: rpyc in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (5.0.1)\nRequirement already satisfied: spidev in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (3.5)\nRequirement already satisfied: plumbum in /home/juwan/.local/lib/python3.8/site-packages (from rpyc->MaixPy3==0.2.9) (1.6.9)\nBuilding wheels for collected packages: MaixPy3\n  Building wheel for MaixPy3 (setup.py) ... done\n  Created wheel for MaixPy3: filename=MaixPy3-0.2.9-cp38-cp38-linux_x86_64.whl size=115611 sha256=54f70f181ccc629f1eaf470bf30eccd20389c6333814d7145e16a31db7f6cdcd\n  Stored in directory: /tmp/pip-ephem-wheel-cache-9bf1q3wt/wheels/53/7d/47/6cd374fab930089f96a0a3185f5677e52a9b71dbbee769935d\nSuccessfully built MaixPy3\nInstalling collected packages: MaixPy3\n  Attempting uninstall: MaixPy3\n    Found existing installation: MaixPy3 0.2.8\n    Uninstalling MaixPy3-0.2.8:\n      Successfully uninstalled MaixPy3-0.2.8\nSuccessfully installed MaixPy3-0.2.9\n```\n\n现在你安装好后，可以在 python3 中复制粘贴如下代码运行。\n\n```python\nfrom maix import display, camera\ndisplay.show(camera.capture())\n```\n\n现在你可以看到系统唤起了图像浏览器显示的摄像头捕获的图像。\n\n![./asserts/dalaoshu.png](./asserts/dalaoshu.png)\n\n> 它借助了 opencv-python 和 PIL 的接口功能实现的。"}, "/soft/maixpy3/zh/install/index.html": {"title": "如何安装 MaixPy3 ", "content": "---\ntitle: 如何安装 MaixPy3 \nkeywords: MaixPy, MaixPy3, Python, Python3, MicroPython\ndesc: maixpy doc: 如何安装 MaixPy3 \n---\n\n通常来说，任何支持 Python3 的设备上都可以通过 `pip3 install maixpy3 --upgrade` 来安装 MaixPy3 作为模块入口使用，但由于一些嵌入式设备和不同平台限制，所以在这些平台上需要适配。\n\n适配进度请查阅 [MaixPy3#progress](https://github.com/sipeed/MaixPy3#progress) 。\n\n> 由于 Windows 的特殊性，不鼓励用户去折腾 Windows 的编译与安装。"}, "/soft/maixpy3/zh/tools/MaixPy3_IDE.html": {"title": "MaixPy3 IDE 基本介绍", "content": "---\ntitle: MaixPy3 IDE 基本介绍\nkeywords: MaixPy3 IDE\ndesc: maixpy doc: 如何连接 MaixII-Dock?\n---\n\nMaixPy3 是通过对 Jupyter 进行修改所得到的，这是方便新入门的同学进行学习。Jupyter 可以单步运行代码，并保留输出的结果，还能将屏幕显示的内容保留下来。\n\n## 安装 MaixPy3 IDE\n\n在[下载站](https://dl.sipeed.com/shareURL/MaixII/MaixPy3-IDE)中获得 MaixPy3 IDE 安装，双击打开并安装，安装结束之后，会以网页的形式在电脑默认浏览器中打开。\n\n> 下载站下载会比较慢，推荐百度云下载：链接：<https://pan.baidu.com/s/1C7Jl3rXticeJsCgH-fIcbQ>  提取码：2333 \n\n\n![IDE_1](./assets/IDE_1.png)\n\n## 界面介绍\n\n### 首页\n\n![IDE_2](./assets/IDE_2.png)\n上图中：\n\n1. 为文件选择区，点击即可进入 Jupyter 文档中\n2. 为文件上传，是将文件上传到 MaixPy IDE 的工作区当中，并不是将文件上传到开发板中。\n3. 为新建文件或者是文件夹\n4. 退出 MaixPy3 IDE，直接关闭浏览器 MaixPy IDE 还会在后台中运行。\n> MaixPy IDE 整合了一个 Python3，创建 Python3 文件的时候，只会使用 IDE 中的 Python。RPyc-python 文件是通过连接开发板运行代码，并输出结果。\n\n### 文件界面\n\n![](./assets/IDE_3.png)\n上图中：\n\n1. 单元格工具栏，可以对单元格进行复制、粘贴、运行、停止等操作\n2. 当前单元格的属性，可以在代码和 MD 文件中切换\n3. 显示当前文档运行代码属性单元格时所使用的内核\n4. 显示蓝色是为选中单元格，绿色为当前处于编辑的单元格\n\n![](./assets/IDE_4.png)\n\n![](./assets/IDE_5.png)\n\n\n## 常见问题\n\n在左侧中的常见问题与解决办法--[IDE常见问题](/soft/maixpy3/zh/question/Maixpy3_IDE.html)中可以查询到"}, "/soft/maixpy3/zh/update_history.html": {"title": "MaixPy3更新历史", "content": "# MaixPy3更新历史\n\n\n## 2021/8/5\n增加了MiaxII Dock在windows下的dd烧录方法。\n\n## 2021/8/2\n更新了MiaxII Dock的烧录方式，不再使用PhoenixSuit进行烧录。"}, "/soft/maixpy3/zh/usage/00_hello_world.html": {"title": "Hello World", "content": "---\ntitle: Hello World\nkeywords: Hello World, MaixPy3\ndesc: maixpy doc: Hello World\n---\n\n> 本文是给有一点 Python 基础但还想进一步深入的同学，有经验的开发者建议跳过。\n\n## 前言\n\n在写这篇案例系列的时候 [junhuanchen](https://github.com/junhuanchen) 期望能够引导用户如何成为专业的开发者，不是只会调用代码就好，所以在 MaixPy3 开源项目上期望为你带来值得学习和容易上手的开源项目，所以开篇会引导用户学习一些长期有利于编程工作上好的做法和观念，就先从最简单的认知项目开始吧。\n\n第一次接触需要编程的开源硬件项目，要做的第一件事就是先有一个好的开始，例如运行 Hello World 程序，意味着你必须能够先将这个事物跑起来才能够继续后续的内容，它可能是硬件、软件、工具等可编程的载体。\n\n> 但这里先不强调立刻开始运行程序，而是强调如何熟悉一个开源项目。\n\n要先找到它提供的开发文档（例如本文），先纵览全文，站在专业的角度来看，你需要先关注它提供了哪些资源，可以在哪里反馈你的问题，这样就有利于你后续开发过程中出现问题后，该如何迅速得到解决，避免自己之后在学习和开发过程中耽误时间。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/OSDC_Resource_Main_Page.png)\n\n有哪些资源是值得关注的？\n\n- 学会搜索！！！！！\n- 找到它的开源项目（如：[github.com/sipeed](https://github.com/sipeed)），获取它所提供的一系列源码。\n- 找到它提供的用户手册、应用案例、数据手册等等一系列开发所需要的文档。\n- 找到它的开发、编译、烧录、量产等一系列配套工具链，为后续软件开发活动中做准备。\n- 找到它的公开交流的环境，如 bbs、github、twitter、facebook、qq、wechat 等社交平台。\n\n现在你可以放心的编程了，但你还需要遵守一些在开源软件上的规则，认知到开源协议的存在，不要随意地做出侵犯他人软件的行为，哪怕没有法律责任的问题。\n\n在开源软件的世界里，鼓励人们自由参与和贡献代码，而不是鼓励如何免费白嫖，自由不等于免费，免费不等于服务，将软件源码公开是为了让用户更好更具有针对性的提交和反馈项目中存在的问题，不是为了更好服务你，请不要以服务自己的产品为中心。\n\n请尊重所有在开源环境里工作的朋友们，尊重他们（或是未来的你）的劳动成果。\n\n最后在开源的世界里，学会技术，学会成长，学会参与项目，学会分享成果！\n\n## Hello World\n\n> 关于本机怎样安装运行 Python 的基础知识，建议从其他网站教程得知。\n\n说了这么多，不如先来运行一段 Python3 代码吧。\n\n```python\nprint(\"hello world\")\n```\n\n> 点击下方的 run 按钮即可运行，如果有条件就在本机运行测试。\n\n<div align=\"center\" >\n    <iframe src=\"https://tool.lu/coderunner/embed/aEj.html\" style=\"width:90%; height:320px;\" frameborder=\"0\" mozallowfullscreen webkitallowfullscreen allowfullscreen></iframe>\n</div>\n\n> 在线 Python 编程 [runoob-python](https://www.runoob.com/try/runcode.php?filename=HelloWorld&type=python3) [google-colab](https://colab.research.google.com) 备用地址。\n\n但这样的代码是不够的，稍微认真一点写。\n\n```python\n# encoding: utf-8\n\ndef unit_test():\n    '''\n    this is unit_test\n    '''\n    print(\"hello world\")\n    raise Exception('unit_test')\n\nif __name__ == \"__main__\":\n    try:\n        unit_test()\n    except Exception as e:\n        import sys, traceback\n        exc_type, exc_value, exc_obj = sys.exc_info()\n        traceback.print_tb(exc_obj)\n        print('have a error:', e)\n\n```\n\n运行结果：\n\n```bash\nPS C:\\Users\\dls\\Documents\\GitHub\\MaixPy3> & C:/Users/dls/anaconda3/python.exe c:/Users/dls/Documents/GitHub/MaixPy3/test.py\nhello world\n  File \"c:/Users/dls/Documents/GitHub/MaixPy3/test.py\", line 12, in <module>\n    unit_test()\n  File \"c:/Users/dls/Documents/GitHub/MaixPy3/test.py\", line 8, in unit_test\n    raise Exception('unit_test')\nhave a error: unit_test\n```\n\n代码瞬间就变得复杂了起来？其实不然，这么写必然有它的用意，那这么写都考虑到了哪些情况呢？\n\n### 注意字符编码和代码缩进格式\n\n初学者经常会出现缩进不对齐的语法问题，代码的语法出现问题过于基础就不详谈，检查代码的小技巧就是 `CTAL + A` 全选代码，按 TAB 键右缩进，再配合 SHIFT + TAB 左缩进来发现哪段代码存在问题。\n\n首行的 `# encoding: utf-8` 是为了避免在代码中存在中文或其他语言的字符编码导致的运行出错的问题。\n\n> 在 python3 的字符串类型中 str 与 bytes 是一对欢喜冤家，例如 print(b'123') 打印出来的是 b'123' ，而实际上就是 '123' 的 bytes 字符串，前缀 b 只是为了和 str 区分，因为用途不同，在不同的接口对数据类型的需求不对，例如传递 str 字符串时候是不允许输入 '\\xFF' (0xFF) 字符的（会在转换过程中丢失），但 bytes 可以存储和表达。\n\n### 给代码加入单元测试和异常捕获\n\n想要写出一套稳定可用的代码，需要围绕接口可重入可测试的设计来编写封装，任何人写的代码都可能存在缺陷，在不能确定是哪里产生的问题之前，要能够恢复现场也要能够定位具体位置，以求问题能够最快得到反馈。\n\n所以在代码功能还没写之前，先把测试和异常的模板写好，再开始写功能，边写边测，确保最终交付的软件代码就算出问题也可以随时被测试（定位）出来。\n\n```python\n\ndef unit_test():\n    '''\n    this is unit_test\n    '''\n    print(\"hello world\")\n\nif __name__ == \"__main__\":\n    unit_test()\n```\n\n这样的代码可以保证任何人在任何时候运行该代码的时候都可以复现当时写下的场合所做的内容，然后 `if __name__ == \"__main__\":` 意味着该代码被其他模块包含的时候，不会在 import 该 Python 模块（可取名成 `hello` ）模块时调用，而是根据自己的代码需要执行相应的单元测试进行测试。\n\n```python\nimport hello\nhello.unit_test() # print(\"hello world\")\n```\n\n接着加入异常机制（try: except Exception as e:）保护代码段，表示该段代码出错的时候，能够不停下代码继续运行，像硬件资源访问的代码常常会发生超时、找不到、无响应的错误状态，这种情况下，一个跑起来的系统程序通常不需要停下来，出错了也可以继续运行下一件事，然后把当时的错误记录下来，通过 print 或 logging 日志模块记录下来，拿着错误结果（日志）反馈给开发者，这样开发者就可以分析、定位和解决问题，这其中也包括你自己。\n\n```python\ntry:\n    raise Exception('unit_test')\nexcept Exception as e:\n    import sys, traceback\n    exc_type, exc_value, exc_obj = sys.exc_info()\n    traceback.print_tb(exc_obj)\n    print('have a error:', e)\n```\n\n单元测试是每个程序都尽可能保持的基本原则，虽然人会偷懒，但最起码的代码格式还是要有的。\n\n> 注：traceback 可以抓取最后一次运行出现的错误而不停止运行，但该模块不存在 MicroPython(MaixPy) 中，它有类似的替代方法。\n\n## 封装代码接口成通用模块的方法\n\n世上本没有路，走的人多了，也便成了路。\n\n这里说的路实际上就是一种封装和参考，它意味着你写的代码成为一种事实上的通用操作。\n\n在 Python 上有很多封装参考，主要是为了形成抽象的函数模块。\n\n所以出现了一些经典的编程思想，如面向过程、面向对象、面向切面、面向函数等编程方法，哪一种更好就不比较和讨论了。\n\n这里就简单叙述一下这些编程方法的逐渐发展与变化的过程，可以如何做出选择。\n\n### 面向过程\n\n用面向过程的思维写代码，强调的是这份代码做的这件事需要分几步完成，例如最开始写代码都是这样的。\n\n```python\none = 1\ntwo = 2\nthree = one + two\nprint(three)\n```\n\n这是用人类直觉的过程来写代码，后来意识到可以这样写成通用功能，这是最初的代码封装成某个函数。\n\n```python\ndef sum(num1, num2):\n    return num1 + num2\none, two = 1, 2\nprint(sum(one, two)) # 1 + 2 = 3\n```\n\n于是你多写了个类似的乘法操作。\n\n```python\ndef mul(num1, num2):\n    return num1 * num2\none, two = 1, 2\nprint(mul(one, two)) # 1 * 2 = 2\n```\n\n这时的代码是按照每一个代码操作流程来描述功能的。\n\n### 面向对象\n\n面向对象是相对于面向过程来讲的，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式，一切事物皆对象，通过面向对象的方式，将现实世界的事物抽象成对象，现实世界中的关系抽象成类、[继承](https://baike.baidu.com/item/继承)，帮助人们实现对现实世界的[抽象](https://baike.baidu.com/item/抽象)与数字建模。\n\n在看了一些面向对象的描述后，你会意识到上节面向过程的函数操作可能很通用，应该不只适用于一种变量类型，所以可以通过面向对象（class）的方法来封装它，于是可以试着这样写。\n\n```python\nclass object:\n    def sum(self, a, b):\n        return a + b\n    def mul(self, a, b):\n        return a * b\nobj = object()\nprint(obj.sum(1, 2)) # 1 + 2 = 3\nprint(obj.mul(1, 2)) # 1 * 2 = 2\n```\n\n这样会意识到似乎还不只是数字能用，感觉字符串也能用。\n\n```python\nclass object:\n    def sum(self, a, b):\n        return a + b\n    def mul(self, a, b):\n        return a * b\nobj = object()\nprint(obj.sum('1', '2')) # 1 + 2 = 3\nprint(obj.mul('1', '2')) # 1 * 2 = 2\n```\n\n但这么写会出问题的，字符串相加的时候可以，但相乘的时候会报错误，因为是字符串这个类型的变量是不能相乘的。\n\n```bash\n12\nTraceback (most recent call last):\n  File \"c:/Users/dls/Documents/GitHub/MaixPy3/test.py\", line 8, in <module>\n    print(obj.mul('1', '2')) # 1 * 2 = 2\n  File \"c:/Users/dls/Documents/GitHub/MaixPy3/test.py\", line 5, in mul\n    return a * b\nTypeError: can't multiply sequence by non-int of type 'str'\n```\n\n显然这样写代码就不合理了，但这时运用的面向对象的思想是可行的，只是实现的方式不够好而已，所以重新设计类结构，例如可以写成下面的类结构。\n\n```python\nclass obj:\n    def __init__(self, value):\n        self.value = value\n    def __add__(self, obj):\n        return self.value + obj\n    def __mul__(self, obj):\n        return self.value * obj\n\nprint(obj(1) + 2) # 3\nprint(obj(1) * 2) # 2\n```\n\n其中 `__add__` 和 `__mul__` 是可重载运算符函数，意味着这个类实例化的对象在做 + 和 * 运算操作的时候，会调用类（class）重载函数，接着可以提升可以运算的对象类型，进一步继承对象拓展功能（`class number(obj):`）和访问超类的函数（`super().__add__(obj)`），其中 `if type(obj) is __class__:` 用于判断传入的参数对象是否可以进一步处理。\n\n```python\n\nclass number(obj):\n    def __add__(self, obj):\n        if type(obj) is __class__:\n            return self.value + obj.value\n        return super().__add__(obj)\n    def __mul__(self, obj):\n        if type(obj) is __class__:\n            return self.value * obj.value\n        return super().__mul__(obj)\n\nprint(number(1) + 2)\nprint(number(1) * 2)\nprint(number(1) + number(2))\nprint(number(1) * number(2))\n\n```\n\n这时候会发现可以进一步改写成字符串数值运算。\n\n```python\n\nclass str_number(obj):\n    def __init__(self, value):\n        self.value = int(value)\n    def __add__(self, obj):\n        if type(obj) is __class__:\n            return str(self.value + int(obj.value))\n        return str(super().__add__(int(obj)))\n    def __mul__(self, obj):\n        if type(obj) is __class__:\n            return str(self.value * int(obj.value))\n        return str(super().__mul__(int(obj)))\n\nprint(str_number('1') + '2')\nprint(str_number('1') * '2')\nprint(str_number('1') + str_number('2'))\nprint(str_number('1') * str_number('2'))\n```\n\n现在就可以解决了最初的同类操作适用不同的数据类型，把最初的一段操作通用到数值和字符串了，可以受此启发，它不仅仅只是加法或乘法，还有可能是其他操作，关于面向对象的内容就说到这里，感兴趣的可以查阅相关资料深入学习，本节只讲述可以怎样使用面向对象的思维写代码，而不是单纯把 Class 当 Struct 来使用。\n\n> 像最初写的代码，如果不通过对象继承分解函数，最终将会形成一个巨大的 Struct 结构。\n\n### 面向切面\n\n现在到了选择更多编程思维方式了，关于面向切面编程方法的场景是这样提出的，有一些函数，它在产品调试的时候会需要，但在产品上线的时候是不需要的，那这样的函数应该如何实现比较好？接下来不妨直接看代码，以日志输出的代码为例来说说面向切面，介绍一下如何使用装饰器进行编程的方法。\n\n```python\n\ndef log(param):\n    # simple\n    if callable(param):\n        def wrapper(*args, **kw):\n            print('%s function()' % (param.__name__,))\n            param(*args, **kw)\n        return wrapper\n    # complex\n    def decorator(func):\n        import functools\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            print('%s %s():' % (param, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\ndef now():\n    print(\"2019\")\n\n@log\ndef now1():\n    print(\"2020\")\n\n@log(\"Is this year?\")\ndef now2():\n    print(\"2021\")\n\nnow()\nnow1()\nnow2()\n\n```\n\n运行结果：\n\n```bash\nPS C:\\Users\\dls\\Documents\\GitHub\\MaixPy3> & C:/Users/dls/anaconda3/python.exe c:/Users/dls/Documents/GitHub/MaixPy3/test.py\n2019\nnow1 function()\n2020\nIs this year? now2():\n2021\nPS C:\\Users\\dls\\Documents\\GitHub\\MaixPy3>\n```\n\n对于产品上线时不需要的函数，注释掉就可以了，更进一步还可以重新设计某些函数满足于某些条件后再运行。\n\n- 在执行某段操作前，先打印当前的系统状态记录下来，确保出错时可以追溯到出错的地方。\n- 在发送网络数据前，要先检查网络通路是否存在，网卡是否还在工作。\n- 在运行操作前，先检查内存够不够，是否需要释放内存再继续操作。\n\n可以看到，当想要不改变某些现成库代码的条件下拓展系统的功能，就不免需要面向切面的设计方法。\n\n>  注意！面向切面提出的是编程思想，实现的方法不一定是装饰函数，可以是回调函数，也可以是重载函数。\n\n### 面向函数\n\n关于面向函数的场景是由于有些问题是被数学公式提出的，所以对于一些数学问题，并不一定要按过程化的思维来写，如实现阶乘函数（factorial），它的功能就是返回一个数的阶乘，即`1*2*3*...*`该数。\n\n```python\ndef fact(n):\n    if n == 3:\n        return 3*2*1\n    if n == 2:\n        return 2*1\n    if n == 1:\n        return 1\nprint(fact(3))\nprint(fact(2))\nprint(fact(1))\n```\n\n不难看出用最初的面向过程来写是写不下去的，不可能去定义所有的可能性，所以要找出规律，可以通过递归的方式实现。\n\n```python\ndef fact(n):\n    return 1 if n == 1 else n * fact(n - 1)\nprint(fact(1))\nprint(fact(5))\nprint(fact(100))\n```\n\n这样功能就完整了，简单来说函数式编程是让编程思维追求程序中存在的公式。\n\n## 试试快速迭代的敏捷开发？\n\n现代开源软件在经历了产测、内测、公测等环节后，直至更新到用户的手里，从前到后的过程通常在一周内就可以完成，所以在设计程序接口的时候，可以接受当下接口设计的不完美，等到未来有一个更好的替代功能接口的时候，就可以将其迭代替换下来，这意味着可以不用设计好整体的软件系统再开始工作，而是边做边改进，这套理论适用于初期需要频繁更新业务逻辑的开源软件。\n\n这里简单引用一段小故事来说明这个现象。\n\n快速迭代，不是说一定要产品做好了，才能上线，半成品也能上线。\n\n在没有上线之前，你怎么知道哪好那不好。所以半成品也是可以出门的，一定不要吝惜在家，丑媳妇才需要尽早见公婆。尽早的让用户去评判你的想法，你的设计是否可以赢得用户的喜爱。快速发出，紧盯用户反馈。百度完成了第一版的搜索引擎，也是让用户去做的选择。用百度 CEO 李彦宏（Robin）的话来说“你怎么知道如何把这个产品设计成最好的呢？只有让用户尽快去用它。既然大家对这版产品有信心，在基本的产品功能上我们有竞争优势，就应该抓住时机尽快将产品推向市场，真正完善它的人将是用户。他们会告诉你喜欢哪里不喜欢哪里，知道了他们的想法，我们就迅速改，改了一百次之后，肯定就是一个非常好的产品了。”\n\n## 准备一个好的开始\n\n看到这里的你，可能会困惑，可能会看不懂，会觉得很复杂，这是认知上的偏差，实际上本文所讲述的都是编程思想上的基础，如果想专业起来，不认真是不行的。\n\n不妨自己动手试试看吧。"}, "/soft/maixpy3/zh/usage/AI_net/train_resnet.html": {"title": "V831 ResNet18分类模型本地训练", "content": "# V831 ResNet18分类模型本地训练\n\n## 配置训练环境\n\n安装 python ，这里就不详细讲述怎么安装\n\n安装 CUDA 11.1 或者安装 CUDA 10.2 ，这个就自行[百度](https://www.baidu.com/s?ie=UTF-8&wd=%E5%AE%89%E8%A3%85CUDA)\n\n安装 pytorch-GPU ，CUDA10.2 在命令行中运行\n\n```\npip3 install torch==1.9.0+cu102 torchvision==0.10.0+cu102 torchaudio===0.9.0 -f https://download.pytorch.org/whl/torch_stable.html\n```\n\nCUDA 11.1 在命令行中运行\n\n```\npip3 install torch==1.9.0+cu111 torchvision==0.10.0+cu111 torchaudio===0.9.0 -f https://download.pytorch.org/whl/torch_stable.html\n```\n\n等待下载并安装\n\n下载训练脚本\n\n```\ngit clone https://github.com/sipeed/maix_train.git\n```\n\n## 开始训练\n\nresnet18 训练脚本在 maix_train\\pytorch\\classifier 文件夹下\n\n打开 classifier_resnet_train.py 修改 dataset_path 的参数，填写上数据集文件夹的相对路经。如果不知道什么是相对路径，请看[这里](https://blog.csdn.net/qq_34769573/article/details/80445681)\n\n```python\nclasses = ('chair', 'people')   #分类的类别，需要自己进行修改和添加\ndataset_path = \"data/datasets\"  #数据集文件相对路径\nval_split_from_data = 0.1 # 10% \nbatch_size = 4                  #以下的参数根据自己的需求进行修改，不知道怎么修改的请自行学习一下深度学习的基础知识\nlearn_rate = 0.001              #不要去群里问，这里的参数怎么修改，这个涉及的太多基础知识了\ntotal_epoch = 100\neval_every_epoch = 5\nsave_every_epoch = 20\ndataload_num_workers = 2\ninput_shape = (3, 224, 224)\ncards_id = [0]\nparam_save_path = 'out/classifier_{}.pth'   #这里是保存模型文件的路径\n```\n\n打开 classifier_resnet_test.py 根据自己的需求进行参数的修改\n\n```python\ntest_images_path = sys.argv[1]\nclasses = ('chair', 'people')   #分类的类别，需要自己进行修改和添加\ninput_shape = (3, 224, 224)\ncards_id = [0]   \nparam_save_path = sys.argv[2]\nonnx_out_name = \"out/classifier.onnx\"       #模型的位置\nncnn_out_param = \"out/classifier.param\"     #这里是转换模型的位置（windows可以不用管）\nncnn_out_bin = \"out/classifier.bin\"  \n```\n\n运行 classifier_resnet_train.py 即可开始进行模型训练。\n\n至于模型的部署请看[MaixII Dock上部署resnet18分类网络](https://bbs.sipeed.com/thread/1068)"}, "/soft/maixpy3/zh/usage/AI_net/Edge_detection.html": {"title": "边缘检测", "content": "# 边缘检测\n\nPytorch 使用模型(卷积/conv)实现 sobel(索贝尔) 边缘检测实现源码\n\n> 目前只能在 V831 上进行部署使用，R329 后续会更新上来\n\n## 边缘检测效果\n![](./../asserts/test.jpg)\n![](./../asserts/sobel_edge2.jpg)\n![](./../asserts/final.jpg)\n![](./../asserts/sobel_edge.jpg)\n![](./../asserts/sobel_v831.jpg)\n\n\n源码在末尾\n\n## 边缘检测原理\n边缘就是值变化剧烈的地方, 如果对值的变化求导, 则边缘部分就是导数局部最大.\n但是在图像处理时没有具体的函数让我们求导, 使用卷积运算则可以很好的近似替代\n\n如下图, 假设左上为坐标原点, 横轴为 `x`, 纵轴为`y`, 如下图左上角9个像素点, `P(x, y)`表示坐标`(x, y)`的点, 要求`P(1, 1)`处在x轴的变化率, 则只需将`P(2, 1) - P(0, 1)` 得到值为`0`, `P(1, 0)`处为`1-3 = -2,` 这个差值即变化率, 类比成导数, 我们就能知道横轴在哪些地方变化率更大.\n![](./../asserts/conv.jpg)\n上面这种方法我们可以得到横轴的变化率, 这里使用卷积核\n```\n[-1, 0, 1],\n[-2, 0, 2],\n[-1, 0, 1]\n```\n对图像进行卷积运算, 如图中的计算方法, 像素点左右权值取2, 角上的也参与计算,但是权值为1,没有左右边的权值高. 这样我们就得到了横轴的变化率图, 即边缘检测图.\n\n注意, 这里是对横轴计算了, 比较的点左右的值变化, 所以实际看到的图像会出现明显的纵轴边缘, 如下图左边\n![](./../asserts/vertical_horizontal.jpg)\n同理, 上图右边的图使用卷积核\n\n[1,2,1],\n[0,0,0],\n[-1, -2, -1]\n得到的纵轴的边缘图.\n\n注意这里用右边减左边, 如果右边的值比左边的小会是负数, 如果我们希望只检测颜色值变大(变白)则可以直接使用, 如果两个变化方向都要检测, 则可以取绝对值. 比如下图左边是没有取绝对值, 右边取了绝对值\n![](./../asserts/without_with_abs.jpg)\n得到两个方向的图后, 对其进行合并, 对每个像素平方和开方即可\n![](./../asserts/final.jpg)\n这张图左边是使用 GIMP 的 sobel 边缘检测(垂直+水平)的效果, 略微有点不同:\n![](./../asserts/sobel_edge2.jpg)\n不同的原因是使用水平和垂直的图平方和开根后, 直接用 `plt.imshow` 显示, 和 GIMP 的处理方式不同\n```python\nout = np.sqrt(np.square(out_v) + np.square(out_h))\nplt.imshow(out)\n```\n简单地直接将值规范到`[0, 255]`就和 GIMP 的图相似了(但不完全一样)\n```python\nout = np.sqrt(np.square(out_v) + np.square(out_h))\nout = out * 255.0 / out.max()\nplt.imshow(out.astype(np.uint8))\n```\n![](./../asserts/sobel_v_h.jpg)\n## 自定义卷积核来实现边缘检测\n除了上面说了使用两次卷积计算, 也可以用只计算一次的卷积核, 比如:\n```bash\n[-1, -1, -1],\n[ -1, 8, -1],\n[ -1, -1, -1]\n```\n这是对于一个通道(灰度图)来说, 如果要扩充到三个通道(RGB), 卷积核参数就是如下形式\n```bash\nconv_rgb_core_sobel = [\n                        [[-1,-1,-1],[-1,8,-1], [-1,    -1,    -1],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [-1,-1,-1],[-1,8,-1], [-1,    -1,    -1],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [-1,-1,-1],[-1,8,-1], [-1,    -1,    -1],\n                        ]]\n```\n经过卷积运算后, 前后图如下:\n\n![](./../asserts/sobel_edge.jpg)\n\n注意, 输入值范围如果为`[0, 255]`, 输出值则范围会变化, 以图片形式查看时需要注意加以处理, 这里使用了`plt.imshow(out)`来显示, 这个函数会自动对图像做简单的处理, 才会看起来是黑色背景\n\n## 导出成模型使用\n可以将 Net 导出成 onnx 即可在其它平台使用, 就是一个简单的卷积层\n\n部署到 V831 后的样子(使用了卷积核`[-1,-1,-1],[-1,8,-1], [-1,-1,-1],`):\n\n![](./../asserts/sobel_v831.jpg)\n\nV831 部署[源码](https://github.com/sipeed/MaixPy3/blob/master/ext_modules/_maix_nn/example/load_forward_sobel_edge_camera.py)在 github， 模型在 maixhub 上可以下载\n\n## 边缘检测源码\n\n> 这是在电脑上运行的代码，不是在开发板平台上运行的代码\n\n```python\n\n'''\n    simple sobel edge demo\n    visit: https://neucrack.com/p/377\n    @author neucrack\n    @license MIT\n'''\nimport torch\nimport torch.nn as nn\nimport numpy as np\nimport cv2\nfrom PIL import Image\nimport matplotlib.pyplot as plt\nclass Net(nn.Module):\n    def __init__(self):\n        super(Net, self).__init__()\n        self.conv1 = nn.Conv2d(3, 3, 3, padding=(0, 0), bias=False)\n    def forward(self, x):\n        x = self.conv1(x)\n        return x\nnet = Net()\nconv_rgb_core_original = [\n                        [[0,0,0],[0,1,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,1,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,1,0], [0,0,0]\n                        ]]\nconv_rgb_core_sobel = [\n                        [[-1,-1,-1],[-1,8,-1], [-1,    -1,    -1],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [-1,-1,-1],[-1,8,-1], [-1,    -1,    -1],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [-1,-1,-1],[-1,8,-1], [-1,    -1,    -1],\n                        ]]\nconv_rgb_core_sobel_vertical = [\n                        [[-1,0,1],[-2,0,2], [-1,    0,    1],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [-1,0,1],[-2,0,2], [-1,    0,    1],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [-1,0,1],[-2,0,2], [-1,    0,    1],\n                        ]]\nconv_rgb_core_sobel_horizontal = [\n                        [[1,2,1],[0,0,0], [-1, -2, -1],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [1,2,1],[0,0,0], [-1, -2, -1],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [1,2,1],[0,0,0], [-1, -2, -1],\n                        ]]\ndef sobel(net, kernel):\n    sobel_kernel = np.array(kernel,    dtype='float32')\n    sobel_kernel = sobel_kernel.reshape((3,    3,    3,    3))\n    net.conv1.weight.data = torch.from_numpy(sobel_kernel)\nparams = list(net.parameters())\nimg = cv2.imread(\"out/test.jpg\")\ninput_img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\ninput_tensor = (input_img.astype(np.float32) - 127.5) / 128 # to [-1, 1]\ninput_tensor = torch.Tensor(input_tensor).permute((2, 0, 1))\nprint(input_tensor.shape)\ninput_tensor = input_tensor.unsqueeze(0)\nprint(\"input shape:\", input_tensor.shape)\nsobel(net, conv_rgb_core_sobel)\nout = net(input_tensor).detach().numpy()[0].transpose([1,2,0])\nsobel(net, conv_rgb_core_sobel_vertical)\nout_v = net(input_tensor).detach().numpy()[0].transpose([1,2,0])\nsobel(net, conv_rgb_core_sobel_horizontal)\nout_h = net(input_tensor).detach().numpy()[0].transpose([1,2,0])\nprint(\"out shape: {}, tensor:{}\".format(out.shape, out))\nprint(out.shape, out.max(), out.min())\nplt.figure()\nplt.figure()\nplt.subplot(1, 5, 1)\ninput = input_tensor.numpy()[0].transpose((1,2,0))\nprint(input.max(), input.min())\nplt.imshow(input_img)\nplt.subplot(1, 5, 2)\nprint(out.max(), out.min())\n# out = np.sqrt(np.square(out))\n# out = out * 255.0 / out.max()\n# out = out.astype(np.uint8)\n# print(out.max(), out.min())\nplt.imshow(out)\nplt.subplot(1, 5, 3)\nout = np.abs(out_v)\n# out = out * 255.0 / out.max()\n# plt.imshow(out.astype(np.uint8))\nplt.imshow(out)\nplt.subplot(1, 5, 4)\nout = np.abs(out_h)\n# out = out * 255.0 / out.max()\n# plt.imshow(out.astype(np.uint8))\nplt.imshow(out)\nplt.subplot(1, 5, 5)\nout = np.sqrt(np.square(out_v) + np.square(out_h))\n# out = out * 255.0 / out.max()\n# plt.imshow(out.astype(np.uint8))\nplt.imshow(out)\nplt.show()\n```\n\n## 参考\n- [How to implement Sobel edge detection using Python from scratch](http://www.adeveloperdiary.com/data-science/computer-vision/how-to-implement-sobel-edge-detection-using-python-from-scratch/)\n- [梯度和Sobel导数](https://blog.csdn.net/lzhf1122/article/details/71752644)\n\n> 以上内容出至于：<https://neucrack.com/p/377>"}, "/soft/maixpy3/zh/usage/AI_net/find_face.html": {"title": "人脸检测", "content": "---\ntitle: 人脸检测\nkeywords: 人脸检测, MaixPy3, Python, Python3\ndesc: maixpy doc: 人脸检测\n---\n\n人脸检测的模型，可以通过 maixhub 中下载，将下载之后得到的模型，通过 ssh 等连接方式，存放到开发板中\n\n具体的部署代码在 [Github](https://github.com/sipeed/MaixPy3/blob/master/ext_modules/_maix_nn/example/yolo2_camera.py) 中，将代码复制出来，需要修改脚本中读取模型的位置，运行代码即可进行人脸检测\n\n> 最新的镜像已经将模型存放在 /home/model 文件夹下\n\n```python\nfrom maix import camera, display, nn, image\nfrom maix.nn import decoder\nclass face:\n    labels = [\"person\"]\n    anchors = [1.19, 1.98, 2.79, 4.59, 4.53, 8.92, 8.06, 5.29, 10.32, 10.65]\n    m = {\n        \"param\": \"/home/model/face/yolo2_face_awnn.param\",\n        \"bin\": \"/home/model/face/yolo2_face_awnn.bin\"\n    }\n    options = {\n        \"model_type\":  \"awnn\",\n        \"inputs\": {\n            \"input0\": (224, 224, 3)\n        },\n        \"outputs\": {\n            \"output0\": (7, 7, (1+4+1)*5)\n        },\n        \"mean\": [127.5, 127.5, 127.5],\n        \"norm\": [0.0078125, 0.0078125, 0.0078125],\n    }\n    def __init__(self):\n        from maix import nn\n        from maix.nn import decoder\n        self.model = nn.load(self.m, opt=self.options)\n        self.yolo = decoder.Yolo2(len(self.labels), self.anchors, net_in_size=(224, 224), net_out_size=(7, 7))\n        \n    def __del__(self):\n        del self.model\n        del self.yolo\n\nlabels = [\"person\"]\nwhile True:\n    img = camera.capture().resize(224,224)\n    out = Face.model.forward(img.tobytes(), quantize=True, layout=\"hwc\")\n    boxes, probs = Face.yolo.run(out, nms=0.3, threshold=0.5, img_size=(224, 224))\n    if len(boxes):\n        for i, box in enumerate(boxes):\n            img.draw_rectangle(box[0], box[1], box[0]+box[2], box[1]+box[3], (255,0,0), 1)\n        display.show(img)\n    else:\n        display.show(img)\n\n```"}, "/soft/maixpy3/zh/usage/AI_net/resnet.html": {"title": "V831上部署resnet18分类网络", "content": "# V831上部署resnet18分类网络\n\n## 前期准备\n在V831上使用resnet18分类网络，我们需要在linux环境下进行。windows系统可以使用虚拟机，或者是使用WSL，具体的安装教程请自行百度，这里就不过多的进行描述\n\n### 安装pytorch环境\n\n我们需要在系统中安装pytorch，通过在pytorch官网上可以知道安装pytorch需要执行\n\n    pip3 install torch==1.9.0+cpu torchvision==0.10.0+cpu torchaudio==0.9.0 -f https://download.pytorch.org/whl/torch_stable.html\n\n或者是通过conda环境进行安装\n\n    conda install pytorch torchvision torchaudio cpuonly -c pytorch\n\n我们还需要安装一个`torchsummary`库来进行神经网络的可视化\n\n    pip3 install torchsummary\n\n### 编译ncnn转换工具\n\n通过 `git clone https://github.com/Tencent/ncnn.git` 将ncnn的仓库拉取到本地，进行编译\n\n安装编译环境的依赖\n\n```bash\nsudo apt update\nsudo apt install build-essential git cmake libprotobuf-dev protobuf-compiler libvulkan-dev vulkan-utils libopencv-dev\n```\n编译ncnn需要使用到 Vulkan 后端\n要使用 Vulkan 后端，请安装 Vulkan 头文件、一个 vulkan 驱动程序加载器、GLSL 到 SPIR-V 编译器和 vulkaninfo 工具。或者从<https://vulkan.lunarg.com/sdk/home>下载并安装完整的 Vulkan SDK（大约 200MB；它包含所有头文件、文档和预构建的加载程序，以及一些额外的工具和所有源代码）\n\n```bash\nwget https://sdk.lunarg.com/sdk/download/1.2.182.0/linux/vulkansdk-linux-x86_64-1.2.182.0.tar.gz\ntar xvf vulkansdk-linux-x86_64-1.2.182.0.tar.gz\nexport VULKAN_SDK=$(pwd)/1.2.182.0/x86_64\n```\n\n拉取ncnn的子仓库\n\n```bash\ncd ncnn\ngit submodule update --init\n```\n\n开始编译ncnn\n```bash\nmkdir -p build\ncd build\ncmake -DCMAKE_BUILD_TYPE=Release -DNCNN_VULKAN=ON -DNCNN_SYSTEM_GLSLANG=ON -DNCNN_BUILD_EXAMPLES=ON ..\nmake -j$(nproc)\n```\n\n编译结束之后会在build/tools/onnx/下的到onnx2ncnn可执行文件，这个是就用ncnn的转换工具\n\n> 将编译出来的 onnx2ncnn 添加到系统的环境变量中\n\n## 获取模型并进行推理\n\n> 以下代码建议在jupyter中运行\n\n通过pytorch hub来获取resnet18的预训练模型，这里并不细说训练的过程和模型定义\n\nlabel[下载](https://raw.githubusercontent.com/pytorch/hub/master/imagenet_classes.txt)\n使用以下代码进行模型的下载和推理\n```python\nimport os\nimport torch\nfrom torchsummary import summary\ntorch.hub._validate_not_a_forked_repo=lambda a,b,c: True\n## model\nmodel = torch.hub.load('pytorch/vision:v0.6.0', 'resnet18', pretrained=True)\nmodel.eval()\ninput_shape = (3, 224, 224)\nsummary(model, input_shape, device=\"cpu\")\n## test image\nfilename = \"out/dog.jpg\"\nif not os.path.exists(filename):\n    if not os.path.exists(\"out\"):\n        os.makedirs(\"out\")\n    import urllib\n    url, filename = (\"https://github.com/pytorch/hub/raw/master/images/dog.jpg\", filename)\n    try: urllib.URLopener().retrieve(url, filename)\n    except: urllib.request.urlretrieve(url, filename)\nprint(\"test image:\", filename)\n## preparing input data\nfrom PIL import Image\nimport numpy as np\nfrom torchvision import transforms\ninput_image = Image.open(filename)\n# input_image.show()\npreprocess = transforms.Compose([\n    transforms.Resize(max(input_shape[1:3])),\n    transforms.CenterCrop(input_shape[1:3]),\n    transforms.ToTensor(),\n    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),\n])\ninput_tensor = preprocess(input_image)\nprint(\"input data max value: {}, min value: {}\".format(torch.max(input_tensor), torch.min(input_tensor)))\ninput_batch = input_tensor.unsqueeze(0) # create a mini-batch as expected by the model\n## forward model\n# move the input and model to GPU for speed if available\nif torch.cuda.is_available():\n    input_batch = input_batch.to('cuda')\n    model.to('cuda')\nwith torch.no_grad():\n    output = model(input_batch)\n## result    \n# Tensor of shape 1000, with confidence scores over Imagenet's 1000 classes\n# print(output[0])\n# The output has unnormalized scores. To get probabilities, you can run a softmax on it.\nmax_1000 = torch.nn.functional.softmax(output[0], dim=0)\nmax_idx = int(torch.argmax(max_1000))\nwith open(\"imagenet_classes.txt\") as f:\n    labels = f.read().split(\"\\n\")\nprint(\"result: idx:{}, name:{}\".format(max_idx, labels[max_idx]))\n```\n\n运行后得到结果:\n```python\nUsing cache found in /home/neucrack/.cache/torch/hub/pytorch_vision_v0.6.0\n----------------------------------------------------------------\n        Layer (type)               Output Shape         Param #\n================================================================\n            Conv2d-1         [-1, 64, 112, 112]           9,408\n       BatchNorm2d-2         [-1, 64, 112, 112]             128\n              ReLU-3         [-1, 64, 112, 112]               0\n         MaxPool2d-4           [-1, 64, 56, 56]               0\n            Conv2d-5           [-1, 64, 56, 56]          36,864\n       BatchNorm2d-6           [-1, 64, 56, 56]             128\n              ReLU-7           [-1, 64, 56, 56]               0\n            Conv2d-8           [-1, 64, 56, 56]          36,864\n       BatchNorm2d-9           [-1, 64, 56, 56]             128\n             ReLU-10           [-1, 64, 56, 56]               0\n       BasicBlock-11           [-1, 64, 56, 56]               0\n           Conv2d-12           [-1, 64, 56, 56]          36,864\n      BatchNorm2d-13           [-1, 64, 56, 56]             128\n             ReLU-14           [-1, 64, 56, 56]               0\n           Conv2d-15           [-1, 64, 56, 56]          36,864\n      BatchNorm2d-16           [-1, 64, 56, 56]             128\n             ReLU-17           [-1, 64, 56, 56]               0\n       BasicBlock-18           [-1, 64, 56, 56]               0\n           Conv2d-19          [-1, 128, 28, 28]          73,728\n      BatchNorm2d-20          [-1, 128, 28, 28]             256\n             ReLU-21          [-1, 128, 28, 28]               0\n           Conv2d-22          [-1, 128, 28, 28]         147,456\n      BatchNorm2d-23          [-1, 128, 28, 28]             256\n           Conv2d-24          [-1, 128, 28, 28]           8,192\n      BatchNorm2d-25          [-1, 128, 28, 28]             256\n             ReLU-26          [-1, 128, 28, 28]               0\n       BasicBlock-27          [-1, 128, 28, 28]               0\n           Conv2d-28          [-1, 128, 28, 28]         147,456\n      BatchNorm2d-29          [-1, 128, 28, 28]             256\n             ReLU-30          [-1, 128, 28, 28]               0\n           Conv2d-31          [-1, 128, 28, 28]         147,456\n      BatchNorm2d-32          [-1, 128, 28, 28]             256\n             ReLU-33          [-1, 128, 28, 28]               0\n       BasicBlock-34          [-1, 128, 28, 28]               0\n           Conv2d-35          [-1, 256, 14, 14]         294,912\n      BatchNorm2d-36          [-1, 256, 14, 14]             512\n             ReLU-37          [-1, 256, 14, 14]               0\n           Conv2d-38          [-1, 256, 14, 14]         589,824\n      BatchNorm2d-39          [-1, 256, 14, 14]             512\n           Conv2d-40          [-1, 256, 14, 14]          32,768\n      BatchNorm2d-41          [-1, 256, 14, 14]             512\n             ReLU-42          [-1, 256, 14, 14]               0\n       BasicBlock-43          [-1, 256, 14, 14]               0\n           Conv2d-44          [-1, 256, 14, 14]         589,824\n      BatchNorm2d-45          [-1, 256, 14, 14]             512\n             ReLU-46          [-1, 256, 14, 14]               0\n           Conv2d-47          [-1, 256, 14, 14]         589,824\n      BatchNorm2d-48          [-1, 256, 14, 14]             512\n             ReLU-49          [-1, 256, 14, 14]               0\n       BasicBlock-50          [-1, 256, 14, 14]               0\n           Conv2d-51            [-1, 512, 7, 7]       1,179,648\n      BatchNorm2d-52            [-1, 512, 7, 7]           1,024\n             ReLU-53            [-1, 512, 7, 7]               0\n           Conv2d-54            [-1, 512, 7, 7]       2,359,296\n      BatchNorm2d-55            [-1, 512, 7, 7]           1,024\n           Conv2d-56            [-1, 512, 7, 7]         131,072\n      BatchNorm2d-57            [-1, 512, 7, 7]           1,024\n             ReLU-58            [-1, 512, 7, 7]               0\n       BasicBlock-59            [-1, 512, 7, 7]               0\n           Conv2d-60            [-1, 512, 7, 7]       2,359,296\n      BatchNorm2d-61            [-1, 512, 7, 7]           1,024\n             ReLU-62            [-1, 512, 7, 7]               0\n           Conv2d-63            [-1, 512, 7, 7]       2,359,296\n      BatchNorm2d-64            [-1, 512, 7, 7]           1,024\n             ReLU-65            [-1, 512, 7, 7]               0\n       BasicBlock-66            [-1, 512, 7, 7]               0\nAdaptiveAvgPool2d-67            [-1, 512, 1, 1]               0\n           Linear-68                 [-1, 1000]         513,000\n================================================================\nTotal params: 11,689,512\nTrainable params: 11,689,512\nNon-trainable params: 0\n----------------------------------------------------------------\nInput size (MB): 0.57\nForward/backward pass size (MB): 62.79\nParams size (MB): 44.59\nEstimated Total Size (MB): 107.96\n----------------------------------------------------------------\nout/dog.jpg\ntensor(2.6400) tensor(-2.1008)\nidx:258, name:Samoyed, Samoyede\n\n```\n可以看到模型有 11,689,512的参数， 即 11MiB左右， 这个大小也就几乎是实际在 831 上运行的模型的大小了\n\n## 模型转换\n\n### pth转onnx\n通过pytorch hub获取到的resnet18 模型是pth格式的，需要转换成onnx格式的模型\n\n转换代码\n```python\ndef torch_to_onnx(net, input_shape, out_name=\"out/model.onnx\", input_names=[\"input0\"], output_names=[\"output0\"], device=\"cpu\"):\n    batch_size = 1\n    if len(input_shape) == 3:\n        x = torch.randn(batch_size, input_shape[0], input_shape[1], input_shape[2], dtype=torch.float32, requires_grad=True).to(device)\n    elif len(input_shape) == 1:\n        x = torch.randn(batch_size, input_shape[0], dtype=torch.float32, requires_grad=False).to(device)\n    else:\n        raise Exception(\"not support input shape\")\n    print(\"input shape:\", x.shape)\n    # torch.onnx._export(net, x, \"out/conv0.onnx\", export_params=True)\n    torch.onnx.export(net, x, out_name, export_params=True, input_names = input_names, output_names=output_names)\nonnx_out=\"out/resnet_1000.onnx\"\nncnn_out_param = \"out/resnet_1000.param\"\nncnn_out_bin = \"out/resnet_1000.bin\"\ninput_img = filename\ntorch_to_onnx(model, input_shape, onnx_out, device=\"cuda:0\")\n\n```\n在out文件夹中得到onnx格式模型文件\n\n### onnx转ncnn\n\n然后再利用前面编译出来的onnx2ncnn转换工具进行ncnn格式的转换\n\n```python\ndef onnx_to_ncnn(input_shape, onnx=\"out/model.onnx\", ncnn_param=\"out/conv0.param\", ncnn_bin = \"out/conv0.bin\"):\n    import os\n    # onnx2ncnn tool compiled from ncnn/tools/onnx, and in the buld dir\n    cmd = f\"onnx2ncnn {onnx} {ncnn_param} {ncnn_bin}\"\n    os.system(cmd)\n    with open(ncnn_param) as f:\n        content = f.read().split(\"\\n\")\n        if len(input_shape) == 1:\n            content[2] += \" 0={}\".format(input_shape[0])\n        else:\n            content[2] += \" 0={} 1={} 2={}\".format(input_shape[2], input_shape[1], input_shape[0])\n        content = \"\\n\".join(content)\n    with open(ncnn_param, \"w\") as f:\n        f.write(content)\nonnx_to_ncnn(input_shape, onnx=onnx_out, ncnn_param=ncnn_out_param, ncnn_bin=ncnn_out_bin)\n```\n\n> 这里需要确定 onnx2ncnn 是可以使用的命令，否则会无法使用这个函数进行模型转换\n\n\n\n### ncnn量化到int8模型\n\n通过maixhub将ncnn模型进行量化到int8模型\n\n在 maixhub 模型转换 将 ncnn 模型转换为 awnn 支持的 int8 模型 （网页在线转换很方便人为操作，另一个方面因为全志要求不开放 awnn 所以暂时只能这样做）\n\n阅读转换说明，可以获得更多详细的转换说明\n![](./asserts/maixhub.jpg)\n\n这里有几组参数：\n\n- 均值 和 归一化因子： 在 pytorch 中一般是 (输入值 - mean ) / std, awnn对输入的处理是 (输入值 - mean ) \\* norm, 总之，让你训练的时候的输入到第一层网络的值范围和给awnn量化工具经过(输入值 - mean ) \\* norm 计算后的值范围一致既可。 比如 这里打印了实际数据的输入范围是[-2.1008, 2.6400]， 是代码中preprocess 对象处理后得到的，即x = (x - mean) / std ==> (0-0.485)/0.229 = -2.1179, 到awnn就是x = (x - mean_2\\*255) \\* (1 / std \\* 255) 即 mean2 = mean \\* 255, norm = 1/(std \\* 255), 更多可以看这里。\n\n- 所以我们这里可以设置 均值为 0.485 \\* 255 = 123.675， 设置 归一化因子为1/ (0.229 \\* 255) = 0.017125， 另外两个通道同理，但是目前 awnn 只能支持三个通道值一样。。。所以填123.675, 123.675, 123.675，0.017125, 0.017125, 0.017125 即可，因为这里用了pytorch hub的预训练的参数，就这样吧， 如果自己训练，可以好好设置一下图片输入层尺寸（问不是图片怎么办？貌似 awnn 暂时之考虑到了图片。。）\n\n- RGB 格式： 如果训练输入的图片是 RGB 就选 \n- RGB量化图片， 选择一些和输入尺寸相同的图片，可以从测试集中拿一些，不一定要图片非常多，但尽量覆盖全场景（摊手\n\n> 自己写的其它模型转换如果失败，多半是啥算子不支持，需要在 使用说明里面看支持的 算子，比如现在的版本view、 flatten、reshape 都不支持所以写模型要相当小心， 后面的版本会支持 flatten reshape 等 CPU 算子\n\n如果不出意外， 终于得到了量化好的 awnn 能使用的模型， \\*.param 和 \\*.bin\n\n## 使用模型，在v831上推理\n可以使用 python 或者 C 写代码，以下两种方式\n\npython的是需要在终端下运行的，不要使用jupyter，建议使用ssh，这样放文件什么都比较方便\n\n### MaixPy3\npython 请看MaixPy3\n\n不想看文档的话，就是在系统开机使用的基础上， 更新 MaixPy3 就可以了：\n\n    pip install --upgrade maixpy3\n\n然后在终端使用 python 运行脚本（可能需要根据你的文件名参数什么的改一下代码）：\n\nhttps://github.com/sipeed/MaixPy3_scripts/blob/main/basic/v1.0/resnet.py\n\nlabel 在这里： https://github.com/sipeed/MaixPy3/blob/main/ext_modules/_maix_nn/example/classes_label.py\n\nbaars.ttf 在这里：https://github.com/sipeed/MaixPy3_scripts/blob/main/application/base/res/baars.ttf\n```python\nfrom maix import camera, nn, display\nfrom home.res.classes_label import labels\nclass Resnset:\n    m = {\n        \"param\": \"/home/model/resnet18_1000_awnn.param\",\n        \"bin\": \"/home/model/resnet18_1000_awnn.bin\"\n    }\n    options = {\n        \"model_type\":  \"awnn\",\n        \"inputs\": {\n            \"input0\": (224, 224, 3)\n        },\n        \"outputs\": {\n            \"output0\": (1, 1, 1000)\n        },\n        \"first_layer_conv_no_pad\": False,\n        \"mean\": [127.5, 127.5, 127.5],\n        \"norm\": [0.00784313725490196, 0.00784313725490196, 0.00784313725490196],\n    }\n    def __init__(self):\n        from maix import nn\n        self.model = nn.load(self.m, opt=self.options)\n       \n    def __del__(self):\n        del self.model\n\n\n\n\nwhile True:\n    img = camera.capture().resize(224, 224)\n    tmp = img.tobytes()\n    out = resnset.model.forward(tmp, quantize=True)\n    out2 = nn.F.softmax(out)\n    msg = \"{:.2f}: {}\".format(out2.max(), labels[out.argmax()])\n    img.draw_string(0, 0, str(msg), 0.5, (255, 0, 0), 1)\n    display.show(img)\n```\n> 如果运行报错了，请更新maixpy3再运行\n\n\n\n### C语言 SDK， libmaix\n访问这里，按照 https://github.com/sipeed/libmaix 的说明克隆仓库，并编译 https://github.com/sipeed/libmaix/tree/master/examples/nn_resnet\n\n上传编译成功后dist目录下的所有内容到 v831, 然后执行./start_app.sh即可\n\n> 以上内容出至：<https://neucrack.com/p/358>"}, "/soft/maixpy3/zh/usage/AI_net/face_recognize.html": {"title": "人脸识别", "content": "---\ntitle: 人脸识别\nkeywords: 人脸识别, MaixPy3, Python, Python3\ndesc: maixpy doc: 人脸识别\n---\n\n人脸识别的模型，可以通过 maixhub 中下载，将下载之后得到的模型，通过 ssh 等连接方式，存放到开发板中\n\n具体的部署代码在 [Github](https://github.com/sipeed/MaixPy3/blob/master/ext_modules/_maix_nn/example/face_recognize.py) 中，将代码复制出来，需要修改脚本中读取模型的位置，运行代码即可进行人脸识别\n\n```python\ndef __init__(self, threshold = 0.5, nms = 0.3, max_face_num = 1):\n        model = {\n            \"param\": \"res/model_int8.param\",\n            \"bin\": \"res/model_int8.bin\"\n        }\n        model_fe = {\n            \"param\": \"res/fe_res18_117.param\",\n            \"bin\": \"res/fe_res18_117.bin\"\n        }\n        self.input_size = (224, 224, 3)\n        input_size_fe = (128, 128, 3)\n        self.feature_len = 256\n        self.features = []\n\n```\n\n通过按键来进行人脸的录入，识别到正确的人脸回显示成绿的绿色的框，右键为添加人脸，左键为删除人脸"}, "/soft/maixpy3/zh/usage/hardware/SPI.html": {"title": "SPI", "content": "---\ntitle: SPI\nkeywords: maixpy3, SPI\ndesc: maixpy3 doc: SPI\n---\n\n## 使用 SPI\n\n> 以下代码由于 Maixpy3 还在优化中，可能不能运行，具体的代码到 [github](https://github.com/sipeed/MaixPy3) 上查看\n\n```python\nimport spidev, time\nspi = spidev.SpiDev(mode=SPI.MODE_MASTER, baudrate=10000000, polarity=0, phase=0, bits=8, firstbit=SPI.MSB)   # SPI 初始化\nspi.open(1, 0)                      # 使用  SPI 1.0 \n\nwhile True:\n  time.sleep(0.1)\n  to_send = [0x01, 0x02, 0x01]\n  to_get = []\n  print(spi.write_readinto(to_send, to_get, cs=SPI.CS0)) \n\n```\n\n## 什么是 SPI\nSPI是串行外设接口（Serial Peripheral Interface）的缩写，是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，正是出于这种简单易用的特性，越来越多的芯片集成了这种通信协议，比如AT91RM9200。\n\n## SPI 工作原理\nSPI总线是一种4线总线，因其硬件功能很强，所以与SPI有关的软件就相当简单，使中央处理器（Central Processing Unit，CPU）有更多的时间处理其他事务。正是因为这种简单易用的特性，越来越多的芯片集成了这种通信协议，比如AT91RM9200。SPI是一种高速、高效率的串行接口技术。通常由一个主模块和一个或多个从模块组成，主模块选择一个从模块进行同步通信，从而完成数据的交换。SPI是一个环形结构，通信时需要至少4根线（事实上在单向传输时3根线也可以）。\n\nSPI的通信原理很简单，它以主从方式工作，这种模式通常有一个主设备和一个或多个从设备，需要至少4根线，事实上3根也可以（单向传输时）。也是所有基于SPI的设备共有的，它们是MISO（主设备数据输入）、MOSI（主设备数据输出）、SCLK（时钟）、CS（片选）。\n\n>（1）MISO– Master Input Slave Output，主设备数据输入，从设备数据输出；\n\n>（2）MOSI– Master Output Slave Input，主设备数据输出，从设备数据输入；\n\n>（3）SCLK – Serial Clock，时钟信号，由主设备产生；\n\n>（4）CS – Chip Select，从设备使能信号，由主设备控制。\n\n其中，CS是从芯片是否被主芯片选中的控制信号，也就是说只有片选信号为预先规定的使能信号时（高电位或低电位），主芯片对此从芯片的操作才有效。这就使在同一条总线上连接多个SPI设备成为可能。\n\n接下来就负责通讯的3根线了。通讯是通过数据交换完成的，这里先要知道SPI是串行通讯协议，也就是说数据是一位一位的传输的。这就是SCLK时钟线存在的原因，由SCLK提供时钟脉冲，SDI，SDO则基于此脉冲完成数据传输。数据输出通过 SDO线，数据在时钟上升沿或下降沿时改变，在紧接着的下降沿或上升沿被读取。完成一位数据传输，输入也使用同样原理。因此，至少需要8次时钟信号的改变（上沿和下沿为一次），才能完成8位数据的传输。\n\n时钟信号线SCLK只能由主设备控制，从设备不能控制。同样，在一个基于SPI的设备中，至少有一个主设备。这样的传输方式有一个优点，在数据位的传输过程中可以暂停，也就是时钟的周期可以为不等宽，因为时钟线由主设备控制，当没有时钟跳变时，从设备不采集或传送数据。SPI还是一个数据交换协议：因为SPI的数据输入和输出线独立，所以允许同时完成数据的输入和输出。芯片集成的SPI串行同步时钟极性和相位可以通过寄存器配置，IO模拟的SPI串行同步时钟需要根据从设备支持的时钟极性和相位来通讯。\n\n最后，SPI接口的一个缺点：没有指定的流控制，没有应答机制确认是否接收到数据。\n\nSPI的片选可以扩充选择16个外设,这时PCS输出=NPCS,说NPCS0~3接4-16译码器,这个译码器是需要外接4-16译码器，译码器的输入为NPCS0~3，输出用于16个外设的选择。"}, "/soft/maixpy3/zh/usage/hardware/PWM.html": {"title": "PWM", "content": "---\ntitle: PWM\nkeywords: maixpy3, PWM\ndesc: maixpy3 doc: PWM\n---\n\n## 使用 PWM\n\n当需要使用 PWM 驱动一些外设的时候，可以通过以下的代码进行驱动，对于不同的 Linux 开发板来说，PWM 信号输出的管脚号是不一样的，只需要修改 PWM 输出口\n\n> 以下代码由于 Maixpy3 还在优化中，可能不能运行，具体的代码到 [github](https://github.com/sipeed/MaixPy3) 上查看\n\n```python\nfrom maix import pwm\nimport time\npwm_output = pwm.PWM(6, freq=1000)          # s设置输出 PWM 的管脚和频率\nwhile True:\n    pwm_output.out(pulse_width_percent = 50)    # 设置 PWM 的占空比并开始输出\n    time.sleep(1)\n    pwm_output.step()                           # 停止输出 pwm 信号\n    time.sleep(0.1)\n\n```\n\n## 什么是 PWM？\n脉冲宽度调制是一种模拟控制方式，根据相应载荷的变化来调制晶体管基极或MOS管栅极的偏置，来实现晶体管或MOS管导通时间的改变，从而实现开关稳压电源输出的改变。这种方式能使电源的输出电压在工作条件变化时保持恒定，是利用微处理器的数字信号对模拟电路进行控制的一种非常有效的技术。脉冲宽度调制是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术，广泛应用在从测量、通信到功率控制与变换的许多领域中。\n\n## PWM 工作原理\n脉宽调制（PWM）基本原理：控制方式就是对逆变电路开关器件的通断进行控制，使输出端得到一系列幅值相等但宽度不一致的脉冲，用这些脉冲来代替正弦波或所需要的波形。也就是在输出波形的半个周期中产生多个脉冲，使各脉冲的等值电压为正弦波形，所获得的输出平滑且低次谐波少。按一定的规则对各脉冲的宽度进行调制，既可改变逆变电路输出电压的大小，也可改变输出频率。\n\n例如，把正弦半波波形分成N等份，就可把正弦半波看成由N个彼此相连的脉冲所组成的波形。这些脉冲宽度相等，都等于 π/n ，但幅值不等，且脉冲顶部不是水平直线，而是曲线，各脉冲的幅值按正弦规律变化。如果把上述脉冲序列用同样数量的等幅而不等宽的矩形脉冲序列代替，使矩形脉冲的中点和相应正弦等分的中点重合，且使矩形脉冲和相应正弦部分面积（即冲量）相等，就得到一组脉冲序列，这就是PWM波形。可以看出，各脉冲宽度是按正弦规律变化的。根据冲量相等效果相同的原理，PWM波形和正弦半波是等效的。对于正弦的负半周，也可以用同样的方法得到PWM波形。\n\n在PWM波形中，各脉冲的幅值是相等的，要改变等效输出正弦波的幅值时，只要按同一比例系数改变各脉冲的宽度即可，因此在交－直－交变频器中，PWM逆变电路输出的脉冲电压就是直流侧电压的幅值。\n\n根据上述原理，在给出了正弦波频率，幅值和半个周期内的脉冲数后，PWM波形各脉冲的宽度和间隔就可以准确计算出来。按照计算结果控制电路中各开关器件的通断，就可以得到所需要的PWM波形。下图为变频器输出的PWM波的实时波形。\n![](./../asserts/pwm.gif)\n![](./../asserts/pwm.jpg)\n\n\n\n> 源自百度百科"}, "/soft/maixpy3/zh/usage/hardware/I2C.html": {"title": "I2C", "content": "---\ntitle: I2C\nkeywords: maixpy3, I2C\ndesc: maixpy3 doc: I2C\n---\n\n## 如何使用 I2C \n\n通过查看开发板上的管脚引出 I2C 相关引脚，管脚图中得 TWI 对应的就是 I2C 管脚\n\n![](./../asserts/M2Dock_pin.png)\n\n> 以下代码由于 Maixpy3 还在优化中，可能不能运行，具体的代码到 [github](https://github.com/sipeed/MaixPy3) 上查看\n\n```python\nfrom maix import i2c\ni2c_address = i2c.I2CSecan('/dev/i2c-2')            # 获取设备在 I2C 的地址数据\nprint(i2c_address)\ni2c_im = i2c.read(i2c_address, 4)                   # 获取设备信息\ni2c_ID = i2c.read_register(i2c_address, 0x36, 4)    # 读取设备寄存器上的信息\ni2c.writes(i2c_address, 1)                          # 对设备上发送数据\ni2c.writes_register(i2c_address, 0x38, 0xab)        # 对设备上的寄存器写入数据\n```\n> 以上是 MaixII-Dock 开发板的板载三轴加速度传感器部分代码，完整代码在 [Github](https://github.com/sipeed/MaixPy3/blob/master/examples/maix_v831/usage/usage_v831_i2c-2.py)\n\n对于 I2C 别的使用方法，可以查看 Maixpy3 在 Github 上的源码\n\n## 什么是 I2C 总线\n\n1. I2C 总线是由 Philips 公司开发的一种简单、双向二线制同步串行总线。它只需要两根线即可在连接于总线上的设备之间传送信息。\n2. 主设备用于启动总线传送数据，并产生时钟以开放传送的设备，此时任何被寻址的设备均被认为是从设备．总线上主设备和从设备、发数据设备和收数据设备的关系不是恒定的，而取决于此时数据传送方向。\n3. 如果主设备要发送数据给从设备，则主设备首先要寻址从设备，然后主动发送数据至从设备，最后由主设备终止数据传送；如果主设备要接收从设备的数据，首先由主设备寻址从设备．然后主设备接收从设备发送的数据，最后由主设备终止接收过程。在这种情况下．主机负责产生定时时钟和终止数据传送。\n\n## I2C 通信设备原理\n\n1. 硬件结构：通信只需要两根传输线，结构上及其简单。\n    - SCL(serial clock)：时钟线，传输 CLK 信号，一般是 I2C 主设备向从设备提供时钟的通道。\n    - SDA(serial data): 数据线，通信数据都通过SDA线传输。\n\n2. 通信特征：串行、同步、非差分、低速率\n    - I2C 属于串行通信，所有的数据以位为单位在 SDA 线上串行传输。\n    - 同步通信就是通信双方工作在同一个时钟下，一般是通信的 A 方通过一根 CLK 信号线传输 A 自己的时钟给 B，B 工作在 A 传输的时钟下。所以同步通信的显著特征就是：通信线中有 CLK\n    - 非差分。因为 I2C 通信速率不高，而且通信双方距离很近，所以使用电平信号通信。\n    - 低速率。I2C 一般是用在同一个板子上的2个 IC 之间的通信，而且用来传输的数据量不大，所以本身通信速率很低（一般几百KHz，不同的 I2C 芯片的通信速率可能不同，具体在编程的时候要看自己所使用的设备允许的 I2C 通信最高速率，不能超过这个速率）\n\n3. 通信方向：主设备+从设备\n    - I2C 通信的时候，通信双方地位是不对等的，而是分主设备和从设备。通信由主设备发起，由主设备主导，从设备只是按照 I2C 协议被动的接受主设备的通信，并及时响应。\n    - 谁是主设备、谁是从设备是由通信双方来定的（ I2C 协议并无规定），一般来说一个芯片可以只能做主设备、也可以只能做从设备、也可以既能当主设备又能当从设备（软件配置）。\n\n4. 一对多通信\n    - I2C 通信可以一对一（1个主设备对1个从设备），也可以一对多（1个主设备对多个从设备）。\n    - 主设备来负责调度总线，决定某一时间和哪个从设备通信。注意：同一时间内，I2C的总线上只能传输一对设备的通信信息，所以同一时间只能有一个从设备和主设备通信，其他从设备处于“冬眠”状态，不能出来捣乱，否则通信就乱套了。\n    - 每一个 I2C 从设备在通信中都有一个 I2C 从设备地址，这个设备地址是从设备本身固有的属性，然后通信时主设备需要知道自己将要通信的那个从设备的地址，然后在通信中通过地址来甄别是不是自己要找的那个从设备。（这个地址是一个电路板上唯一的，不是全球唯一的）\n\n5. 主要用途\n    - 主要用途：SoC 和周边外设之间的通信（典型的如 EEPROM、电容触摸 IC、各种 sensor 等）\n\n\n> 原文链接：https://blog.csdn.net/weixin_46089486/article/details/108992588"}, "/soft/maixpy3/zh/usage/hardware/UART.html": {"title": "UART", "content": "---\ntitle: UART\nkeywords: maixpy3, UART\ndesc: maixpy3 doc: UART\n---\n\n## UART 的使用\n\n串口可以用于与别的开发板或者是单片机进行数据的通信，用于链接别的开发板或者单片机。\n\n根据所接的串口号进行修改以下代码，\n\n> 以下代码由于 Maixpy3 还在优化中，可能不能运行，具体的代码到 [github](https://github.com/sipeed/MaixPy3) 上查看\n\n```python\nimport serial\n\nser = serial.Serial(\"/dev/ttyS1\",115200)    # 使用 UART1 ，波特率设置为 115200\n\nprint('serial test start ...')\nser.write(b\"Hello Wrold !!!\\n\")\ntry:\n    while True:\n        ser.setDTR(True)\n        ser.setRTS(True)\n        tmp = ser.readline()\n        print(tmp)\n        ser.write(tmp)\n        ser.setDTR(False)\n        ser.setRTS(False)\nexcept KeyboardInterrupt:\n    if ser != None:\n        ser.close()\n```\n\n## 什么是串口\n\n通用异步收发传输器（Universal Asynchronous Receiver/Transmitter，通常称作UART） 是一种串行异步收发协议，应用十分广泛。UART工作原理是将数据的二进制位一位一位的进行传输。在UART通讯协议中信号线上的状态位高电平代表’1’低电平代表’0’。当然两个设备使用UART串口通讯时，必须先约定好传输速率和一些数据位。\n\n## 硬件连接\n硬件连接比较简单，仅需要3条线，注意连接时两个设备UART电平，如电平范围不一致请做电平转换后再连接，如下图所示：\n\n- TX：发送数据端，要接对面设备的RX\n- RX：接收数据端，要接对面设备的TX\n- GND：保证两设备共地，有统一的参考平面\n\n![](./../asserts/UART.jpg)\n\n## 串口工作原理\n\n- 发送接收\n\n发送逻辑对从发送FIFO 读取的数据执行“并→串”转换。控制逻辑输出起始位在先的串行位流，并且根据控制寄存器中已编程的配置，后面紧跟着数据位（注意：最低位 LSB 先输出）、奇偶校验位和停止位。\n\n在检测到一个有效的起始脉冲后，接收逻辑对接收到的位流执行“串→并”转换。此外还会对溢出错误、奇偶校验错误、帧错误和线中止（line-break）错误进行检测，并将检测到的状态附加到被写入接收FIFO 的数据中。 [3] \n\n- 波特率产生\n\n波特率除数（baud-rate divisor）是一个22 位数，它由16 位整数和6 位小数组成。波特率发生器使用这两个值组成的数字来决定位周期。通过带有小数波特率的除法器，在足够高的系统时钟速率下，UART 可以产生所有标准的波特率，而误差很小。\n\n- 数据收发\n\n发送时，数据被写入发送FIFO。如果UART 被使能，则会按照预先设置好的参数（波特率、数据位、停止位、校验位等）开始发送数据，一直到发送FIFO 中没有数据。一旦向发送FIFO 写数据（如果FIFO 未空），UART 的忙标志位BUSY 就有效，并且在发送数据期间一直保持有效。BUSY 位仅在发送FIFO 为空，且已从移位寄存器发送最后一个字符，包括停止位时才变无效。即 UART 不再使能，它也可以指示忙状态。BUSY 位的相关库函数是UARTBusy( )\n\n在UART 接收器空闲时，如果数据输入变成“低电平”，即接收到了起始位，则接收计数器开始运行，并且数据在Baud16 的第8 个周期被采样。如果Rx 在Baud16 的第8 周期仍然为低电平，则起始位有效，否则会被认为是错误的起始位并将其忽略。\n\n如果起始位有效，则根据数据字符被编程的长度，在 Baud16 的每第 16 个周期（即一个位周期之后）对连续的数据位进行采样。如果奇偶校验模式使能，则还会检测奇偶校验位。\n最后，如果Rx 为高电平，则有效的停止位被确认，否则发生帧错误。当接收到一个完整的字符时，将数据存放在接收FIFO 中。\n\n- 中断控制\n    - 出现以下情况时，可使UART 产生中断：\n    - FIFO 溢出错误\n    - 线中止错误（line-break，即Rx 信号一直为0 的状态，包括校验位和停止位在内）\n    - 奇偶校验错误\n    - 帧错误（停止位不为1）\n    - 接收超时（接收FIFO 已有数据但未满，而后续数据长时间不来）\n    - 发送\n    - 接收\n    - 由于所有中断事件在发送到中断控制器之前会一起进行“或运算”操作，所以任意时刻 UART 只能向中断产生一个中断请求。通过查询中断状态函数UARTIntStatus( )，软件可以在同一个中断服务函数里处理多个中断事件（多个并列的if 语句）。\n\n- FIFO 操作\n\nFIFO 是“First-In First-Out”的缩写，意为“先进先出”，是一种常见的队列操作。 Stellaris 系列ARM 的UART 模块包含有2 个16 字节的FIFO：一个用于发送，另一个用于接收。可以将两个FIFO 分别配置为以不同深度触发中断。可供选择的配置包括：1/8、 1/4、1/2、3/4 和7/8 深度。例如，如果接收FIFO 选择1/4，则在UART 接收到4 个数据时产生接收中断。\n\n发送FIFO的基本工作过程： 只要有数据填充到发送FIFO 里，就会立即启动发送过程。由于发送本身是个相对缓慢的过程，因此在发送的同时其它需要发送的数据还可以继续填充到发送 FIFO 里。当发送 FIFO 被填满时就不能再继续填充了，否则会造成数据丢失，此时只能等待。这个等待并不会很久，以9600 的波特率为例，等待出现一个空位的时间在1ms 上下。发送 FIFO 会按照填入数据的先后顺序把数据一个个发送出去，直到发送 FIFO 全空时为止。已发送完毕的数据会被自动清除，在发送FIFO 里同时会多出一个空位。\n\n接收FIFO的基本工作过程： 当硬件逻辑接收到数据时，就会往接收FIFO 里填充接收到的数据。程序应当及时取走这些数据，数据被取走也是在接收FIFO 里被自动删除的过程，因此在接收 FIFO 里同时会多出一个空位。如果在接收 FIFO 里的数据未被及时取走而造成接收FIFO 已满，则以后再接收到数据时因无空位可以填充而造成数据丢失。\n\n收发FIFO 主要是为了解决UART 收发中断过于频繁而导致CPU 效率不高的问题而引入的。在进行 UART 通信时，中断方式比轮询方式要简便且效率高。但是，如果没有收发 FIFO，则每收发一个数据都要中断处理一次，效率仍然不够高。如果有了收发FIFO，则可以在连续收发若干个数据（可多至14 个）后才产生一次中断然后一并处理，这就大大提高了收发效率。\n\n完全不必要担心FIFO 机制可能带来的数据丢失或得不到及时处理的问题，因为它已经帮你想到了收发过程中存在的任何问题，只要在初始化配置UART 后，就可以放心收发了， FIFO 和中断例程会自动搞定一切。\n\n- 回环操作\nUART 可以进入一个内部回环（Loopback）模式，用于诊断或调试。在回环模式下，从Tx 上发送的数据将被Rx 输入端接收。\n\n- 串行红外协议\n\n在某些 Stellaris 系列 ARM 芯片里，UART 还包含一个 IrDA 串行红外（SIR）编码器/ 解码器模块。IrDA SIR 模块的作用是在异步UART数据流和半双工串行SIR 接口之间进行转换。片上不会执行任何模拟处理操作。SIR 模块的任务就是要给UART 提供一个数字编码输出和一个解码输入。UART 信号管脚可以和一个红外收发器连接以实现IrDA SIR物理层连接。\n\n\n> 参考：百度百科、CSDN博客"}, "/soft/maixpy3/zh/usage/hardware/key.html": {"title": "事件输入", "content": "---\ntitle: 事件输入\nkeywords: maixpy3, 事件输入\ndesc: maixpy3 doc: 事件输入\n---\n\n## 使用事件输入\n\n> 以下代码由于 Maixpy3 还在优化中，可能不能运行，具体的代码到 [github](https://github.com/sipeed/MaixPy3) 上查看\n\n```python\nfrom evdev import InputDevice\nfrom select import select\n\n\ndef detectInputKey(count):\n\tdev = InputDevice('/dev/input/event0')\n\twhile True:\n\t\tselect([dev], [], [])\n\t\tfor event in dev.read():\n\t\t\t# print(event)\n\t\t\tif event.code == 0x02:\n\t\t\t\tprint('press key S1')\n\t\t\tif event.code == 0x03:\n\t\t\t\tprint('press key S2')\n\t\t\tif event.value == 1 and event.code != 0:\n\t\t\t\tcount += 1\n\t\t\t\tprint('press sum:', count)\n\ndetectInputKey(0)\n```"}, "/soft/maixpy3/zh/usage/hardware/GPIO.html": {"title": "GPIO", "content": "---\ntitle: GPIO\nkeywords: maixpy3, GPIO\ndesc: maixpy3 doc: GPIO\n---\n\n## 如何使用 GPIO 输出高低电平\n\nGPIO 是可以复用成别的通信接口，对于 Maixpy3 来说并不需要那么麻烦，GPIO 就用来输出高低电平，别的用法后面再说。\n\n下面以 MaixII-Dock 开发板为例子讲述如果使用 maixpy3 输出高低电平。\n\n通过查看 MaixII-Dock 的引出管脚图可以知道，那些管脚可以直接用来当 GPIO 口使用\n\n![](./../asserts/M2Dock_pin.png)\n\n> 以下代码由于 Maixpy3 还在优化中，可能不能运行，具体的代码到 [github](https://github.com/sipeed/MaixPy3) 上查看\n\n```python\nfrom maix import GPIO\nimport time\nled =GPIO.pin(\"PH\", 14)             # 设置使用 PH 14 管脚\nwhile led:\n    led.set_value(0)                # 设置低电平\n    time.sleep(0.5)\n    print(\"0\", led.get_value())     # 获取管脚当前状态\n    led.set_value(1)                # 设置高电平\n    time.sleep(0.5)\n    print(\"1\", led.get_value())     # 获取管脚当前状态\n\n```\n\n## 什么是 GPIO \nGPIO（英语：General-purpose input/output），通用型之输入输出的简称，功能类似8051的P0—P3，其接脚可以供使用者由程控自由使用，PIN脚依现实考量可作为通用输入（GPI）或通用输出（GPO）或通用输入与输出（GPIO），如当clk generator, chip select等。\n\n既然一个引脚可以用于输入、输出或其他特殊功能，那么一定有寄存器用来选择这些功能。对于输入，一定可以通过读取某个寄存器来确定引脚电位的高低；对于输出，一定可以通过写入某个寄存器来让这个引脚输出高电位或者低电位；对于其他特殊功能，则有另外的寄存器来控制它们。\n> 源自[百度百科](https://baike.baidu.com/item/gpio/4723219?fr=aladdin)\n\n## GPIO 的用途\n\n不同系统间的GPIO的确切作用不同。通用常有下面几种：\n\n1. 输出值可写（高=1，低=0）。一些芯片也可以选择驱动这些值的方式，以便支持“线-或”或类似方案（开漏信号线）。\n2. 输入值可读（1，0）。一些芯片支持输出管脚回读，这在线或的情况下非常有用（以支持双向信号线）。GPIO控制器可能具有一个输入防故障/防反跳逻辑，有时还会有软件控制。\n3. 输入经常被用作中断信号，通常是边沿触发，但也有可能是电平触发。这些中断可以配置为系统唤醒事件，从而将系统从低功耗模式唤醒。\n4. 一个GPIO经常被配置为输入/输出双向，根据不同的产品单板需求，但也存在单向的情况。\n5. 大多是GPIO可以在获取到spinlock自旋锁时访问，但那些通过串行总线访问的通常不能如此操作（休眠的原因）。一些系统中会同时存在这两种形式的GPIO。\n6. 在一个给定单板上，每个GPIO用于一个特定的目的，如监控MMC/SD卡的插入/移除，检查卡写保护状态，驱动LED，配置发送器，串行总线位拆，触发一个硬件看门狗，触发一个开关之类的。\n\n> 原则[电子发烧友论坛](http://www.elecfans.com/emb/jiekou/20171206595752.html)\n\n\n\n只需要修改对应的管脚口即可进行高低电平输出，对于图中别的通信使用方式会在后面讲述\n\n对于 GPIO 更多的使用方式，通过查看开发板的规格书得知"}, "/soft/maixpy3/zh/usage/Audio/play_mp4.html": {"title": "播放视频", "content": "# 播放视频\n\n经过测试，目前 MaixPy3 可兼容视频格式有 MP4 和 avi，其他格式还没有进行测试，对于视频别的参数，可以在以下通过测试的视频查看。\n\n一共有3个[测试视频](https://dl.sipeed.com/shareURL/MaixII/MaixII-Dock/example),将这里得到的视频存放到 Linux 系统的文件中，将 `path_to_video` 的参数修改成所存放视频路径\n```python\nimport pyaudio\nfrom maix import display, camera\nimport av\nimport threading\nimport time\n\n\nclass funation:\n    status = 0\n    def __init__(self,device=None):\n        self.event = self.run\n        display.show(camera.capture())\n        self.tim = time.time()\n        self.device = device\n    def __del__(self):\n        print(\"paly exit\")\n    def play(self):\n        try:\n            # recommend flv\n            # ffmpeg -r 30 -i bad_apple.mp4 -s 240x240 output.mp4\n            # adb push ./output.mp4 /mnt/UDISK/\n            # adb push ./test.py / && adb shell 'python ./test.py'\n            path_to_video = '/home/res/output.mp4'\n            container = av.open(path_to_video)\n            ai_stream = container.streams.audio[0]\n            vi_stream = container.streams.video[0]\n            fifo = av.AudioFifo()\n            p = pyaudio.PyAudio()\n            ao = p.open(format=pyaudio.paFloat32, channels=2, rate=22050, output=True)\n            for frame in container.decode(video=0, audio=0):\n                if 'Audio' in repr(frame):\n                    frame.pts = None\n                    fifo.write(frame)\n                    for frame in fifo.read_many(4096):\n                        ao.write(frame.planes[0].to_bytes())\n                if 'Video' in repr(frame):\n                    display.show(bytes(frame.to_rgb().planes[0]))\n                if self.device.funaction_status == -1:\n                    ao.stop_stream()\n                    ao.close()\n                    p.terminate()\n                    return\n        except Exception as e:\n            print(e)\n        finally:\n            ao.stop_stream()\n            ao.close()\n            p.terminate()\n    def run(self):\n        if self.status == 0:\n            threading.Thread(target=self.play).start()\n            self.status = 1\n        time.sleep(0.1)\n\n\nif __name__ == \"__main__\":\n    import signal\n    def handle_signal_z(signum,frame):\n        print(\"APP OVER\")\n        exit(0)\n    signal.signal(signal.SIGINT,handle_signal_z)\n    start = funation()\n    while True:\n        start.event()\n```"}, "/soft/maixpy3/zh/usage/Audio/speech.html": {"title": "", "content": ""}, "/soft/maixpy3/zh/usage/Audio/audio.html": {"title": "音频操作", "content": "---\ntitle: 音频操作\nkeywords: 音频操作, MaixPy3, Python, Python3\ndesc: maixpy doc: 音频操作\n---\n\nMaixPy3 整合了 pyaudio 库，可以通过使用 pyaudio 库进行音频播放，录音等操作\n\n\n## 录音操作\n\n```python\nimport pyaudio\nimport wave\n\nCHUNK = 1024\nFORMAT = pyaudio.paInt16\nCHANNELS = 2\nRATE = 44100\nRECORD_SECONDS = 5\nWAVE_OUTPUT_FILENAME = \"output.wav\"\n\np = pyaudio.PyAudio()\n\nstream = p.open(format=FORMAT,\n                channels=CHANNELS,\n                rate=RATE,\n                input=True,\n                frames_per_buffer=CHUNK)\n\nprint(\"* recording\")\n\nframes = []\n\nfor i in range(0, int(RATE / CHUNK * RECORD_SECONDS)):\n    data = stream.read(CHUNK)\n    frames.append(data)\n\nprint(\"* done recording\")\n\nstream.stop_stream()\nstream.close()\np.terminate()\n\nwf = wave.open(WAVE_OUTPUT_FILENAME, 'wb')\nwf.setnchannels(CHANNELS)\nwf.setsampwidth(p.get_sample_size(FORMAT))\nwf.setframerate(RATE)\nwf.writeframes(b''.join(frames))\nwf.close()\n```\n\n## 播放音频\n\n```python\n\nimport pyaudio\nimport wave\nimport sys\n\n# 定义数据流块\nCHUNK = 1024\n\nif len(sys.argv) < 2:\n    print(\"Plays a wave file.\\n\\nUsage: %s filename.wav\" % sys.argv[0])\n    sys.exit(-1)\n\n# 只读方式打开wav文件\nwf = wave.open(r'D:\\\\Python\\\\Lib\\\\site-packages\\\\PyQt4\\\\uic\\\\test.wav', 'rb')#(sys.argv[1], 'rb')\n\np = pyaudio.PyAudio()\n\n# 打开数据流\nstream = p.open(format=p.get_format_from_width(wf.getsampwidth()),\n                channels=wf.getnchannels(),\n                rate=wf.getframerate(),\n                output=True)\n\n# 读取数据\ndata = wf.readframes(CHUNK)\n\n# 播放  \nwhile data != '':\n    stream.write(data)\n    data = wf.readframes(CHUNK)\n\n# 停止数据流  \nstream.stop_stream()\nstream.close()\n\n# 关闭 PyAudio  \np.terminate() \n```\n\n## 更多的使用\n\n想了解更多关于 pyaudio 的使用方法，自行百度 pyaudio 的使用教程，这是一个 python 的标准库，网上有很多教程"}, "/soft/maixpy3/zh/usage/net.html": {"title": "net", "content": "---\ntitle: net\nkeywords: MaixPy3,net, Python3\ndesc: maixpy doc: net\n---\n\n## 连接网络\n\npython 中包含着一个 socket 的标准库，可以进行搭建一个简易的 web 服务器，代码如下：\n\n> ifconfig 用来查看 ip 地址\n\n```python\nimport socket\n\nHOST, PORT = '', 8888 # 填上开发板的 ip 地址\n\nlisten_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nlisten_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nlisten_socket.bind((HOST, PORT))\nlisten_socket.listen(1)\nprint('Serving HTTP on port %s ...' % PORT)\nwhile True:\n    client_connection, client_address = listen_socket.accept()\n    request = client_connection.recv(1024)\n    print(request.decode(\"utf-8\"))\n\n    http_response = \"\"\"\\\nHTTP/1.1 200 OK\n\nHello, World!\n\"\"\"\n    client_connection.sendall(http_response.encode(\"utf-8\"))\n    client_connection.close()\n```\n\n在电脑的浏览器输入开发板的 ip + 端口号，即可看到打印出来的信息\n\n\n## 更多的使用方法\n\n请自行的去百度 [python socket](https://www.baidu.com/s?ie=utf-8&f=3&rsv_bp=1&tn=baidu&wd=python%20socket&oq=python%25E6%2590%25AD%25E5%25BB%25BA%25E7%25BD%2591%25E9%25A1%25B5%25E6%259C%258D%25E5%258A%25A1%25E5%2599%25A8&rsv_pq=e64708e3000c8483&rsv_t=f79fUMT%2BuI7wekfW8YPY%2F08rmoG%2BK1vvKzxctjM%2F48hbJ9TyBEHjqePwp3Y&rqlang=cn&rsv_enter=1&rsv_dl=ts_0&rsv_sug3=12&rsv_sug1=12&rsv_sug7=100&rsv_sug2=0&rsv_btype=t&prefixsug=python%2520soc&rsp=0&inputT=3909&rsv_sug4=4389c) 的教程，自行学习"}, "/soft/maixpy3/zh/usage/08_V831_resnet_copy.html": {"title": "resnet18分类", "content": "# resnet18分类\n\n在V831上（awnn）跑 pytorch resnet18 模型， 模型转换方法\n\n## 直接使用 pytorch hub 的与训练模型\n这里省略了模型定义和训练过程， 直接使用 pytorch hub 的 resnet18 预训练模型进行简单介绍：\nhttps://pytorch.org/hub/pytorch_vision_resnet/\n\n## 在 PC 端测试模型推理\n根据上面链接的使用说明， 使用如下代码可以运行模型\n\n其中， label 下载： https://raw.githubusercontent.com/pytorch/hub/master/imagenet_classes.txt\n```python\nimport os\nimport torch\nfrom torchsummary import summary\ntorch.hub._validate_not_a_forked_repo=lambda a,b,c: True\n## model\nmodel = torch.hub.load('pytorch/vision:v0.6.0', 'resnet18', pretrained=True)\nmodel.eval()\ninput_shape = (3, 224, 224)\nsummary(model, input_shape, device=\"cpu\")\n## test image\nfilename = \"out/dog.jpg\"\nif not os.path.exists(filename):\n    if not os.path.exists(\"out\"):\n        os.makedirs(\"out\")\n    import urllib\n    url, filename = (\"https://github.com/pytorch/hub/raw/master/images/dog.jpg\", filename)\n    try: urllib.URLopener().retrieve(url, filename)\n    except: urllib.request.urlretrieve(url, filename)\nprint(\"test image:\", filename)\n## preparing input data\nfrom PIL import Image\nimport numpy as np\nfrom torchvision import transforms\ninput_image = Image.open(filename)\n# input_image.show()\npreprocess = transforms.Compose([\n    transforms.Resize(max(input_shape[1:3])),\n    transforms.CenterCrop(input_shape[1:3]),\n    transforms.ToTensor(),\n    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),\n])\ninput_tensor = preprocess(input_image)\nprint(\"input data max value: {}, min value: {}\".format(torch.max(input_tensor), torch.min(input_tensor)))\ninput_batch = input_tensor.unsqueeze(0) # create a mini-batch as expected by the model\n## forward model\n# move the input and model to GPU for speed if available\nif torch.cuda.is_available():\n    input_batch = input_batch.to('cuda')\n    model.to('cuda')\nwith torch.no_grad():\n    output = model(input_batch)\n## result    \n# Tensor of shape 1000, with confidence scores over Imagenet's 1000 classes\n# print(output[0])\n# The output has unnormalized scores. To get probabilities, you can run a softmax on it.\nmax_1000 = torch.nn.functional.softmax(output[0], dim=0)\nmax_idx = int(torch.argmax(max_1000))\nwith open(\"imagenet_classes.txt\") as f:\n    labels = f.read().split(\"\\n\")\nprint(\"result: idx:{}, name:{}\".format(max_idx, labels[max_idx]))\n```\n运行后 结果：\n\n```bash\nUsing cache found in /home/neucrack/.cache/torch/hub/pytorch_vision_v0.6.0\n----------------------------------------------------------------\n        Layer (type)               Output Shape         Param #\n================================================================\n            Conv2d-1         [-1, 64, 112, 112]           9,408\n       BatchNorm2d-2         [-1, 64, 112, 112]             128\n              ReLU-3         [-1, 64, 112, 112]               0\n         MaxPool2d-4           [-1, 64, 56, 56]               0\n            Conv2d-5           [-1, 64, 56, 56]          36,864\n       BatchNorm2d-6           [-1, 64, 56, 56]             128\n              ReLU-7           [-1, 64, 56, 56]               0\n            Conv2d-8           [-1, 64, 56, 56]          36,864\n       BatchNorm2d-9           [-1, 64, 56, 56]             128\n             ReLU-10           [-1, 64, 56, 56]               0\n       BasicBlock-11           [-1, 64, 56, 56]               0\n           Conv2d-12           [-1, 64, 56, 56]          36,864\n      BatchNorm2d-13           [-1, 64, 56, 56]             128\n             ReLU-14           [-1, 64, 56, 56]               0\n           Conv2d-15           [-1, 64, 56, 56]          36,864\n      BatchNorm2d-16           [-1, 64, 56, 56]             128\n             ReLU-17           [-1, 64, 56, 56]               0\n       BasicBlock-18           [-1, 64, 56, 56]               0\n           Conv2d-19          [-1, 128, 28, 28]          73,728\n      BatchNorm2d-20          [-1, 128, 28, 28]             256\n             ReLU-21          [-1, 128, 28, 28]               0\n           Conv2d-22          [-1, 128, 28, 28]         147,456\n      BatchNorm2d-23          [-1, 128, 28, 28]             256\n           Conv2d-24          [-1, 128, 28, 28]           8,192\n      BatchNorm2d-25          [-1, 128, 28, 28]             256\n             ReLU-26          [-1, 128, 28, 28]               0\n       BasicBlock-27          [-1, 128, 28, 28]               0\n           Conv2d-28          [-1, 128, 28, 28]         147,456\n      BatchNorm2d-29          [-1, 128, 28, 28]             256\n             ReLU-30          [-1, 128, 28, 28]               0\n           Conv2d-31          [-1, 128, 28, 28]         147,456\n      BatchNorm2d-32          [-1, 128, 28, 28]             256\n             ReLU-33          [-1, 128, 28, 28]               0\n       BasicBlock-34          [-1, 128, 28, 28]               0\n           Conv2d-35          [-1, 256, 14, 14]         294,912\n      BatchNorm2d-36          [-1, 256, 14, 14]             512\n             ReLU-37          [-1, 256, 14, 14]               0\n           Conv2d-38          [-1, 256, 14, 14]         589,824\n      BatchNorm2d-39          [-1, 256, 14, 14]             512\n           Conv2d-40          [-1, 256, 14, 14]          32,768\n      BatchNorm2d-41          [-1, 256, 14, 14]             512\n             ReLU-42          [-1, 256, 14, 14]               0\n       BasicBlock-43          [-1, 256, 14, 14]               0\n           Conv2d-44          [-1, 256, 14, 14]         589,824\n      BatchNorm2d-45          [-1, 256, 14, 14]             512\n             ReLU-46          [-1, 256, 14, 14]               0\n           Conv2d-47          [-1, 256, 14, 14]         589,824\n      BatchNorm2d-48          [-1, 256, 14, 14]             512\n             ReLU-49          [-1, 256, 14, 14]               0\n       BasicBlock-50          [-1, 256, 14, 14]               0\n           Conv2d-51            [-1, 512, 7, 7]       1,179,648\n      BatchNorm2d-52            [-1, 512, 7, 7]           1,024\n             ReLU-53            [-1, 512, 7, 7]               0\n           Conv2d-54            [-1, 512, 7, 7]       2,359,296\n      BatchNorm2d-55            [-1, 512, 7, 7]           1,024\n           Conv2d-56            [-1, 512, 7, 7]         131,072\n      BatchNorm2d-57            [-1, 512, 7, 7]           1,024\n             ReLU-58            [-1, 512, 7, 7]               0\n       BasicBlock-59            [-1, 512, 7, 7]               0\n           Conv2d-60            [-1, 512, 7, 7]       2,359,296\n      BatchNorm2d-61            [-1, 512, 7, 7]           1,024\n             ReLU-62            [-1, 512, 7, 7]               0\n           Conv2d-63            [-1, 512, 7, 7]       2,359,296\n      BatchNorm2d-64            [-1, 512, 7, 7]           1,024\n             ReLU-65            [-1, 512, 7, 7]               0\n       BasicBlock-66            [-1, 512, 7, 7]               0\nAdaptiveAvgPool2d-67            [-1, 512, 1, 1]               0\n           Linear-68                 [-1, 1000]         513,000\n================================================================\nTotal params: 11,689,512\nTrainable params: 11,689,512\nNon-trainable params: 0\n----------------------------------------------------------------\nInput size (MB): 0.57\nForward/backward pass size (MB): 62.79\nParams size (MB): 44.59\nEstimated Total Size (MB): 107.96\n----------------------------------------------------------------\nout/dog.jpg\ntensor(2.6400) tensor(-2.1008)\nidx:258, name:Samoyed, Samoyede\n```\n\n可以看到模型有 11,689,512的参数， 即 11MiB左右， 这个大小也就几乎是实际在 831 上运行的模型的大小了\n\n## 将模型转换为 V831 能使用的模型文件\n转换过程如下：\n\n使用 Pytorch 将模型导出为 onnx模型， 得到onnx文件\n```python\ndef torch_to_onnx(net, input_shape, out_name=\"out/model.onnx\", input_names=[\"input0\"], output_names=[\"output0\"], device=\"cpu\"):\n    batch_size = 1\n    if len(input_shape) == 3:\n        x = torch.randn(batch_size, input_shape[0], input_shape[1], input_shape[2], dtype=torch.float32, requires_grad=True).to(device)\n    elif len(input_shape) == 1:\n        x = torch.randn(batch_size, input_shape[0], dtype=torch.float32, requires_grad=False).to(device)\n    else:\n        raise Exception(\"not support input shape\")\n    print(\"input shape:\", x.shape)\n    # torch.onnx._export(net, x, \"out/conv0.onnx\", export_params=True)\n    torch.onnx.export(net, x, out_name, export_params=True, input_names = input_names, output_names=output_names)\nonnx_out=\"out/resnet_1000.onnx\"\nncnn_out_param = \"out/resnet_1000.param\"\nncnn_out_bin = \"out/resnet_1000.bin\"\ninput_img = filename\ntorch_to_onnx(model, input_shape, onnx_out, device=\"cuda:0\")\n```\n\n如果你不是使用 pytorch 转换的, 而是使用了现成的 ncnn 模型, 不知道输出层的名字, 可以在 https://netron.app/ 打开模型查看输出层的名字\n\n## 使用 onnx2ncnn 工具将onnx转成ncnn模型，得到一个.param文件和一个.bin文件\n按照ncnn项目的编译说明编译，在build/tools/onnx目录下得到onnx2ncnn可执行文件\n```python\ndef onnx_to_ncnn(input_shape, onnx=\"out/model.onnx\", ncnn_param=\"out/conv0.param\", ncnn_bin = \"out/conv0.bin\"):\n    import os\n    # onnx2ncnn tool compiled from ncnn/tools/onnx, and in the buld dir\n    cmd = f\"onnx2ncnn {onnx} {ncnn_param} {ncnn_bin}\"\n    os.system(cmd)\n    with open(ncnn_param) as f:\n        content = f.read().split(\"\\n\")\n        if len(input_shape) == 1:\n            content[2] += \" 0={}\".format(input_shape[0])\n        else:\n            content[2] += \" 0={} 1={} 2={}\".format(input_shape[2], input_shape[1], input_shape[0])\n        content = \"\\n\".join(content)\n    with open(ncnn_param, \"w\") as f:\n        f.write(content)\nonnx_to_ncnn(input_shape, onnx=onnx_out, ncnn_param=ncnn_out_param, ncnn_bin=ncnn_out_bin)\n```\n## 使用全志提供的awnn工具将ncnn模型进行量化到int8模型\n在 maixhub 模型转换 将 ncnn 模型转换为 awnn 支持的 int8 模型 （网页在线转换很方便人为操作，另一个方面因为全志要求不开放 awnn 所以暂时只能这样做）\n\n阅读转换说明，可以获得更多详细的转换说明\n![](./asserts/maixhub.jpg)\n\n这里有几组参数：\n\n均值 和 归一化因子： 在 pytorch 中一般是 (输入值 - mean ) / std, awnn对输入的处理是 (输入值 - mean ) * norm, 总之，让你训练的时候的输入到第一层网络的值范围和给awnn量化工具经过(输入值 - mean ) * norm 计算后的值范围一致既可。 比如 这里打印了实际数据的输入范围是[-2.1008, 2.6400]， 是代码中preprocess 对象处理后得到的，即x = (x - mean) / std ==> (0-0.485)/0.229 = -2.1179, 到awnn就是x = (x - mean_2*255) * (1 / std * 255) 即 mean2 = mean * 255, norm = 1/(std * 255), 更多可以看这里。\n所以我们这里可以设置 均值为 0.485 * 255 = 123.675， 设置 归一化因子为1/ (0.229 * 255) = 0.017125， 另外两个通道同理，但是目前 awnn 只能支持三个通道值一样。。。所以填123.675, 123.675, 123.675，0.017125, 0.017125, 0.017125 即可，因为这里用了pytorch hub的预训练的参数，就这样吧， 如果自己训练，可以好好设置一下\n\n图片输入层尺寸（问不是图片怎么办？貌似 awnn 暂时之考虑到了图片。。）\n\nRGB 格式： 如果训练输入的图片是 RGB 就选 RGB\n量化图片， 选择一些和输入尺寸相同的图片，可以从测试集中拿一些，不一定要图片非常多，但尽量覆盖全场景（摊手\n自己写的其它模型转换如果失败，多半是啥算子不支持，需要在 使用说明里面看支持的 算子，比如现在的版本view、 flatten、reshape 都不支持所以写模型要相当小心， 后面的版本会支持 flatten reshape 等 CPU 算子\n\n如果不出意外， 终于得到了量化好的 awnn 能使用的模型， *.param 和 *.bin\n\n## 使用模型，在v831上推理\n可以使用 python 或者 C 写代码，以下两种方式\n\n### MaixPy3\npython 请看MaixPy3\n\n不想看文档的话，就是在系统开机使用的基础上， 更新 MaixPy3 就可以了：\n\n    pip install --upgrade maixpy3\n\n然后在终端使用 python 运行脚本（可能需要根据你的文件名参数什么的改一下代码）：\n\nhttps://github.com/sipeed/MaixPy3/blob/main/ext_modules/_maix_nn/example/load_forward_camera.py\n\nlabel 在这里： https://github.com/sipeed/MaixPy3/blob/main/ext_modules/_maix_nn/example/classes_label.py\n```python\nfrom maix import nn\nfrom PIL import Image, ImageDraw\nfrom maix import camera, display\ntest_jpg = \"/root/test_input/input.jpg\"\nmodel = {\n    \"param\": \"/root/models/resnet_awnn.param\",\n    \"bin\": \"/root/models/resnet_awnn.bin\"\n}\ncamera.config(size=(224, 224))\noptions = {\n    \"model_type\":  \"awnn\",\n    \"inputs\": {\n        \"input0\": (224, 224, 3)\n    },\n    \"outputs\": {\n        \"output0\": (1, 1, 1000)\n    },\n    \"first_layer_conv_no_pad\": False,\n    \"mean\": [127.5, 127.5, 127.5],\n    \"norm\": [0.00784313725490196, 0.00784313725490196, 0.00784313725490196],\n}\nprint(\"-- load model:\", model)\nm = nn.load(model, opt=options)\nprint(\"-- load ok\")\nprint(\"-- read image\")\nimg = Image.open(test_jpg)\nprint(\"-- read image ok\")\nprint(\"-- forward model with image as input\")\nout = m.forward(img, quantize=True)\nprint(\"-- read image ok\")\nprint(\"-- out:\", out.shape)\nout = nn.F.softmax(out)\nprint(out.max(), out.argmax())\nfrom classes_label import labels\nwhile 1:\n    img = camera.capture()\n    if not img:\n        time.sleep(0.02)\n        continue\n    out = m.forward(img, quantize=True)\n    out = nn.F.softmax(out)\n    msg = \"{:.2f}: {}\".format(out.max(), labels[out.argmax()])\n    print(msg)\n    draw = ImageDraw.Draw(img)\n    draw.text((0, 0), msg, fill=(255, 0, 0))\n    display.show(img)\n```\n\n### C语言 SDK， libmaix\n访问这里，按照 https://github.com/sipeed/libmaix 的说明克隆仓库，并编译 https://github.com/sipeed/libmaix/tree/master/examples/nn_resnet\n\n上传编译成功后dist目录下的所有内容到 v831, 然后执行./start_app.sh即可\n\n> 以上内容出至：<https://neucrack.com/p/358>"}, "/soft/maixpy3/zh/usage/camera/camera.html": {"title": "摄像头", "content": "# 摄像头\n\nMaixPy3 目前所兼容的摄像头是依赖硬件平台，不能进行随意切换，如果有需要的可以进行商务定制，联系方式<support@sipeed.com>\n\n## 使用摄像头拍摄一张图并显示\n\n使用前面所介绍的开发工具进入到 Maixpy3 的环境中，复制并运行一下代码\n```python\nfrom maix import display, camera\ndisplay.show(camera.capture())\n```\n\n屏幕上就会打印出摄像头所拍摄到的第一帧画面\n![](./../asserts/camera_test.jpg)\n\n## 屏幕实时显示摄像头拍摄画面\n```python\nfrom maix import display, camera\nwhile True:\n    display.show(camera.capture())\n```\n![](./../asserts/camera_1.gif)\n\n可以通过 Ctrl + C 将其停止下来\n\n## 拍摄图片并保存下来\n\n运行一下代码可以直接\n\n```python\nfrom maix import camera, display\nimg = camera.capture()\nimg.save('/mnt/UDISK/123.jpg')\ndisplay.show(img)\n```\n\n拍摄后的照片会保存在 /mnt/UDISK 文件下，可以通过 SSH、FTP、ADB 等链接方式将文件取出来。"}, "/soft/maixpy3/zh/usage/camera/link.html": {"title": "巡线识别", "content": "# 巡线识别\n\n对于传统的智能小车来说，巡线是一个重要的功能， Maixpy3 中内置了巡线函数\n\n> 以下代码由于 Maixpy3 还在优化中，可能不能运行，具体的代码到 [github](https://github.com/sipeed/MaixPy3) 上查看\n\n```python\nfrom maix import camera, image, display\n\nwhile True:\n    img = camera.capture()\n    ma = img.find_line()\n    if ma:\n        img.draw_line(ma['rect'][0], ma['rect'][1], ma['rect'][2], ma['rect'][3], (255,255,225), 1)\n        img.draw_line(ma[\"rect\"][2], ma[\"rect\"][3], ma[\"rect\"][4], ma[\"rect\"][5], (255,255,225), 1)\n        img.draw_line(ma[\"rect\"][4], ma[\"rect\"][5], ma[\"rect\"][6], ma[\"rect\"][7], (255,255,225), 1)\n        img.draw_line(ma[\"rect\"][6], ma[\"rect\"][7], ma[\"rect\"][0], ma[\"rect\"][1], (255,255,225), 1)\n        img.draw_circle(ma[\"cx\"], ma[\"cy\"], 2, (255,255,225), 1)\n    display.show(img)\n```"}, "/soft/maixpy3/zh/usage/camera/color.html": {"title": "颜色识别", "content": "# 颜色识别\n\n## 寻找色块\n\n寻找色块可以通过指定 HSV 阈值，进行颜色的确定，下面的例程代码可以通过修改中的函数参数进行修改寻找的颜色， 以下是 Maixpy3 中内置的颜色，可直接进行调用\n\n    green = [(28,-36,-14,68,-5,15)]  #绿色\n    red = [(20,22,-3,55,52,42)]    #红色\n    yellow = [(35,-6,22,88,5,81)]   #黄色\n    blue = [(13, 11, -91, 54, 48, -28)]  #蓝色\n    white = [(41,6,-32,74,11,-12)]  #白色\n    black = [(10,-3,-28,50,10,-4)]  #黑色\n\n> 以下代码由于 Maixpy3 还在优化中，可能不能运行，具体的代码到 [github](https://github.com/sipeed/MaixPy3) 上查看\n\n```python\nfrom maix import camera, image, display\n\nwhile True:\n    tmp = camera.capture()\n    ma = tmp.find_blobs([(28,-36,-14,68,-5,15)]) # 传入需要寻找颜色的 HSV 值\n    for i in ma:\n        tmp.draw_rectangle(i[\"x\"], i[\"y\"], i[\"x\"] + i[\"w\"], i[\"y\"] + i[\"h\"], (255, 0, 0), 1)\n    display.show(tmp)\n```\n\n\n## 获取颜色值\n\n上述寻找颜色的值，可以通过一下的办法进行识别。\n\n> 以下代码由于 Maixpy3 还在优化中，可能不能运行，具体的代码到 [github](https://github.com/sipeed/MaixPy3) 上查看\n\n```python\nfrom maix import camera, image, display\n\nwhile True:\n    img = camera.capture()\n    ma = img.get_blob_color((110,110,20,20),1)\n    img.draw_string(10, 10, str(ma), 0.5)\n    img.draw_rectangle(110,110, 130, 130, (255, 0, 0), 1) \n    display.show(img)\n```\n\n![缺示例图片]()\n\n颜色在计算机视觉当中是有多种表达形式，如 RBG 、 CMYK、 HSV等\n\n## HSV格式\n\nMaixpy3 中使用的格式是 HSV 格式，通过调整 HSV 中的各个阈值进行识别\n\n![](./../../assets/get_started/HSV.jpg)\n\n- **色调H**\n用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。它们的补色是：黄色为60°，青色为180°,紫色为300°\n\n- **饱和度S**\n饱和度S表示颜色接近光谱色的程度。一种颜色，可以看成是某种光谱色与白色混合的结果。其中光谱色所占的比例愈大，颜色接近光谱色的程度就愈高，颜色的饱和度也就愈高。饱和度高，颜色则深而艳。光谱色的白光成分为0，饱和度达到最高。通常取值范围为0%～100%，值越大，颜色越饱和。\n\n- **明度V**\n明度表示颜色明亮的程度，对于光源色，明度值与发光体的光亮度有关；对于物体色，此值和物体的透射比或反射比有关。通常取值范围为0%（黑）到100%（白）"}, "/soft/maixpy3/zh/usage/01_loop_python.html": {"title": "", "content": "> 本文是给有一点 Python 基础但还想进一步深入的同学，有经验的开发者建议跳过。\n\n## 前言\n\n上文讲述了如何认识开源项目和一些编程方法的介绍，这节主要来说说 Python 代码怎么写的一些演化过程和可以如何写的参考，在现在的 Sipeed 开源社区/社群里，有太多的新手不知道如何写好 Python 代码，尤其是嵌入式中的 Python 代码也是有不少的技巧和观念需要注意的，至少让这篇文章从循环开始说起。\n\n> 可以把本文当作一篇经验之谈，主要是探讨代码稳定性与性能，以及一些计算机知识的拓展。\n\n## 循环执行代码\n\n当写下第一行代码的时候，在电脑上的 Python 解释器运行效果是这样的。\n\n```python\nprint('Hello World')\n```\n\n![](./asserts/win_python.png)\n\n而嵌入式设备上的 python 是通过串口（serial）传出来。\n\n![](./asserts/maix_python.png)\n\n当写完了第一行 `Hello World` 的 `print` 函数，总不能一直复制、粘贴代码吧。\n\n```python\n\nprint('Hello World')\nprint('Hello World')\nprint('Hello World')\nprint('Hello World')\nprint('Hello World')\n\n```\n\n也不是只运行验证功能就好了吧，所以加上了循环（`while`）执行代码。\n\n```python\n\nwhile True:\n    print('Hello World')\n\n```\n\n如果想要稳定一些，最好还要为它加入异常机制，保证它不会因为 Python 代码的运行出错而停下来。\n\n```python\n\nwhile True:\n    try:\n        print('Hello World')\n    except Exception as e:\n        pass\n\n```\n\n### 循环代码中为什么需要异常机制\n\n是不是以为 print 这样的代码就不会出错？其实不然，其实程序越接近底层硬件越容易出错。\n\n从功能上说上文两者之间并没有什么区别，都是输出，但你会发现串口输出可能会出现下面几类情况。\n\n- 串口芯片损坏或线路断路、串口到芯片的通路损坏导致的串口没有数据输出。\n- 串口线路数据不稳定、串口协议（波特率、停止位）等配置错误导致的数据乱码。\n\n这就意味着你会遇到很多来自硬件上的问题，所以要注意到这些意外。\n\n那在软件代码上会发生什么有关于硬件上的意外呢？\n\n通常有无响应、无应答、未连接等不成功的错误，它们是来自 IO 的错误。\n\n- 当网络连接失败后需要超时重连，传输数据通道闲置时需要定时检查心跳数据包。\n- 当配置文件写入后通常会读出来确认真的写入了，也是为了防止出错，可能是存储介质出错，也可能是逻辑出错。\n- 当用户向输入框填了错误数据，不用写怎么判断和处理，不合法的数据抛出异常就行。\n\n因为这些现象太多不确定的可能性，才会需要对代码进行异常捕获机制，来决定是否放过这次意外，可能会在下一次的循环就恢复了，这样就能够基本保证了 Python 代码循环的稳定性了。\n\n### 来自外部/硬件上异常机制\n\n这样就足够了吗？\n\n事实上有些错误不源于 Python 代码，可能来自于底层 C 代码，或其他程序，上文说的异常机制只能捕获 Python 异常，不能捕获来自其他语言的异常。\n\n所以实际情况比想象的要更严峻一些，当你无法解决不稳定的系统带来其他异常的时候，通常在服务器程序上设计会在外部附加一个守护程序（如调试程序）来定时检查自己的程序，例如可以检查下面的一些情况。\n\n- 检查当前的系统是否能联网\n- 检查数据库的通路是否正常\n- 检查指定的程序是否在运行\n\n总得来说，你要为你的程序做一个监控程序，可以是守护程序，也可以是看门狗。\n\n> 具体怎么实现，可以了解一些守护进程的实现。\n\n### 看门狗（watchdog）是什么？\n\n如上述的守护程序是靠一个软件去监控另一个软件的状态，而看门狗的工作行为描述如下：\n\n假设有一条需要定时吃饭（更新）的狗、如果不定时喂它（feed）就会饿着肚子叫。那么问题来了，什么时候狗会叫呢？因为人（芯片）死了，没人喂它了。（这也许是一个冷笑话）\n\n看门狗是要求芯片程序负责定时喂狗，如果没有喂狗就狗就饿死了，作为报复狗会把芯片重启。让它可以继续喂狗。\n\n任何硬件产品都有可能出现意外和错误，看门狗相当于芯片上的最后一层保障机制，通常它可能会发生在函数栈的指针参数执行出错，导致后续的喂狗操作再也执行不到了，具体怎么实现，可以查阅不同芯片提供的程序接口或寄存器。\n\n### 优化！优化！！优化！！！\n\n当你的程序已经跑起来以后，你会发现程序并没有达到令人满意的效果，在性能、内存上都没有经过任何考虑，只是实现了最起码的功能而已，那么完成了功能以后，可以如何继续呢？\n\n当然，在优化程序之前得先建立计算代码执行时间的观念，建立起最简单的性能指标，如在代码加上时间计算。\n\n```python\ndef func():\n    i = 20**20000\n\nimport time\nlast = time.time()\nfunc()\ntmp = time.time() - last\nprint(tmp)\n```\n\n在 CPU I5-7300HQ 的计算机上见到每一次的循环的时间间隔约为 0.000997781753540039 不足 1ms 即可完成。\n\n```bash\nPS C:\\Users\\dls\\Documents\\GitHub\\MaixPy3> & C:/Users/dls/anaconda3/python.exe c:/Users/dls/Documents/GitHub/MaixPy3/test.py\n0.000997781753540039\n```\n\n注意不要写到 `print(time.time() - last)` ，因为重定向后的 print 是相当耗时的，尤其是当内容输出到串口终端或网页前端的时候，如下使用 M2dock 设备来演示一下串口输出。\n\n> 重定向指改变内容要输出的地方\n\n```bash\nroot@sipeed:/# python3\nPython 3.8.5 (default, Jan 17 2021, 06:07:56)\n[GCC 6.4.1] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> def func():\n...     i = 20**20000\n...\n>>> import time\n>>> last = time.time()\n>>> func()\n>>> tmp = time.time() - last\n>>> print(tmp)\n0.09001994132995605\n>>>\n>>>\n>>> def func():\n...     i = 20**20000\n...\n>>> import time\n>>> last = time.time()\n>>> func()\n>>> print(time.time() - last)\n1.480057954788208\n>>>\n```\n\n可以看到相差可能有 1 秒，而事实上只需要 90ms 就可以完成 func 函数的运算，这就产生了误差导致不准确，若是使用 jupyter 输出就会看到 0.026456356048583984 需要 26ms 可以较为准确的推算出它的真实运算结果。\n\n![](./asserts/time_python.png)\n\n为什么会造成这种差异的原因是因为串口依次输入命令输出结果需要时间，所以依次输入语句执行自然会存在误差，而 jupyter 是通过网络 socket 连接传输显示到屏幕上，所以耗时误差只会发生在运算重定向输出结果的时候，最终结果会较为贴近真实运算结果，通过保存下述代码文件来运行即可得知真实情况下约为 26 ~ 28ms 完成。\n\n```bash\nroot@sipeed:/# cat test.py\ndef func():\n    i = 20**20000\n\nimport time\nlast = time.time()\nfunc()\ntmp = time.time() - last\nprint(tmp)\n\nroot@sipeed:/# python test.py\n0.028677940368652344\nroot@sipeed:/#\n```\n\n所以从现在建立起最基础的计算耗时，并且认知到在计算机的世界里，毫秒其实已经很慢了，然后可以类比一种感受，人眼感到流畅的画面至少是 24 fps ，而平时的视频在 15 fps 的流动是不会让你感受到卡顿的，如果低于这个阈值，则会出现卡顿造成心理上的不愉快，这个 15 fps 意味着每秒 15 张存在变化的画面，如果用程序来类比就是 1000 ms / 15 = 66 ms ，也就是每个流程操作最好是在 66ms 内完成，这样用户才不会觉得卡顿，同理，当 1000ms / 24 = 41ms 就可以确保用户体验这个软件的时候会觉得流畅。\n\n有了基本的性能指标，就有了优化的对比参考，如果是一些测试框架会帮助你自动完成每个函数的耗时统计，但在没有现成框架工具的时候就要稍微辛苦一下自己了。\n\n#### 讲一些经典案例\n\n在日常中存在最多操作就是循环和判断，显然好的优化就是减少不必要的指令操作，可以通过改变代码的执行结构来进行优化，下面就来具体分析吧。\n\n如某个向网络上发送数据的操作，最初可能会按人类直觉写出以下的代码，这是一种不用思考也可以很容易写出来的同步阻塞式的结构，每一条语句都是满足了某些条件再继续执行。\n\n```python\n\ndef xxxx_func():\n    import random\n    return random.randint(0, 1)\n\nwhile True:\n    is_idle = True\n    if is_idle is True:\n        print('try start')\n        is_ready = xxxx_func()\n        if is_ready is True:\n            print('try ready')\n            is_connected = xxxx_func()\n            if is_connected is True:\n                print('try connect')\n                is_send = xxxx_func()\n                if is_send is True:\n                    print('try send')\n                    is_reply = xxxx_func()\n                    if is_reply is True:\n                        print('wait reply')\n                        is_exit = xxxx_func()\n                        if is_exit is True:\n                            print('operate successfully')\n```\n\n而优化只需要加状态变量改写成状态机结构（fsm）就可以了，所有代码都可以平行化执行，并根据执行频率的重要程度（权重）调整各项判断的顺序，尤其是移除一些不必要的判断。\n\n```python\ndef xxxx_func():\n    return 1\n\n# state value\nis_idle, is_ready, is_connected, is_send, is_reply, is_exit = 0, 1, 2, 3, 4, 5 \nstate = is_idle\n\nwhile state != is_exit:\n\n    if state is is_reply:\n        print('wait reply')\n        state = is_exit if xxxx_func() else is_send\n        continue\n\n    if state is is_send:\n        print('try send')\n        state = is_reply if xxxx_func() else is_connected\n        continue\n\n    if state is is_connected:\n        print('try connect')\n        state = is_send if xxxx_func() else is_ready\n        continue\n\n    if state is is_ready:\n        print('try ready')\n        state = is_connected if xxxx_func() else is_idle\n        continue\n\n    if state is is_idle:\n        print('try start')\n        state = is_ready\n        continue\n```\n\n这样改造执行结构后，每个代码之间的上下文关系并不强烈，是否执行某个语句取决于系统对于某个状态是否满足，如果状态失败也不会倒退回最初的判断，也就不需要每次都对各个状态做检查，检查只会发生在出错的时候状态跌落（state - 1）。\n\n缺点就是需要消耗一些记录状态的变量(●'◡'●)，不过代码的拓展性和维护性就上来了。\n\n> 可以根据实际情况增加状态的判断或是减少状态的转移（调整状态转移范围），如直接设置 state = is_ready，假设某些操作是已知的就可以跳过，可以添加 continue 跳过一些不可能发生的状态。\n\n#### 还有吗？\n\n进一步优化还可以干掉 if 直接将状态与函数联合索引执行，简化代码如下。\n\n```python\n\nis_a, is_b, is_c = 0, 1, 2\n\nstate = is_a\n\ndef try_b():\n    global state\n    state = is_c\n\ndef try_a():\n    global state\n    state = is_b\n\nfunc = [try_a, try_b]\n\nwhile state != is_c:\n    func[state]()\n    # print(state)\n\n```\n\n基于上述结构给出一个示例代码参考。\n\n```python\n\nclass xxxx_fsm:\n            \n    is_start, is_ready, is_connected, is_send, is_reply, is_exit = 0, 1, 2, 3, 4, 5\n\n    def xxxx_func(self):\n        return 1\n\n    def __init__(self):\n        self.func = [self.try_start, self.try_ready, self.try_connect, self.try_send, self.wait_reply]\n        self.state = __class__.is_start # state value\n\n    def wait_reply(self):\n        self.state = __class__.is_exit if self.xxxx_func() else __class__.is_send\n\n    def try_send(self):\n        self.state = __class__.is_reply if self.xxxx_func() else __class__.is_connected\n\n    def try_connect(self):\n        self.state = __class__.is_send if self.xxxx_func() else __class__.is_ready\n\n    def try_ready(self):\n        self.state = __class__.is_connected if self.xxxx_func() else __class__.is_start\n\n    def try_start(self):\n        self.state = __class__.is_ready\n\n    def event(self):\n        self.func[self.state]()\n\n    def check(self):\n        return self.state != __class__.is_exit\n\ntmp = xxxx_fsm()\n\nwhile tmp.check():\n\n    tmp.event()\n\n    # print(tmp.state)\n```\n\n其实上述的有限状态机并非万能的代码结构，只是刚好很适合拆分已知的复杂业务逻辑的同步阻塞代码，那么还有什么结构可以选择吗？有的，此前说的都是同步阻塞的代码，所以还有所谓的异步执行的代码。\n\n#### 说说异步的执行方式\n\n在这之前的代码都是按每个循环的步骤有序执行完成功能（同步执行），但现实生活中的操作一定是按顺序发生的吗？其实不然，其实很多操作可能会在任意时刻发生。\n\n想象一个程序，它会响应来自网络的数据，也会响应来自人类的按键输入操作，这两个操作如果按上述的结构来写，可能会是下面这样。\n\n```python\nimport time, random\n\ndef check_http():\n    time.sleep(random.randint(0, 3))\n    return random.randint(0, 1)\n\ndef http_recv():\n    while True:\n        if check_http():\n            print('http_recv')\n            break\n\ndef check_key():\n    time.sleep(random.randint(0, 2))\n    return random.randint(0, 1)\n\ndef key_press():\n    while True:\n        if check_key():\n            print('key_press')\n            break\n\nwhile True:\n    http_recv()\n    key_press()\n```\n\n可以看到 http_recv 和 key_press 两个事件的检查会各自占据一段不知何时会触发或结束的检测的时间，程序只能循环等待这些事件会不会发生（或称轮询）。\n\n这是个看起来可以工作但浪费了很多时间的程序，现实里接收到许多用户的网络连接，而服务程序不可能只服务某个用户的连接。\n\n所以改写异步的第一步就是简化代码中不必要的循环，将每个需要循环等待的部分拆分成非阻塞的函数。\n\n> 非阻塞意味着某个操作会在有限的时间内结束，期望某个函数能够在较短的时间（10ms）内退出，退出不代表功能结束，只是需要把这个时间让出去给其他函数调用。\n\n```python\nimport time, random\n\nhttp_state, key_state = 0, 0\n\ndef http_recv():\n    global http_state\n    if http_state:\n        print('http_recv')\n\ndef key_press():\n    global key_state\n    if key_state:\n        print('key_press')\n\ndef check_state():\n    global key_state, http_state\n    time.sleep(random.randint(0, 1))\n    key_state, http_state = random.randint(0, 2), random.randint(0, 2)\n\nwhile True:\n    check_state()\n    http_recv()\n    key_press()\n```\n\n从逻辑上移除了等待，再通过统一的（check_state）检查每个操作的状态再决定是否唤醒该操作，变成只有满足某个状态才执行该操作，将此前的多个循环拆分出来。\n\n但你会发现这样写还是有问题，这样岂不是意味着所有代码都要按这个接口来写了吗？那么多的代码，不可能全都可以拆分吧。\n\n所以是时候加入异步 IO （asyncio）的 async 和 await 语法了！先来点简单的。\n\n```python\nimport asyncio\n\nasync def test_task(name, tm):\n    await asyncio.sleep(tm)\n    print('%s over...' % name)\n\nasync def main(name):\n    import time\n    last = time.time()\n    await asyncio.gather(\n        test_task(name + 'A', 0.1),\n        test_task(name + 'B', 0.2),\n        test_task(name + 'C', 0.3),\n    )\n    print(name, time.time() - last)\n\nloop = asyncio.get_event_loop()\ntasks = [ main('l: '), main('r: ') ]\nloop.run_until_complete(asyncio.wait(tasks))\n\n```\n\n运行结果如下：\n\n```bash\nPS python.exe test.py\nr: A over...\nl: A over...\nr: B over...\nl: B over...\nr: C over...\nl: C over...\nr:  0.3076450824737549\nl:  0.3076450824737549\n```\n\n可以看到代码总共耗时为 0.3s 完成，但运行了两次不同所属的 main 函数以及各自调用三次不同延时的 test_task 任务，而 await asyncio.sleep(tm) 延时期间实际上是被 asyncio 拿去运行其他的 async 函数了，基于此结构可以这样改写。\n\n```python\n\nimport asyncio, random\n\nasync def key_press():\n    await asyncio.sleep(0.1)\n    key_state = random.randint(0, 1)\n    if key_state:\n        return 'have key_press'\n\nasync def http_recv():\n    await asyncio.sleep(0.2)\n    http_state = random.randint(0, 1)\n    if http_state:\n        return 'have http_recv'\n\nasync def run():\n    import time\n    while True:\n        task_list = [http_recv(), key_press()]\n        done, pending = await asyncio.wait(task_list, timeout=random.randint(0, 1) / 2)\n        print(time.time(), [done_task.result() for done_task in done])\n        await asyncio.sleep(0.2) # remove to run too fast.\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(run())\n```\n\n执行效果如下。\n\n```bash\n1615141673.93252 [None, None]\n1615141674.134 [None, 'have http_recv']\n1615141674.3350334 [None, None]\n1615141674.7361133 ['have key_press', 'have http_recv']\n1615141674.9365196 [None, None]\n1615141675.1399093 ['have http_recv', None]\n```\n\n可以看到在运行 run 函数延时 `await asyncio.sleep(0.2)` 后就会循环加载异步事件函数执行，配置 asyncio.wait 函数的参数 `timeout` 会导致 `random.randint(0, 1) / 2` 秒后就会自行超时退出，退出的时候会收集当前的 `key_press` 和 `http_recv` 函数的运行结果，如果期间异步函数成功返回值（`return 'have http_recv'`），最终结果就会输出 `1615138982.9762554 ['have http_recv']` 表示有事件触发并执行了，否则为 None ，这将在下一次循环重新提交异步函数列表 `[http_recv(), key_press()]` 执行。\n\n> 注意 Python 3.7 以前的版本使用 loop = asyncio.get_event_loop() & loop.run_forever() & loop.run_until_complete() ，而后采用 asyncio.run() 了。每个编程语言都有自己的异步框架和语法特色，请根据实际情况选用。\n\n### 考虑一下封装模块给其他人使用吧？\n\n随着代码越写越多，项目越来越大，大到可能不是你一个人写的时候，你就要开始注意工程项目的管理了，这与个人写代码时的优化略微不同，主要强调的是不同代码之间的接口分离，尽量不干涉到他人的实现和提交，所以在写代码的时候，不妨为自己准备一个独立模块，以方便与其他人写的分离或是导入其他（import）模块。\n\n若是在某个目录（`mod`）下存在一个 `__init__.py` 的话，它就会变成 Python 模块，且名为 `mod` ，其中 `__init__.py` 的内容可能如下：\n\n```python\ndef code():\n    print('this is code')\n```\n\n而且在该目录下还存在一个额外的代码文件（如 `tmp.py` ）内容如下：\n\n```python\ninfo = 'nihao'\n```\n\n对于开发者或用户来说，在 `import mod` 的时候会调用 `mod` 目录下的 `__init__.py` ，而 `from mod import tmp` 会调用 `mod` 目录下的 `tmp.py` 代码。\n\n```python\n>>> import mod\n>>> mod\n<module 'mod' from 'C:\\\\mod\\\\__init__.py'>\n>>> mod.code()\nthis is code\n>>> from mod import tmp\n>>> tmp\n<module 'mod.tmp' from 'C:\\\\mod\\\\tmp.py'>\n>>> tmp.info\n'nihao'\n>>>\n```\n\n这样你写的代码就可以作为一个模块被其他人所使用了，注意 import 只会加载并执行一次，想要再次加载请使用 reload 函数。\n\n### 如何进行内存上的分析？\n\n这里就推荐 [memory_profiler](https://github.com/pythonprofilers/memory_profiler) 开源工具，快去体验吧。\n\n使用方法：`python -m memory_profiler example.py`\n\n```python\nfrom memory_profiler import profile\n\n@profile\ndef my_func():\n    a = [1] * (10 ** 6)\n    b = [2] * (2 * 10 ** 7)\n    del b\n    return a\n```\n\n运行结果：\n\n```bash\nLine #    Mem usage    Increment  Occurences   Line Contents\n============================================================\n     3   38.816 MiB   38.816 MiB           1   @profile\n     4                                         def my_func():\n     5   46.492 MiB    7.676 MiB           1       a = [1] * (10 ** 6)\n     6  199.117 MiB  152.625 MiB           1       b = [2] * (2 * 10 ** 7)\n     7   46.629 MiB -152.488 MiB           1       del b\n     8   46.629 MiB    0.000 MiB           1       return a\n```\n\n## 总结\n\n其实所谓的优化就是在程序上不断追求无延迟、零等待、鲁棒性、艺术品、最佳实践等指标。\n\n当完成了自己的某个作品，多少都会希望自己的作品是最好的，又或是越做越好的。熬夜辛苦写下的程序，用尽自己的脑力和各种逻辑思维来不断打磨它，尽可能的把它变成一件艺术品，然后为之自豪和兴奋，恨不得向它人炫耀自己的成果。\n\n但愿你不会在往后的一堆垃圾代码中失去了最初喜欢上编程的心情。\n\n### 附录：多线程？多进程？该不该使用？\n\n事实上多线程和多进程都是建立在操作系统之上的概念，由于操作系统中存在不同优先级的中断函数，其中优先级较高的函数栈会打断优先级低的函数栈执行，并且优先级高的操作结束就会轮到优先级低的操作，优先级高的操作通常都会被设计成尽快结束退出（哪怕是失败），不然用户程序就会像老爷爷一样缓慢运行了。\n\n多线程是由拥有内存空间进程（某个程序）创造出来的，多线程函数“看上去”是彼此并行的，并且共用所属进程的内存数据，而不同进程之间申请的内存空间并不互通，所以当你想要实现守护进程的程序，是需要对其他进程进行通信的（如卸载程序时会检查并发送信号停止要卸载的程序），并非是在代码中修改一个变量那么简单。\n\n事实上我并不鼓励用户在 Python 上使用多线程，因为全局解释器锁（GIL）的存在，CPython 解释器中执行的每一个 Python 线程，都会先锁住自己，以阻止别的线程执行。而 CPython 解释器会去轮询检查线程 GIL 的锁住情况，每隔一段时间，Python 解释器就会强制当前线程去释放 GIL，这样别的线程才能有执行的机会。总得来说 CPython 的实现决定了使用多线程并不会带来太大的性能提升，反而会带来更多线程安全的问题，尤其是需要线程资源同步了。\n\n> 警告：请不要在每个线程中都写上不会退出的死循环，多线程的并不是拿来偷懒的工具。"}, "/soft/maixpy3/zh/others/product.html": {"title": "如何提交你的产品", "content": "---\ntitle: 如何提交你的产品\nkeywords: MaixPy, MaixPy3, Python, Python3, MicroPython\ndesc: maixpy doc: 如何提交你的产品\n---\n\n当完成了一款芯片平台的适配后，想要合并进 MaixPy3 仓库，本文会对此做出说明。\n\n## 提供你的编译配置\n\n如 [envs/maix_v831.py](https://github.com/sipeed/MaixPy3/blob/main/envs/maix_v831.py) Python 包编译的配置，主要是用于区分适配在 maix 系列的 v831 产品，建议以芯片型号为区分，也许产品定义会不同，这时候就需要示例代码或文档来完成产品功能的区分了。\n\n## 提供你的示例代码\n\n如 [examples](https://github.com/sipeed/MaixPy3/tree/main/examples) 目录下的 maix_v831 文件夹，你可以在这里放置与你平台有关的程序、配置脚本、代码等资源。\n\n## 提供你的相关文档\n\n> 一般情况下可以不提供编译文档说明，这层的差异可能会在交叉编译链时解决，编译命令类似于 `python3.x setup.py xxxxx build` 的结构。\n\n你可以在 [docs](https://github.com/sipeed/MaixPy3/tree/main/docs) 目录下存放公共文档，也可以在 [examples](https://github.com/sipeed/MaixPy3/tree/main/examples) 下的产品文件夹里存放专用的文档。\n\n提供的文档类型可以是 markdown 或 jupyter notebook 文档。\n\n可以提供开发方法、如何编译的文档，也可以提供各类设备特有的示例文档，建议通过 jupyter notebook 文档可以达到所见即所得的效果。\n\n## 关于其他内容\n\n2021年02月24日 现在仓库里还不会收录有关于交叉编译链、量产工具、烧录工具、训练工具等等与代码或文档无关的内容。\n\n若是上述内容有不能够适应其他平台的地方，可以在 issue 里发起讨论，一起探讨和分享如何改进项目结构。\n\n> 快快把你的代码提交进来吧！"}, "/soft/maixpy3/zh/others/develop.html": {"title": "MaixPy3 开发文档", "content": "---\ntitle: MaixPy3 开发文档\nkeywords: MaixPy, MaixPy3, Python, Python3, MicroPython\ndesc: maixpy doc: 如何参与项目（开发文档）\n---\n\nMaixPy3 并不是为了某一款芯片平台制作的，它的初衷就是为了通过 Python 编程简化用户在嵌入式 Linux 上开发程序的过程，所以是建立在所有 Linux 设备都能使用的基础上去设计的，但由于 Sipeed 官方的能力有限，难以同时照顾所有开源硬件的同步开发，所以提供一些官方的基本芯片移植参考，方便第三方的开源爱好者提交其他芯片平台、镜像、工具推送到 MaixPy3 的环境中。\n\n## 一般开发流程\n\n从 MaixPy3 仓库的 [setup.py](https://github.com/sipeed/MaixPy3/blob/main/setup.py) 进行项目的编译。\n\n对于一台 Linux X86 的个人计算机而言，我们使用如下命令进行构建。\n\n- 编译 `python3 setup.py build`\n- 清理 `python3 setup.py clean`\n- 安装 `pip3 install .`\n\n```bash\njuwan@juwan-N85-N870HL:~/Desktop/v831_toolchain_linux_x86/MaixPy3$ python3 setup.py build\nrunning build\nrunning build_py\nrunning egg_info\nwriting MaixPy3.egg-info/PKG-INFO\nwriting dependency_links to MaixPy3.egg-info/dependency_links.txt\nwriting entry points to MaixPy3.egg-info/entry_points.txt\nwriting requirements to MaixPy3.egg-info/requires.txt\nwriting top-level names to MaixPy3.egg-info/top_level.txt\nwriting manifest file 'MaixPy3.egg-info/SOURCES.txt'\nrunning build_ext\njuwan@juwan-N85-N870HL:~/Desktop/v831_toolchain_linux_x86/MaixPy3$ python3 setup.py clean\nrunning clean\njuwan@juwan-N85-N870HL:~/Desktop/v831_toolchain_linux_x86/MaixPy3$ pip3 install .Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple\nProcessing /home/juwan/Desktop/v831_toolchain_linux_x86/MaixPy3\nRequirement already satisfied: Pillow in /usr/lib/python3/dist-packages (from MaixPy3==0.2.9) (7.0.0)\nRequirement already satisfied: evdev in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (1.4.0)\nRequirement already satisfied: gpiod in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (1.4.0)\nRequirement already satisfied: numpy in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (1.19.4)\nRequirement already satisfied: opencv-python in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (4.5.1.48)\nRequirement already satisfied: pyserial in /usr/local/lib/python3.8/dist-packages (from MaixPy3==0.2.9) (3.4)\nRequirement already satisfied: rpyc in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (5.0.1)\nRequirement already satisfied: spidev in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (3.5)\nRequirement already satisfied: plumbum in /home/juwan/.local/lib/python3.8/site-packages (from rpyc->MaixPy3==0.2.9) (1.6.9)\nBuilding wheels for collected packages: MaixPy3\n  Building wheel for MaixPy3 (setup.py) ... done\n  Created wheel for MaixPy3: filename=MaixPy3-0.2.9-cp38-cp38-linux_x86_64.whl size=115611 sha256=54f70f181ccc629f1eaf470bf30eccd20389c6333814d7145e16a31db7f6cdcd\n  Stored in directory: /tmp/pip-ephem-wheel-cache-9bf1q3wt/wheels/53/7d/47/6cd374fab930089f96a0a3185f5677e52a9b71dbbee769935d\nSuccessfully built MaixPy3\nInstalling collected packages: MaixPy3\n  Attempting uninstall: MaixPy3\n    Found existing installation: MaixPy3 0.2.8\n    Uninstalling MaixPy3-0.2.8:\n      Successfully uninstalled MaixPy3-0.2.8\nSuccessfully installed MaixPy3-0.2.9\njuwan@juwan-N85-N870HL:~/Desktop/v831_toolchain_linux_x86/MaixPy3$ \n```\n\n而对于不能在目标平台上编译安装的环境，就需要使用预编译的 whl 包来辅助安装，以 Maix V831 为例。\n\n- 编译 `python3.8 setup.py maix_v831 bdist_wheel`\n\n- 安装 `pip install ./dist/*.whl`\n\n```bash\nroot@sipeed:/# pip install maixpy3 --upgrade\nCollecting maixpy3\n  Downloading MaixPy3-0.1.9-cp38-cp38-linux_armv7l.whl (1.0 MB)\n     |████████████████████████████████| 1.0 MB 43 kB/s \nCollecting pexpect\n  Downloading pexpect-4.8.0-py2.py3-none-any.whl (59 kB)\n     |████████████████████████████████| 59 kB 71 kB/s \nCollecting rpyc\n  Downloading rpyc-5.0.1-py3-none-any.whl (68 kB)\n     |████████████████████████████████| 68 kB 42 kB/s \nRequirement already satisfied, skipping upgrade: Pillow in /usr/lib/python3.8/site-packages (from maixpy3) (7.2.0)\nCollecting ptyprocess>=0.5\n  Downloading ptyprocess-0.7.0-py2.py3-none-any.whl (13 kB)\nCollecting plumbum\n  Downloading plumbum-1.6.9-py2.py3-none-any.whl (115 kB)\n     |████████████████████████████████| 115 kB 84 kB/s \nInstalling collected packages: ptyprocess, pexpect, plumbum, rpyc, maixpy3\nSuccessfully installed maixpy3-0.1.9 pexpect-4.8.0 plumbum-1.6.9 ptyprocess-0.7.0 rpyc-5.0.1\nWARNING: You are using pip version 20.1.1; however, version 21.0 is available.\nYou should consider upgrading via the '/usr/bin/python3 -m pip install --upgrade pip' command.\n\nroot@sipeed:/# \n```\n\n对于一些安装失败，缺少了依赖库的场合，需要从外部去引入该包的安装，例如这个问题 [error happened when install maixpy3](https://github.com/sipeed/MaixPy3/issues/4) ，这通常需要升级镜像来解决，或手动安装相关的依赖包。\n\n至此以后，在发布软件包的时候可以通过 `pip install maixpy3` 让目标机器直接安装 maixpy3 的包即可使用。\n\n## 一般测试流程\n\n项目引入 tox 进行软件接口交互的自动化测试，通常用它进行虚拟 Python 环境测试，确保软件代码的依赖关系和接口逻辑测试，如测试 `from xxx import *` 是否可行。\n\n```bash\njuwan@juwan-N85-N870HL:~/Desktop/v831_toolchain_linux_x86/MaixPy3$ tox\nGLOB sdist-make: /home/juwan/Desktop/v831_toolchain_linux_x86/MaixPy3/setup.py\npy38 inst-nodeps: /home/juwan/Desktop/v831_toolchain_linux_x86/MaixPy3/.tox/.tmp/package/1/MaixPy3-0.1.2.zip\npy38 installed: attrs==20.3.0,iniconfig==1.1.1,packaging==20.8,Pillow==8.1.0,pluggy==0.13.1,py==1.10.0,pyparsing==2.4.7,pytest==6.2.1,MaixPy3 @ file:///home/juwan/Desktop/v831_toolchain_linux_x86/MaixPy3/.tox/.tmp/package/1/MaixPy3-0.1.2.zip,scripttest==1.3,toml==0.10.2\npy38 run-test-pre: PYTHONHASHSEED='820562099'\npy38 run-test: commands[0] | py.test\n======================================= test session starts ========================================\nplatform linux -- Python 3.8.5, pytest-6.2.1, py-1.10.0, pluggy-0.13.1\ncachedir: .tox/py38/.pytest_cache\nrootdir: /home/juwan/Desktop/v831_toolchain_linux_x86/MaixPy3\ncollected 5 items                                                                                  \n\next_modules/_maix/example/test__maix.py .                                                    [ 20%]\ntests/test_maix.py ....                                                                      [100%]\n\n======================================== 5 passed in 0.05s =========================================\n_____________________________________________ summary ______________________________________________\n  py38: commands succeeded\n  congratulations :)\n```\n\n对于硬件模块，通常不好自动化测试，所以会做成 example 提供。\n\n关于代码覆盖性测试，暂时不做。\n\n## 一般发布流程\n\n2021年02月21日 关于自动化构建，还在考虑到导入多个平台的编译链编译的问题，暂时还没有准备好。\n\n## Python 模块编译说明\n\nMaixPy3 使用面向模块接口开发，链接跨平台的 Python 或 C 包，统一加载到 Python3 环境当中。\n\n目前支持的 Python3 环境如下：\n\n- [PC x86_64 的 Pyhon3 环境](https://www.python.org/downloads/release/python-380/)\n\n- [Sipeed v831 的 Python3 交叉编译环境](https://github.com/sipeed/MaixPy3/releases/tag/20210613) (需要使用 source toolchain_v83x_linux_x86/envsetup.sh 获得链接 V831 编译链的 python3.8 环境，注意这不是本机的 Python3 环境！！！)\n\n通常拿到一个 Python 模块，对它的 `setup.py` 执行 `python setup.py build` 即可进行构建，它的内容通常有如下示例（只是举例）。\n\n```python\n\nfrom setuptools import setup, Extension, find_packages\n\n_maix_module = Extension('_maix', include_dirs=['ext_modules/_maix/include'], sources=get_srcs('ext_modules/_maix'), libraries=['jpeg'])\n\nlibi2c_module = Extension('pylibi2c',  include_dirs=['ext_modules/libi2c/src'], sources=get_srcs('ext_modules/libi2c/src'))\n\nsetup(\n    name='MaixPy3',\n    version='0.1.2',\n    license='MIT',\n    author='Sipeed',\n    author_email=\"support@sipeed.com\",\n    url='https://github.com/sipeed/MaixPy3',\n    description=\"MaixPy Python3 library\",\n    long_description=open('README.md').read(),\n    install_requires=[\"Pillow\"],\n    ext_modules=[\n        _maix_module,\n        libi2c_module,\n    ],\n    packages = find_packages(), # find __init__.py packages\n    classifiers=[\n        'Programming Language :: Python :: 3',\n    ],\n)\n\n```\n\n只需要关心 setup 函数的参数中 packages 、 ext_modules 定义下的模块。\n\n- find_packages() 会自动寻找根目录下所有带有 `__init__.py` 的包导入到 Python3 的 site-packages 中，import 的时候就会找到它。\n- ext_modules 是需要经过编译的 C 模块。\n\n## 通用 Python 模块开发\n\n以 maix 模块为例，完全用 Python 实现的模块需要按以下结构进行构建。\n\n- maix/`__init__.py`\n- maix/video.py\n- maix/xxxxx.py\n\n首先 setuptools 打包系统会找到该模块的 maix 文件夹并将其安装到 `site-packages/maix` 下，这样用户就可以在 Python3 中 `import maix` 了，注意它与 setup.py 的相对目录（`/maix`）与安装目录（`site-packages/maix`）位置保持一致。\n\n如何控制 from maix import * 的内容可以看 `__init__.py` 了解。\n\n```python\nfrom .video import camera\nfrom .import display\n\n__all__ = ['display', 'video', 'camera']\n```\n\n其中 `__all__` 可以控制 import 加载的模块、对象或变量，这样一个最基本的 Python 模块就制作完成了。\n\n关于编写后的测试看 [test_maix.py](https://github.com/sipeed/MaixPy3/tree/main/tests/test_maix.py) 代码可知，关于 tox 测试框架会在最后简单说明。 \n\n## 关于 C 拓展模块开发\n\n以 [libi2c](https://github.com/amaork/libi2c) 举例说明原生 C 开发的模块。\n\n如果是用 C 开发就需要配合 Makefile 的规则来操作，可以直接在 MaixPy3/ext_modules/libi2c 目录下直接运行 `make all` 进行构建，此时就会得到 `libi2c.so \\ libi2c.a \\ pylibi2c.so` 等模块。\n\n这样目标系统就可以通过 C 代码链接(-l)该 libi2c 模块执行，而 `pylibi2c.so` 模块是可以直接在 Python 里面直接 import 就可以使用的。\n\n```shell\njuwan@juwan-N85-N870HL:~/Desktop/v831_toolchain_linux_x86/MaixPy3/ext_modules/libi2c$ python3\nPython 3.8.5 (default, Jul 28 2020, 12:59:40) \n[GCC 9.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import pylibi2c\n>>> pylibi2c\n<module 'pylibi2c' from '/home/juwan/Desktop/v831_toolchain_linux_x86/MaixPy3/ext_modules/libi2c/pylibi2c.cpython-38-x86_64-linux-gnu.so'>\n>>> \n```\n\n注意 `pylibi2c.so` 是经过 `python3 setup.py build_ext --inplace` 命令编译 [ext_modules/libi2c/src/pyi2c.c](https://github.com/sipeed/MaixPy3/tree/main/ext_modules/libi2c/src/pyi2c.c) 得到的模块。\n\n其中 `#include <Python.h>` 的是来自于系统的 `usr/include` 目录，这取决于你的编译环境。\n\n> 注意，编译通过不代表可以运行，如果发现运行时丢失函数（undefined symbol），可以通过 ldd 查询 .so 依赖函数, 通过 nm -D 查询 .a 函数，通过 readelf -e 查询程序编译版本，有些平台可能没有 ldd 的话，就用 `readelf -d /bin/ls | grep \"Shared library\"` 来查看了，缺啥就往环境里补就对了。\n\n### 导入 pyXXX.c 的 C 拓展模块\n\n对于 make / gcc 的模块包以 ext_modules/xxxx 方式加入 MaixPy3 的编译环境（setup.py）， 请确保该包可以跨平台编译通过后，同步修改 [MaixPy3/envs/general.py](https://github.com/sipeed/MaixPy3/blob/main/envs/general.py) 的 ext_modules 模块。\n\n```python\n\nfrom setuptools import Extension\nfrom .utils import get_srcs\n\nlibi2c_module = Extension('pylibi2c',  include_dirs=[\n                          'ext_modules/libi2c/src'], sources=get_srcs('ext_modules/libi2c/src'))\n\n_maix_module = Extension('_maix', include_dirs=['ext_modules/_maix/include'],\n                         sources=get_srcs('ext_modules/_maix'),\n                         libraries=[\n    \"jpeg\"\n],\n)\n\n_maix_camera_module = Extension('_maix_camera', include_dirs=['ext_modules/_maix_camera/include'],\n                                sources=get_srcs('ext_modules/_maix_camera'),\n                                )\n\n_maix_display_module = Extension('_maix_display', include_dirs=['ext_modules/_maix_display/include'],\n                                 sources=get_srcs('ext_modules/_maix_display'),\n                                 )\n\n_maix_modules = [\n    libi2c_module,\n    _maix_module,\n    _maix_camera_module,\n    _maix_display_module\n]\n\n_maix_data_files = [\n\n]\n\n_maix_py_modules = [\n    \"numpy\",\n    \"opencv-python3\",\n    \"opencv-python\",\n    \"Pillow\",\n    \"rpyc\",\n    \"gpiod\",\n    \"evdev\",\n    \"spidev\",\n    \"pyserial\"\n]\n```\n\n以 _maix_module 为例，在加入编译之前，该包结构如下（目录结构可能会过时）。\n\n- ext_modules/_maix\n- ext_modules/_maix/include/_maix.h\n- ext_modules/_maix/_maix.c\n- ext_modules/_maix/setup.py\n- /example/test__maix.py\n\n此时我们可以在 MaixPy3 根目录下使用 `python3 setup.py build` 调用 [setup.py](https://github.com/sipeed/MaixPy3/blob/main/setup.py) 進行构建，默认构建 linux_x86_64 的包。\n\n```python\n#!/usr/bin/env python\n\n\"\"\"\nsetup.py file for MaixPy3\n\"\"\"\n\nimport sys\nfrom setuptools import setup, Extension, find_packages\n\next_modules = []\ndata_files = []\npy_modules = []\n\nif 'maix_v831' in sys.argv:\n  sys.argv.remove('maix_v831')\n  from envs.maix_v831 import _maix_modules, _maix_data_files, _maix_py_modules\nelse:\n  from envs.general import _maix_modules, _maix_data_files, _maix_py_modules\n  \next_modules.extend(_maix_modules)\ndata_files.extend(_maix_data_files)\npy_modules.extend(_maix_py_modules)\n\n```\n\n如果在本机 Python 编译时出现如下错误：\n\n```shell\next_modules/_maix/pyCamera.c:4:10: fatal error: jpeglib.h: 没有那个文件或目录\n    4 | #include \"jpeglib.h\"\n      |          ^~~~~~~~~~~\ncompilation terminated.\n```\n\n运行 `sudo apt-get install libjpeg-dev` 后会在本机 usr/include 和 usr/bin 中加入 libjpeg 的模块，其他编译链同理。\n\n注意 Extension 的代码的链接时的相对地址（include_dirs & sources），以及本地打包时链接时缺少的（.h）文件，注意 [MANIFEST.in](https://github.com/sipeed/MaixPy3/tree/main/MANIFEST.in) 会链接本地的文件加入 Python 模块的打包。\n\n> 默认配置下打包中不会带入模块的（.h）文件，这会导致运行 tox 自动化打包构建模块时出错。\n\n```in\ninclude ext_modules/libi2c/src/*.h\ninclude ext_modules/_maix/include/*.h\n```\n\n> 关于 setup.py 的用法可以参考 [2021年，你应该知道的Python打包指南](https://frostming.com/2020/12-25/python-packaging)\n\n### 编写 C 拓展模块的参考\n\n接下来说明 CPython 的代码编写规范说明：\n\n- 如何编写一个 CPython 模块（PyModule）。\n- 如何 CPython 模块添加类对象（全局对象）、全局函数、全局变量。\n- 一个 PyObject 类对象的结构代码。\n- 标准 CPython 模块的命令规则。\n\n以 MaixPy3/ext_modules/_maix 模块为例，首先提供一个 C 实现的 Python 模块入口 [_maix.c](https://github.com/sipeed/MaixPy3/tree/main/ext_modules/_maix/_maix.c) 。\n\n```c\n\n#include \"_maix.h\"\n\n#define _VERSION_ \"0.1\"\n#define _NAME_ \"_maix\"\n\nPyDoc_STRVAR(_maix_doc, \"MaixPy Python3 library.\\n\");\n\nstatic PyObject *_maix_help() {\n    return PyUnicode_FromString(_maix_doc);\n}\n\nstatic PyMethodDef _maix_methods[] = {\n    {\"help\", (PyCFunction)_maix_help, METH_NOARGS, _maix_doc},\n    {NULL}\n};\n\nvoid define_constants(PyObject *module) {\n    PyModule_AddObject(module, \"_VERSION_\", Py_BuildValue(\"H\", _VERSION_));\n}\n\nstatic struct PyModuleDef _maixmodule = {\n    PyModuleDef_HEAD_INIT,\n    _NAME_,         /* Module name */\n    _maix_doc,\t/* Module _maixMethods */\n    -1,\t\t\t    /* size of per-interpreter state of the module, size of per-interpreter state of the module,*/\n    _maix_methods,\n};\n\nPyMODINIT_FUNC PyInit__maix(void)\n{\n\n    PyObject *module;\n\n    if (PyType_Ready(&CameraObjectType) < 0) {\n        return NULL;\n    }\n\n    module = PyModule_Create(&_maixmodule);\n    PyObject *version = PyUnicode_FromString(_VERSION_);\n\n    /* Constants */\n    define_constants(module);\n\n    /* Set module version */\n    PyObject *dict = PyModule_GetDict(module);\n    PyDict_SetItemString(dict, \"__version__\", version);\n    Py_DECREF(version);\n\n    /* Register CameraObjectType */\n    Py_INCREF(&CameraObjectType);\n    PyModule_AddObject(module, Camera_name, (PyObject *)&CameraObjectType);\n\n    return module;\n}\n\n\n```\n\n此时 Python 在 import 该模块的时候就会调用 PyInit_xxxx 函数进行初始化，在 Python 里 import 该模块只会执行一次，想要再次执行需要 reload 函数（`from imp import reload`）。\n\n通过 `PyModule_AddObject` 注册 PyObject 对象到该模块中，而该对象被公开到一个头文件当中进行交换，从而给 PyModule 提供多个 PyObject 的实现，添加模块的全局变量与此同理。\n\n```c\nstatic PyMethodDef _maix_methods[] = {\n    {\"help\", ()_maix_help, METH_NOARGS, _maix_doc},\n    {NULL}\n};\n```\n\n通过 `_maix_methods` 结构体为模块添加全局函数，如果你认为某个函数是公共函数，则将其放置模块顶层，表示全局公共函数。\n\n### PyObject 的结构参考\n\n一个基础的格式参考如下：\n\n定义一个对象必要的对外引用，将模块和对象实现分离，模块再通过（.h）文件链接对象实现，可见 [MaixPy3/ext_modules/_maix_camera/include/_maix_camera.h](https://github.com/sipeed/MaixPy3/blob/main/ext_modules/_maix_camera/include/_maix_camera.h) 。\n\n```c\n\n#ifndef _MAIX_CAMERA_H\n#define _MAIX_CAMERA_H\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n#include <Python.h>\n\n/* Macros needed for Python 3 */\n#ifndef PyInt_Check\n#define PyInt_Check PyLong_Check\n#define PyInt_FromLong PyLong_FromLong\n#define PyInt_AsLong PyLong_AsLong\n#define PyInt_Type PyLong_Type\n#endif\n\nPyDoc_STRVAR(VirtualCamera_name, \"VirtualCamera\");\nextern PyTypeObject VirtualCameraObjectType;\n\n// #define V831Camera\n#ifdef V831Camera\nPyDoc_STRVAR(V831Camera_name, \"V831Camera\");\nextern PyTypeObject V831CameraObjectType;\n#endif\n\n#ifdef  __cplusplus\n}\n#endif\n\n#endif\n\n```\n\n此时（PyInit__maix）就可以加载该对象（CameraObjectType）到 _maix 模块当中。\n\n```c\nif (PyType_Ready(&VirtualCameraObjectType) < 0) {\n    return NULL;\n}\n\n/* Register VirtualCameraObjectType */\nPy_INCREF(&VirtualCameraObjectType);\nPyModule_AddObject(module, VirtualCamera_name, (PyObject *)&VirtualCameraObjectType);\n\n```\n\n现在看到 PyObject 的实现参考，以 [MaixPy3/ext_modules/_maix_camera/_camera_virtual.c](https://github.com/sipeed/MaixPy3/blob/main/ext_modules/_maix_camera/_camera_virtual.c) 为范本。\n\n```c\n\nPyDoc_STRVAR(VirtualCameraObject_type_doc, \"VirtualCamera(width, height) -> VirtualCamera object.\\n\");\ntypedef struct\n{\n  PyObject_HEAD;\n  unsigned int width, height;\n} VirtualCameraObject;\n\nstatic PyGetSetDef VirtualCamera_getseters[] = {\n    {\"width\", (getter)VirtualCamera_get_width, (setter)VirtualCamera_set_width, VirtualCamera_width_doc},\n    {\"height\", (getter)VirtualCamera_get_height, (setter)VirtualCamera_set_height, VirtualCamera_height_doc},\n    {NULL},\n};\n\nPyTypeObject VirtualCameraObjectType = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    VirtualCamera_name,                           /* tp_name */\n    sizeof(VirtualCameraObject),                      /* tp_basicsize */\n    0,                                        /* tp_itemsize */\n    (destructor)VirtualCamera_free,                   /* tp_dealloc */\n    0,                                        /* tp_print */\n    0,                                        /* tp_getattr */\n    0,                                        /* tp_setattr */\n    0,                                        /* tp_compare */\n    0,                                        /* tp_repr */\n    0,                                        /* tp_as_number */\n    0,                                        /* tp_as_sequence */\n    0,                                        /* tp_as_mapping */\n    0,                                        /* tp_hash */\n    0,                                        /* tp_call */\n    VirtualCamera_str,                                /* tp_str */\n    0,                                        /* tp_getattro */\n    0,                                        /* tp_setattro */\n    0,                                        /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    VirtualCameraObject_type_doc,                     /* tp_doc */\n    0,                                        /* tp_traverse */\n    0,                                        /* tp_clear */\n    0,                                        /* tp_richcompare */\n    0,                                        /* tp_weaklistoffset */\n    0,                                        /* tp_iter */\n    0,                                        /* tp_iternext */\n    VirtualCamera_methods,                            /* tp_methods */\n    0,                                        /* tp_members */\n    VirtualCamera_getseters,                          /* tp_getset */\n    0,                                        /* tp_base */\n    0,                                        /* tp_dict */\n    0,                                        /* tp_descr_get */\n    0,                                        /* tp_descr_set */\n    0,                                        /* tp_dictoffset */\n    (initproc)VirtualCamera_init,                     /* tp_init */\n    0,                                        /* tp_alloc */\n    VirtualCamera_new,                                /* tp_new */\n};\n```\n\n实现任何模块时需重点关注如下基本函数接口实现，忽略（Camera）前缀，且下文函数只做举例。\n\n- xxxxx_new （对象构造函数）\n- xxxxx_free （对象析构函数）\n- xxxxx_init （对象初始化函数）\n- xxxxx_getseters （对象属性定义结构）\n- xxxxx_methods （对象方法定义结构）\n\n开发上遵循基本结构即可，展示 PyArg_ParseTupleAndKeywords 传递参数用法，以 Camera_init 为例，如果不想写 keyword （kwlist） 就用 PyArg_ParseTuple 函数。\n\n```c\nstatic int Camera_init(CameraObject *self, PyObject *args, PyObject *kwds)\n{\n  // default init value\n  self->width = 640, self->height = 480;\n\n  static char *kwlist[] = {\"width\", \"height\", NULL};\n\n  if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|ii:__init__\", kwlist,\n                                   &self->width, &self->height))\n  {\n    return -1;\n  }\n\n  return 0;\n}\n```\n\n为 PyObject 对象链接函数符号的时候可以看 xxxxx_getseters 和 xxxxx_methods 的结构定义。\n\n```c\nstatic PyMethodDef Camera_methods[] = {\n\n    {\"close\", (PyCFunction)Camera_close, METH_NOARGS, Camera_close_doc},\n    {\"__enter__\", (PyCFunction)Camera_enter, METH_NOARGS, NULL},\n    {\"__exit__\", (PyCFunction)Camera_exit, METH_NOARGS, NULL},\n    {NULL},\n};\n\nstatic PyGetSetDef Camera_getseters[] = {\n    {\"width\", (getter)Camera_get_width, (setter)Camera_set_width, Camera_width_doc},\n    {\"height\", (getter)Camera_get_height, (setter)Camera_set_height, Camera_height_doc},\n    {NULL},\n};\n```\n\n以 Python3 的 _maix.Camera 为例：\n\n```python\n\nimport _maix\n\ntmp = _maix.Camera()\n\nprint(\"this is method\", Camera.close)\n\nprint(\"this is var\", Camera.width)\n\n```\n\n一个简单的 PyCFunction 函数实现方法如下：\n\n```c\n/* str */\nstatic PyObject *Camera_str(PyObject *object)\n{\n  PyObject *dev_desc = PyUnicode_FromString(\"Camera_str\");\n\n  return dev_desc;\n}\n```\n\n如果是定义模块的全局函数则可以配置 METH_NOARGS 并移除函数参数，参考如下代码。\n\n```c\n\nstatic PyObject *_maix_help() {\n    return PyUnicode_FromString(_maix_doc);\n}\n\nstatic PyMethodDef _maix_methods[] = {\n    {\"help\", (PyCFunction)_maix_help, METH_NOARGS, _maix_doc},\n    {NULL}\n};\n\n```\n\n关于编写 CPython 模块的参考资料很多，这里只说明 MaixPy3 模块常用的程序设计，具体到函数的如何实现的细节就不在此赘述。\n\n### CPython 的内存标记用法\n\n可知 Python 拥有自动回收内存的 gc 机制，但在使用 Python C/C++ API 扩展 Python 模块时，对象指针标记不当可能会导致扩展的模块存在内存泄漏，可以使用 Py_INCREF（增加） & Py_DECREF（减少） 指针引用计数。\n\n```c\nPy_INCREF(ref);\n......\nPy_DECREF(ref); // Py_XDECREF(ref);\n```\n\n对应 Python 代码就是：\n\n```python\nref = 1\n....\ndel ref\n```\n\n可以理解为想要 gc 主动释放一个对象，就需要将其引用标志减少到无（0）。\n\n关于标记指针的说明上有用的文章。\n\n- 在开发时的注意事项请查阅 [使用 C 写 Python 模块时内存回收管理，Py_INCREF() 和 Py_DECREF() 的使用方式和注意点](https://neucrack.com/p/340)\n- 关于原理性的源码解析 [解密Python中的垃圾回收机制](https://www.cnblogs.com/traditional/p/13698244.html)\n\n如果你不能确定当前指针是否已经被回收，则你可以在使用前对 PyObject 结构指针进行引用计数的判断，也可以对该结构的类型做判断，从而确保可以操作该对象。\n\n```c\n\nassert(self->ob_refcnt > 0);\n\nPyAPI_DATA(PyTypeObject) PyBool_Type;\n#define PyBool_Check(x) Py_IS_TYPE(x, &PyBool_Type)\n\n```\n\n这样你就可以放心的操作内部创建的对象实例了。\n\n### CPython 模块的编写约束\n\n因为强调面向接口编程，所以 Python 模块下的 libXXXX 模块都是在各自的仓库编译通过后，再通过 setup.py 模块定义接口之间进行链接的，有些子仓库就是这么来的。\n\n也就是说不对编写代码风格做约束，但会对模块的接口做约束。\n\n要求每个模块的层次关系分离，以模块（PyModule）、对象（PyObject）、方法（PyCFunction）为接口参考，有如下结构。\n\n```shell\n+----------+         +-------------+\n|          +---------+ PyCFunction | 全局函數\n| PyModule |         +-------------+\n|          +<---+\n+----------+    |\n                |模块对象\n             +--+-------+\n             | PyObject +<---+\n             +----------+    |\n                             |\n                     +-------+-----+\n                     | PyCFunction | 成员函數\n                     +-------------+\n```\n\n因此请遵循该接口设计进行 Python 模块的开发。\n\n## 一些额外的内容\n\n### 使用 bdist_wheel 打包对应平台 wheel 包\n\n打包成对应平台的 wheel 的 bdist_wheel 的命令需要 setuptools 中支持。\n\n> 而 distutils 只可以构建 bdist 包。\n\nbdist_wheel 是将当前代码构建的最终文件都打包好，然后在安装的时候只需要释放到具体的安装目录下就结束了，这对于一些不能进行编译工作的硬件来说是极好的。\n\n确认 wheel 包是否可以被安装，只需要看名称就知道了，例如 `python3_maix-0.1.2-cp38-cp38-linux_x86_64.whl` 包，我们可以看到 `cp38-cp38-linux_x86_64` 标识。\n\npip 在安装的时候就会通过 `from pip._internal.utils.compatibility_tags import get_supported` 函数判断当前系统是否可以支持这个包，如果你改名了，它也是可以安装进去的,但能不能运行就取决于系统环境了，注意 armv7.whl 和 armv7l.whl 并不相同。\n\n> 细节阅读 [2021 年 当安装 wheel 出现 whl is not a supported wheel on this platform. 的时候](https://www.cnblogs.com/juwan/p/14250104.html)\n\n###  自动化测试框架 tox 的使用说明\n\n在本机上使用 `pip3 install tox` 完成安装，接着在 MaixPy3 根目录下运行 tox 即可。\n\n它会自动构建指定的 Python 虚拟测试环境，进行打包构建，安装解包的测试，最后会收集整个目录下的 `test_*.py` 的代码加入到自动测试当中，如果你不想让个别代码参与测试，你可以改名成 `no_test_*.py` 方便排除和保留文件。\n\n更多请自行查阅 [Python 任务自动化工具 tox 教程](https://www.cnblogs.com/daniumiqi/p/12179453.html) 和官方文档 [tox.readthedocs.io](tox.readthedocs.io) 。\n\n### *关于 V831 或其他平台芯片如何使用\n\n以上文档为通用说明，使用方法差异的地方在于调用 Python 指令有所不同。\n\n例如加载 V831 等其他平台的 SDK 环境后，要将上述命令中的 python3 改成对应 SDK 环境的 python3.8 用以调用交叉编译的 Python 解释器，从而完成目标 arm 平台的交叉编译，这是由 SDK 提供时决定的，其他平台统一按这个结构载入即可。\n\n### 调用 get-pip.py 手动为 Python pip 安装指定包。\n\n有时候一些交叉编译里面的 Python 环境可能会缺少 pip ，如果想要安装包，就可以用这样的方式从外部装进去。\n\n- `./python3.7 get-pip.py Cython --target=../usr/lib/python3.7/site-packages/`"}, "/soft/maixpy3/zh/others/platform.html": {"title": "如何适配你的平台", "content": "---\ntitle: 如何适配你的平台\nkeywords: MaixPy, MaixPy3, Python, Python3, MicroPython\ndesc: maixpy doc: 如何适配你的平台\n--- \n\n> 通过【MaixPy3开发文档】可知基础的 Python3 编译、安装、测试等开发方法。\n\n本文基于 [MaixPy3 项目主页](https://github.com/sipeed/MaixPy3) 详细地介绍了 MaixPy3 项目结构，帮助你更好的适配 MaixPy3 环境。\n\n## 2021 年的 Python 可以彻底跨平台了吗？\n\n答案是还不足够的，仍然有很多依赖底层库差异导致了 Python 模块难以跨平台兼容。\n\n虽然绝大部分软件模块（如：pil、numpy、urllib3）都支持跨平台了，但在嵌入式 linux 设备的 Python 调用硬件资源（如：video \\ audio \\ nn）的问题上，仍然不能达到理想的跨平台接口。\n\n因此 MaixPy3 是围绕一系列支持边缘 AI 的 Linux 设备来做的，短期内不会考虑所有平台（如 Android & Windows ）。\n\n## 适配 MaixPy3 流程是怎样的？\n\n除去必要 Python3 调取硬件资源的方法，在 MaixPy3 上的开发更像是自上而下的模块接口统一的工作。\n\n可以从上层软件往下要求硬件提供相关功能模块的适配。\n\n从用户角度描述常用的功能如下：\n\n- 支持显示器（display）\n- 支持摄像头（camera）\n- 支持音频录音播放（audio）\n- 支持神经网络算法（nn）\n- 支持按键、触摸、鼠标、键盘等事件（evdev）\n- 支持点灯（gpio）\n- 支持上网（network）\n- 支持访问 I2C / SPI / UART / USB 等协议外设或传感器\n\n于是适配功能的流程描述如下：\n\n1. 首先在 Linux 系统上提供上述功能模块，可以动（静）态依赖库提供，也可以系统调用提供，~~还可以直接寄存器操作~~。\n2. 接着通过更多的 Python3 拓展模块实现相应的功能，此时拥有该模块基础使用的 Python 代码。\n3. 最后在 MaixPy3 中统一存在差异的 Python 代码，屏蔽不同设备不同硬件的差异。\n\n## 以适配【显示器】为例\n\n> 由于各个产品的硬件适配程度不同，有些过程可能已经提前完成，你可以选择跳过。\n\n想要使用 Python 在屏幕上显示内容，可以先从上层 Python 代码开始描述功能，为了能够解决基本的图像处理，选择一个 Python 中经典流行通用的 PIL 图像库 [pillow](https://github.com/python-pillow/Pillow)。\n\n现在可以使用代码打开图片并显示到屏幕上了：\n\n```python\nfrom PIL import Image\nim = Image.new(\"RGB\", (640, 480), \"#FF0000\")\nim.show()\n```\n\n这时候若是从【显示器】的角度设计一个 display 模块，可以写成如下代码：\n\n```python\nfrom PIL import Image\nfrom maix import display\ndisplay.show(Image.new(\"RGB\", (640, 480), \"#FF0000\"))\n```\n\n而 `from maix import display` 的实现可以简化成如下代码：\n\n```python\nfrom PIL import Image\ndisplay = Image.new(\"RGB\", (640, 480), \"#FF0000\")\n\ndef show(img):\n  global display\n  if isinstance(img, Image.Image):\n    display.paste(img, box)\n  display.show()\n```\n\n这时候 `display` 模块的角度就是作为显示器模块，实现了同一份代码在不同类型的 Linux 设备之间产生同样的效果。\n\n![](./asserts/pil_view.jpg)\n\n在达到这样的效果验证后，就可以开始做具体的移植适配。\n\n### 准备 Linux / Python3 / pillow 等基础功能模块\n\n准备一个目标 Linux 平台上的 Python3 解释器，与之配套的还有 目标平台的 GCC 编译链与系统目录（/usr/include & /lib）相关文件。\n\n> 期间经历一系列的目标 Linux 平台的系统移植和编译操作后\n\n在确保 Linux 系统可以运行 Python 解释器后，通过 pip 下载安装 pillow 模块，验证上述 Python 实现的功能后，在 MaixPy3 的 setup.py 中给 `setup()` 函数的 `install_requires` 参数加入 `pillow` 模块。\n\n这时候用户在安装 `pip install MaixPy3` 的时候，由于 MaixPy3 依赖于 pillow 这个模块，如果安装过程中发现系统里没有，就会尝试下载编译安装 pillow 模块，但对于一些不能编译安装模块的 Linux 设备就需要系统里直接内置 pillow 模块，以减少用户的困扰。\n\n### 但运行代码后并没有效果\n\n为什么？\n\n这是因为不同平台的屏幕的显示方式（命令）有所不同，不妨从 pillow 来看看的 show 是如何工作的。\n\n```python\nfrom PIL import Image\nim = Image.new(\"RGB\", (640, 480), \"#FF0000\")\nim.show()\n```\n\n在这段代码中的 `im.show()` 最终会依赖于 [ImageShow.py](https://github.com/python-pillow/Pillow/blob/master/src/PIL/ImageShow.py) 来完成图像对象的展示。\n\n在 Linux 上是如何工作的呢？\n\n```python\n\nclass UnixViewer(Viewer):\n    format = \"PNG\"\n    options = {\"compress_level\": 1}\n\n    def get_command(self, file, **options):\n        command = self.get_command_ex(file, **options)[0]\n        return f\"({command} {quote(file)}; rm -f {quote(file)})&\"\n\n    def show_file(self, file, **options):\n        \"\"\"Display given file\"\"\"\n        fd, path = tempfile.mkstemp()\n        with os.fdopen(fd, \"w\") as f:\n            f.write(file)\n        with open(path) as f:\n            command = self.get_command_ex(file, **options)[0]\n            subprocess.Popen(\n                [\"im=$(cat);\" + command + \" $im; rm -f $im\"], shell=True, stdin=f\n            )\n        os.remove(path)\n        return 1\n\n\nclass DisplayViewer(UnixViewer):\n    \"\"\"The ImageMagick ``display`` command.\"\"\"\n\n    def get_command_ex(self, file, **options):\n        command = executable = \"display\"\n        return command, executable\n\n```\n\n可以看到 DisplayViewer 继承 UnixViewer 对象，在 show_file 的时候将图像文件缓存到临时文件（`tempfile.mkstemp()`），再通过 get_command_ex 调用 display 系统命令（程序）完成图像的显示。\n\n> 简单来说就是【在显示器上显示一张图片】的意思。\n\n![](./asserts/display_cmd.jpg)\n\n那在嵌入式 arm Linux 硬件又会是怎样的呢？\n\n在 v831 的 linux 系统中可以使用和 display 类似的 fbviewer 程序来显示一张图像。\n\n```\nroot@sipeed:/# fbviewer /home/res/logo.png \nfbv - The Framebuffer Viewer\n/home/res/logo.png\n140 x 140\n```\n\n如何注入 fbviewer 的显示接口进 pillow 模块呢？（在 `maix/__init__.py` 中有如下一段代码）\n\n```python\ntry:\n  import shutil\n  from PIL import ImageShow\n  # use fbviewer on linux\n  # os.system('ln -s /usr/sbin/fbviewer /usr/sbin/display')\n  if shutil.which(\"fbviewer\"):\n    class fbViewer(ImageShow.UnixViewer):\n      def get_command_ex(self, file, **options):\n        command = executable = \"fbviewer\"\n        return command, executable\n    ImageShow.register(fbViewer, 0)\nexcept ModuleNotFoundError as e:\n  pass\n\n```\n\n可以看到当发现系统里有 fbviewer 时就会将该类注入到 PIL 的 ImageShow 的显示接口中，又或是在系统里直接将 fbviewer 链接到 display 命令上。\n\n现在已经成功适配到具体的屏幕操作了，但这样就足够了吗？\n\n### 这样还不够，这样实现仅是完成了功能。\n\n简单分析一下，上述实现性能损耗主要发生在当图像对象进入 pillow show_file 的时候需要对其编码保存到某个临时文件（/tmp）中，然后再交给 fbviewer 去打开文件，fbviewer 对其解码后再写到 framebuffer 的设备（/dev/fb0）上。\n\n问：为什么不把图像的 rgb 数组直接写到 fb 上呢？\n\n答：没错，内部的 _maix_display 拓展模块实现是这样做的。\n\n```c++\nPyDoc_STRVAR(Display_draw_doc, \"draw()\\nDraw image(rgb888) bytes data to lcd.\\n\");\nstatic PyObject *Display_draw(V831DisplayObject *self, PyObject *args)\n{\n    PyObject *img_bytes = NULL;\n    int img_width = 0, img_height = 0;\n    if (!PyArg_ParseTuple(args, \"Oii\", &img_bytes, &img_width, &img_height))\n    {\n        return NULL;\n    }\n    if (NULL != self->disp) {\n      if (self->disp->width >= img_width && self->disp->height >= img_height) {\n          uint8_t *rgb_data = (uint8_t *)PyBytes_AS_STRING(img_bytes);\n          if (rgb_data != NULL) {\n            self->disp->draw(self->disp, rgb_data, (self->disp->width - img_width) / 2,(self->disp->height - img_height) / 2, img_width, img_height, 1);\n          }\n      }\n    }\n    Py_RETURN_NONE;\n}\n```\n\n```python\nfrom _maix_display import V831Display\n__fastview__ = V831Display(__width__, __height__)\n__fastview__.draw(img.tobytes(), __fastview__.width, __fastview__.height)\n```\n\n这就是【屏幕清屏（变黑） `dd if=/dev/zero of=/dev/fb0` 】与【显示黑色图片 `display black.bmp` 】之间存在的性能差距。\n\n至此【显示器】基本适配完成了，其他模块亦如此，但不一定每个模块都要使用这样方式进行移植，只是出于性能的考虑可以这样做。\n\n> 可以自行查阅 Linux framebuffer 相关资料了解更多。\n\n### 以 Maix 包作为通用的 Python API\n\n做完上述功能后，就要回到这里思考一个用户体验的问题（开发者也可以是用户）。\n\n如何让同一份代码在不同平台表现一致，减少用户的再次学习成本和认知成本，所以制作了一个 maix 入口模块，以减少重复实现的功能代码。\n\n> 若是不使用某个模块（maix）去约束入口代码，就会产生代码碎片化，就如同你所看到的 Linux 上各种 Python 功能模块，做同一件事，不同平台上的接口与用法都不尽相同，但你需要花费不少时间去寻找并使用，为什么不能统一常用的功能接口呢，答案肯定是可以的，但这可能需要一些时间。\n\n从摄像头获取一张图片并显示出来这样的功能，使用如下代码就可以实现这个功能，并且它在大多数平台上都是可以做到的。\n\n```python\nfrom maix import display, camera\ndisplay.show(camera.capture())\n```\n\n为了实现上述统一接口，就需要在 [maix/video.py](https://github.com/sipeed/MaixPy3/blob/main/maix/video.py) 中多次 import 直到能够匹配的平台接口，这就会产生很多肮脏的接口代码，就如下所示。\n\n```python\n\ncamera = MaixVideo()\n\ntry:\n    # use libmaix on v831\n    from _maix_camera import V831Camera\n\n    class V831MaixVideo(MaixVideo):\n\n        def __init__(self, source=\"/v831\"):\n            self.source = source\n            self.cam = None\n\n        def config(self, size=(480, 360)):\n            if self.cam == None:\n                super(V831MaixVideo, self).__init__(size)\n                self.cam = V831Camera(self.width(), self.height())\n                import time\n                time.sleep(0.2) # wait init\n                print('[camera] config input size(%d, %d)' %\n                      (self.width(), self.height()))\n\n        def read(self):\n            if self.cam == None:\n                print('[camera] run config(size=(w, h)) before capture.')\n                self.config()\n            if self.cam:\n                ret, frame = self.cam.read()\n                if ret:\n                    return frame  # bytes\n            return None\n\n        def __del__(self):\n            if self.cam:\n                self.cam.close()\n                self.cam = None\n\n    camera = V831MaixVideo()\nexcept Exception as e:\n    pass\n\ntry:\n    from cv2 import VideoCapture\n\n    class CvMaixVideo(MaixVideo):\n\n        def __init__(self, source=0):\n            super(CvMaixVideo, self).__init__((640, 480))\n            self.source = source\n            self.cam = VideoCapture(0)\n\n        def read(self):\n            ret, frame = self.cam.read()\n            if ret:\n                bgr = frame[..., ::-1]  # bgr2rgb\n                return bgr.tobytes()  # bytes\n            return None\n\n        def __del__(self):\n            self.cam.release()\n\n    camera = CvMaixVideo()\nexcept Exception as e:\n    pass\n\n```\n\n> 这样的代码并不会多次运行，只会 import 的时候载入一次。\n\n像 MaixPy3 在设计 display 和 camera 模块的时候都尽可能围绕则 pillow 和 python-opencv 模块的接口设计衍生而来的，可以看到 camera 的 MaixVideo 定义如下，是参考 opencv 结构实现的。\n\n```python\n\nclass MaixVideo():\n\n    def __init__(self, size=(640, 480)):\n        self._width, self._height = size\n        \n    def width(self):\n        return self._width\n      \n    def height(self):\n        return self._height\n      \n    def write(self):\n        pass  # for file\n\n    def read(self):\n        return b'\\xFF\\x00\\x00' * (self._width * self._height)\n\n    def config(self, size):\n        pass\n\n    def capture(self):\n        from PIL import Image\n        tmp = self.read()\n        if tmp:\n            return Image.frombytes(\"RGB\", (self._width, self._height), tmp)\n        return None\n\n    def close(self):\n        pass  # for file\n\n```\n\n后来加入的 i2c \\ spi \\ pwm \\ gpio 也尽量以通用接口实现。\n\n但也有一些例外，如 [PyAudio](http://people.csail.mit.edu/hubert/pyaudio/) 在对接具体音频驱动设备存在 alsa 和 tinyalsa 两类接口，就需要从底层上去完成 Python 拓展 C 模块的编写，从而实现上层接口的一致，而截止 2021 年的神经网络 NN 模块实现更是千奇百怪，还难以统一。\n\n所以通过 maix 模块作为用户调用的 API 入口，重新围绕功能来抽象设计对用户友好且统一的通用接口。\n\n这样在不同平台上只需要链接不同的 Python 依赖模块即可，如 v831 链接的是 _maix_camera 模块，而 pc 上直接使用 opencv-python 模块，当然也可以是任意调用其他模块，不一定是 MaixPy3 所提供的参考模块，这取决于你的想法。\n\n## 附录：如何优化 Python 模块？（以 GPIO 为例）\n\nPython 上通用软件的接口大多都是通过 shell 接口调用系统程序完成的功能，所以在执行性能上有很大的损失。\n\n所谓经过优化实际上是通过内置代码模块的方式进行操作的，这样就减少了不必要的数据交换了。\n\n那么执行性能究竟差在哪里？除了上述说的【显示器】适配时的优化，下面再以 GPIO 的实现为例说明这个问题。\n\n如果站在使用 Python 进行的 Linux 应用编程角度，可以这样实现 GPIO 的控制。\n\n### 使用 sysfs 的接口\n\n可以在 shell 接口配置 gpio 完成输入输出、拉高拉低。\n\n```bash\nsudo su\ncd /sys/class/gpio\necho 12 > export\necho out > gpio12/direction       # io used for output\necho 1 > gpio12/value             # output logic 1 level\necho 0 > gpio12/value             # output logic 0 level\necho 12 > unexport\n```\n\n而在 Python 里可以使用 os.system() 来输入 shell 命令完成。\n\n### 使用 gpiod 的接口\n\n可以参考 [python3-gpiod](https://github.com/hhk7734/python3-gpiod) 的实现，主要它是对 /dev/gpiodchipX 设备进行操作的。\n\n```python\n\ndef gpiod_chip_open(path: str) -> Optional[gpiod_chip]:\n    \"\"\"\n    @brief Open a gpiochip by path.\n    @param path: Path to the gpiochip device file.\n    @return GPIO chip handle or None if an error occurred.\n    \"\"\"\n    info = gpiochip_info()\n\n    try:\n        fd = os_open(path, O_RDWR | O_CLOEXEC)\n    except FileNotFoundError:\n        return None\n\n    # We were able to open the file but is it really a gpiochip character\n    # device?\n    if not _is_gpiochip_cdev(path):\n        os_close(fd)\n        return None\n\n    status = ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, info)\n    if status < 0:\n        os_close(fd)\n        return None\n\n    if info.label[0] == \"\\0\":\n        label = \"unknown\"\n    else:\n        label = info.label.decode()\n\n    return gpiod_chip(\n        num_lines=info.lines, fd=fd, name=info.name.decode(), label=label\n    )\n\n```\n\n可以通过 shell 接口操作 /sys/class/gpio 对象，也可以通过 `from fcntl import ioctl` 操作字符设备文件进行控制，与第一种差别不大。\n\n### 使用 mmap 的接口\n\n在 Linux 下直接读写物理地址，打开设备文件 /dev/mem 后使用 mmap 进行物理地址的映射，最后查阅数据手册获取寄存器地址读写相应的寄存器。\n\n> 节选部分代码说明意图，注意不同平台的定义和实现都不尽相同。\n\n```c++\n\nunsigned int SUNXI_PIO_BASE = 0;\nstatic volatile long int *gpio_map = NULL;\n\nint sunxi_gpio_init(void) {\n    int fd;\n    unsigned int addr_start, addr_offset;\n    unsigned int PageSize, PageMask;\n\n\n    fd = open(\"/dev/mem\", O_RDWR);\n    if(fd < 0) {\n        return SETUP_DEVMEM_FAIL;\n    }\n\n    PageSize = sysconf(_SC_PAGESIZE);\n    PageMask = (~(PageSize-1));\n\n    addr_start = SW_PORTC_IO_BASE & PageMask;\n    addr_offset = SW_PORTC_IO_BASE & ~PageMask;\n\n    gpio_map = (void *)mmap(0, PageSize*2, PROT_READ|PROT_WRITE, MAP_SHARED, fd, addr_start);\n    if(gpio_map == MAP_FAILED) {\n        return SETUP_MMAP_FAIL;\n    }\n\n    SUNXI_PIO_BASE = (unsigned int)gpio_map;\n    SUNXI_PIO_BASE += addr_offset;\n\n    close(fd);\n    return SETUP_OK;\n}\n\n```\n\n然后编写相应的 Python 拓展 C 模块调用上述接口。\n\n```c++\n\n#define PD0    SUNXI_GPD(0)\n#define PD1    SUNXI_GPD(1)\n#define PD2    SUNXI_GPD(2)\n#define PD3    SUNXI_GPD(3)\n#define PD4    SUNXI_GPD(4)\n#define PD5    SUNXI_GPD(5)\n#define PD6    SUNXI_GPD(6)\n#define PD7    SUNXI_GPD(7)\n#define PD8    SUNXI_GPD(8)\n#define PD9    SUNXI_GPD(9)\n#define PD10    SUNXI_GPD(10)\n#define PD11    SUNXI_GPD(11)\n#define PD12    SUNXI_GPD(12)\n#define PD13    SUNXI_GPD(13)\n#define PD14    SUNXI_GPD(14)\n#define PD15    SUNXI_GPD(15)\n#define PD16    SUNXI_GPD(16)\n#define PD17    SUNXI_GPD(17)\n#define PD18    SUNXI_GPD(18)\n#define PD19    SUNXI_GPD(19)\n#define PD20    SUNXI_GPD(20)\n#define PD21    SUNXI_GPD(21)\n#define PD22    SUNXI_GPD(22)\n#define PD23    SUNXI_GPD(23)\n#define PD24    SUNXI_GPD(24)\n#define PD25    SUNXI_GPD(25)\n#define PD26    SUNXI_GPD(26)\n#define PD27    SUNXI_GPD(27)\n\n#define MISO    SUNXI_GPE(3)\n#define MOSI    SUNXI_GPE(2)\n#define SCK     SUNXI_GPE(1)\n#define CS      SUNXI_GPE(0)\n\nstatic int module_setup(void) {\n    int result;\n\n    result = sunxi_gpio_init();\n    if(result == SETUP_DEVMEM_FAIL) {\n        PyErr_SetString(SetupException, \"No access to /dev/mem. Try running as root!\");\n        return SETUP_DEVMEM_FAIL;\n    }\n    else if(result == SETUP_MALLOC_FAIL) {\n        PyErr_NoMemory();\n        return SETUP_MALLOC_FAIL;\n    }\n    else if(result == SETUP_MMAP_FAIL) {\n        PyErr_SetString(SetupException, \"Mmap failed on module import\");\n        return SETUP_MMAP_FAIL;\n    }\n    else {\n        return SETUP_OK;\n    }\n\n    return SETUP_OK;\n}\n\nstatic PyObject* py_init(PyObject* self, PyObject* args) {\n\n    module_setup();\n\n    Py_RETURN_NONE;\n}\n\nPyMethodDef module_methods[] = {\n    {\"init\", py_init, METH_NOARGS, \"Initialize module\"},\n    {\"cleanup\", py_cleanup, METH_NOARGS, \"munmap /dev/map.\"},\n    {\"setcfg\", py_setcfg, METH_VARARGS, \"Set direction.\"},\n    {\"getcfg\", py_getcfg, METH_VARARGS, \"Get direction.\"},\n    {\"output\", py_output, METH_VARARGS, \"Set output state\"},\n    {\"input\", py_input, METH_VARARGS, \"Get input state\"},\n    {NULL, NULL, 0, NULL}\n};\n\n```\n\n这样与上述实现 display 模块到优化处理的思路是相通的，目的都是减少不必要的接口之间的数据交换达到最终优化的目的。\n\n### 总结\n\n无论是哪种方法本意想通过抽象封装的通用接口来解决不同硬件上的差异，但有时会因为性能和内存的问题，只能放弃抽象直接访问底层寄存器硬件以提高性能。\n\n> 上述接口的操作都是处于 linux 用户空间进行的，使用 Python 和 C 访问 /sys/class/gpio 设备在程序逻辑上并无区别，但从执行代码段和传递变量消耗的角度来看，越靠近底层的实现执行效率自然越高，通过 Python 拓展模块实现的 mmap 映射操作相对于直接使用 C 代码实现而言，两者性能差异几乎可以忽略不计，所以 Python 程序也不一定会性能低下，主要还是取决于具体的实现方式。\n\n如果还想继续提高性能，就需要把寄存器操作下到内核空间了，可能这对于一些用户来说并不是必要的，例如用户点灯相对于系统而言是低频操作，而模拟 SPI 通信需要控制 GPIO 翻转则是高频操作，而从用户的角度来说，实现这个点灯功能（低频操作）对性能的要求不敏感，可以不做优化。\n\n因此要根据硬件的实际情况，在性能与功能之间选择一个折衷的实现。"}, "/soft/maixpy3/zh/guide/feedback.html": {"title": "如何反馈问题", "content": "---\ntitle: 如何反馈问题\nkeywords: MaixPy, MaixPy3, Python, Python3, MicroPython\ndesc: maixpy doc: 如何反馈问题\n---\n\n在没开始使用 MaixPy3 开源项目之前，建议先看一下如何反馈问题，免得之后使用过程中出了问题，不知道在哪反馈，也不知道在哪获取解决方法。在开源项目上反馈的问题通常需要一些时间才能得到解决。\n\n## 找到反馈的地方\n\n按问题的严重性和客户的重要性依次排列反馈的地方，注意商业支持邮件不对个人用户开放，勿扰。\n\n- MaixPy 开源群组\n  - QQ 交流群 878189804 / 1129095405 / 756313869 等\n  - [telgram-sipeed](https://t.me/sipeed)\n- 开源社区\\论坛\\官博等\n  - [bbs.sipeed.com](https://bbs.sipeed.com)\n  - [twitter-sipeedio](https://twitter.com/sipeedio)\n- MaixPy3 开源项目的 issue 区\n  - [github.com/sipeed/MaixPy3/issues](https://github.com/sipeed/MaixPy3/issues)\n- 商业支持邮件\n  - 从 [sipeed.com](https://sipeed.com) 底部获取。\n\n如果是交流群反馈可能会被聊天消息刷下去，建议发到社区或 issue 保证问题可以被记录和得到解决，因为在聊天群组反馈的问题可能不会被解决。\n\n## 正确的反馈问题\n\n在遇到问题之前，请浏览一下（项目、社区）是否有相关的问题反馈记录，再把你遇到的问题，操作，环境，现象都写下来。\n\n- 遇到了什么问题？\n- 你做了什么操作？要有截图或代码！\n- 你在什么系统环境下进行的操作？\n- 期望的现象与实际的现象有什么不符？（有图有真相！）\n\n## 尊重开源开发者\n\n请反馈问题的小白用户们尊重每一位参与开源的开发者，参与其中并没有为此获取利益，仅仅是出于对技术的热爱和分享，以及展现自己技术实力。\n\n> *不要任性，不要耍脾气，更不要玻璃心，要认真的虚心学习！！！！*"}, "/soft/maixpy3/zh/guide/participate.html": {"title": "如何参与项目", "content": "---\ntitle: 如何参与项目\nkeywords: MaixPy, MaixPy3, Python, Python3, MicroPython\ndesc: maixpy doc: 如何参与项目\n---\n\n如果你对开源社区文化很感兴趣，也想一同加入其中学习和分享，那了解 MaixPy3 开源项目可能是一个好的开始。\n\n## 什么是开源文化\n\n> 下文内容选自 [什么是开源文化？](https://www.cnblogs.com/hdwl/archive/2013/04/23/3037549.html)\n\n所谓“开源”，就是开放资源（Open Source）的意思。不过在程序界更多人习惯把它理解为“开放源代码”的意思。\n\n在计算机发展的早期阶段，软件几乎都是开放的，任何人使用软件的同时都可以查看软件的源代码，或者根据自己的需要去修改它。在程序员的社团中大家互相分享软件，共同提高知识水平。这种自由的风气给大家带来了欢乐，也带来了进步。\n\n“自由软件”的英文是“Free Software”，这不免为许多人所误解，人们经常把它和“免费软件”连系在一起，免费的恰恰都是些低级的，这使得自由软件蒙上了一层阴影。于是大家决定给自由软件一个更易理解的别名“开源软件”。开源一词则由此得来。 \n\n所以，开源即是自由的化身。它讲述了一种公开的、自由的精神。软件开源的发展历程 ，为我们软件行业以及非软件行业的人都带来的巨大的参考价值。\n## 可以如何参与开源项目？\n\n以 MaixPy3 为例，如果你对此项目感兴趣，想参与到其中，除了一般的开发活动，您的关注（给个 Star ）已经是最好的开源项目参与方式了，此外参与项目的方法还可以是通过提意见、提 bug 、反馈问题、修改文档说明、修改源代码并提交等等方式，值得注意的是，你要尊重这些开源项目所选取的开源协议。\n\nMaixPy3 开源项目采用 MIT 许可证。\n\n- 您可以使用复制和修改软件。\n- 您可以免费使用软件或出售。\n- 唯一的限制是，它是必须附有MIT授权协议。\n\n您可以在 [MaixPy3](https://github.com/sipeed/MaixPy3) 上公开获取它的项目源码，可以任意修改或提交，也可以学习它是如何实现的或是软件设计。\n\n您也可以在其他开源社区里公开的讨论和交流这个事物，开源总是期望用户能够提出自己的想法和宝贵的建议。\n\n若是有经验的开发人员，还可以阅读【MaixPy3开发文档】尝试提交或适配不同平台的软件。\n\n## 附录：GNU/Linux 和开源文化的背后\n\n> 下文内容选自 [GNU/Linux与开源文化的那些人和事](https://linux.cn/article-6270-1.html)\n\nGNU/Linux 来了，虽然没成为大多数人电脑里的系统，但每个人都离不开它。诸多互联网公司的服务器里都跑着 GNU/Linux ，名单不完全确认，Google、Facebook、淘宝、百度、腾讯、小说阅读网等等。\n\n大多人使用的安卓手机的系统也是基于 Linux 内核。\n\nGNU/Linux 的繁荣有宏伟的规划，有个人的努力，也有很多无形的力量在起着作用。\n\n没有 Unix 就没有 GNU/Linux ，是 Unix 给予了伟大的启示。\n\n没有 C 语言就有没有 GNU/Linux ， C 语言简单，优雅，介于高级语言和低级语言之间，开发系统软件的首选编程语言。\n\n没有一系列 Unix 标准的制定就没有 GNU/Linux 的繁荣。标准就是“车同轨、书同文、统一度量衡”，秦始皇可算最早的标准制订者。遵循 Posix 标准为 GNU/Linux 发展铺平了道路。\n\n没有互联网就没有 GNU/Linux ， GNU/Linux 不是一个人在开发，是全球无数人协作的结果。如果没有互联网实在不可想象。当然， GNU/Linux 也反哺了互联网，无数互联网公司采用GNU/Linux搭建服务器， GNU/Linux 也促进了互联网的繁荣。\n\n还有 GNU/Linux 诞生之前就开发开源项目的人和组织。Larry Wall因为懒，整天被报表搞得焦头烂额，发布了 Perl 语言；高德纳教授因为对排版工人不满意，十年时间停止重要工作，发明了伟大的排版软件 TeX ； Guido 为了打发圣诞节的无聊，编写了新的脚本语言 Python ……\n\n版本管理软件对 GNU/Linux 的发展和开源文化运动也功不可没。 Linux 内核开发起初使用的是商用版本管理软件，某天 Linus Torvalds 先生不开心了，就自己动手搞了一个。他好取自嘲调侃的名字，命名为 Git，意为没什么用的东西。\n\nGit 可不是没什么用，太好用了，Linux 内核源码从此都用 Git 管理。Git 免费、开源， Git 成就了一家伟大的网站 github.com ，伟大的源码项目托管网站。很多开源项目纷纷把源码托管到了 Github 上。"}, "/soft/maixpy3/zh/guide/project.html": {"title": "项目使用说明", "content": "---\ntitle: 项目使用说明\nkeywords: MaixPy, MaixPy3, Python, Python3, MicroPython\ndesc: maixpy doc: 项目使用说明\n---\n\n## 认识 MaixPy3 项目\n\n请点此进入 [MaixPy3](https://github.com/sipeed/maixpy3) 的开源项目仓库。\n\n## 如何安装使用？\n\nMaixPy3 是通过 pip 安装得到的，适用于 Python3 环境，请查阅左侧目录的 [如何安装](../install/index.html) 。\n\n> MaixPy3 在安装的时候可能会依赖一些需要编译才能安装的 Python 包，这需要通过镜像内置依赖包来解决这个问题。\n\n## 支持哪些开发工具？\n\n推荐使用 jupyter 或 VSCode 进行开发，使用串口终端也可以直接进行粘贴运行。\n\n请查阅左侧目录的 [常用的开发工具](../tools/mobaxterm.html) 进行安装与配置。\n\n## 在哪获取示例代码呢？\n\n将会使用 jupyter 文档提供所见即所得的结果。\n\n请查阅左侧目录的 [一些使用案例](../usage/00_hello_world.html) 完成基本的使用。\n\n## 关于内置模块的说明？\n\n对于一些底层实现的模块 API 说明，会统一放到【内置模块说明】当中。\n\n## 其他？\n\n更多的就自己探索吧。"}, "/soft/maixpy3/zh/api/maix/gpio.html": {"title": "MaixII M2dock I2C gpio 调试", "content": "---\ntitle: MaixII M2dock I2C gpio 调试\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: MaixII M2dock gpio 调试\n---\n\n## PIN_CTL\n\n- lichee/linux-4.9/drivers/pinctrl/sunxi/pinctrl-sun8iw19p1-r.c\n\n- lichee/linux-4.9/drivers/pinctrl/sunxi/pinctrl-sun8iw19p1.c\n\n![](./asserts/v831_pin_maps.png)\n\n### V831 Dock PIN Maps\n\n- PINCTRL_PIN(64 + (0), \"P\" \"C\" \"0\")\n- PINCTRL_PIN(96 + (0), \"P\" \"D\" \"0\")\n- PINCTRL_PIN(128 + (0), \"P\" \"E\" \"0\")\n- PINCTRL_PIN(160 + (0), \"P\" \"F\" \"0\")\n- PINCTRL_PIN(192 + (0), \"P\" \"G\" \"0\")\n- PINCTRL_PIN(224 + (0), \"P\" \"H\" \"0\")\n- PINCTRL_PIN(256 + (0), \"P\" \"I\" \"0\")\n\n| PIN Number  | PIN      | function                                   | 设备树配置     | 功能        | 备注  |\n| ----------- | -------- | ------------------------------------------ | --------- | --------- | --- |\n| 238(224+14) | PH14     | SPI1_CS0TWI3_SDAPH_EINT14                  |           | State_LED |     |\n| ---         | ---      |                                            |           | ---       | --- |\n| 166(160+6)  | PF6      | PF_EINT6                                   |           |           |     |\n|             | RST      |                                            |           |           |     |\n| 199(192+7)  | PG7      | UART1_RXPG_EINT7                           |           |           |     |\n| 198(192+6)  | PG6      | UART1_TXPG_EINT6                           |           |           |     |\n| 236(224+12) | PH12     | JTAG_CKRMII_TXENSPI1_MOSITWI2_SDAPH_EINT12 | TWI2_SDA  |           |     |\n| 235(224+11) | PH11     | JTAG_MSRMII_TXCKSPI1_CLKTWI2_SCKPH_EINT11  | TWI2_SCK  |           |     |\n| 238(224+14) | PH14     | JTAG_DIMDIOSPI1_CS0TWI3_SDAPH_EINT14       |           |           |     |\n| 237(224+13) | PH13     | JTAG_DOMDCSPI1_MISOTWI3_SCKPH_EINT13       |           |           |     |\n| 234(224+10) | PH10     | RMII_TXD0TWI3_SDAUART0_RXPH_EINT10         |           |           |     |\n|             | CPUX-RX  |                                            |           |           |     |\n|             | UART0-TX | PWM_9RMII_TXD1TWI3_SCKUART0_TXPH_EINT9     |           |           |     |\n| ---         | ---      |                                            |           | ---       | --- |\n|             | GND      |                                            |           |           |     |\n|             | 5V       |                                            |           |           |     |\n| 230(224+6)  | PH6      | PWM_6RMII_RXD0TWI2_SDAUART2_RXPH_EINT6     |           |           |     |\n| 231(224+7)  | PH7      | PWM_7RMII_CRS_DVUART0_TXUART2_RTSPH_EINT7  |           |           |     |\n| 232(224+8)  | PH8      | PWM_8RMII_RXERUART0_RXUART2_CTSPH_EINT8    |           |           |     |\n|             | GPADC0   |                                            |           |           |     |\n| 224(224+0)  | PH0      | PWM_0I2S0_MCLKSPI1_CLKUART3_TXPH_EINT0     | SPI1_CLK  |           |     |\n| 225(224+1)  | PH1      | PWM_1I2S0_BCLKSPI1_MOSIUART3_RXPH_EINT1    | SPI1_MOSI |           |     |\n| 226(224+2)  | PH2      | PWM_2I2S0_LRCKSPI1_MISOUART3_CTSPH_EINT2   | SPI1_MISO |           |     |\n| 227(224+3)  | PH3      | PWM_3I2S0_DOUTSPI1_CS0UART3_RTSPH_EINT3    | SPI1_CS0  |           |     |\n\n## sysfs 操作 GPIO\n\n```shell\nroot@sipeed:/# ls -l /sys/class/gpio\n--w-------    1 root     root          4096 Dec  9 08:54 export\nlrwxrwxrwx    1 root     root             0 Dec  9 08:54 gpiochip0 -> ../../devices/platform/soc/pio/gpio/gpiochip0\nlrwxrwxrwx    1 root     root             0 Dec  9 08:54 gpiochip352 -> ../../devices/platform/soc/r_pio/gpio/gpiochip352\n--w-------    1 root     root          4096 Dec  9 08:54 unexport\nroot@sipeed:/#\n```\n\n/sys/class/gpio 目录下的三种文件：\n\n- export/unexport 文件:  `/sys/class/gpio/export`，只写，写入 GPIO 编号来向内核申请 GPIO 控制权（前提是没有内核代码申请这个 GPIO 端口）, 成功后会在目录下生成 gpioN 目录, `/sys/class/gpio/unexport` 和导出的效果相反。\n\n- gpioN 指代具体的 gpio 引脚:  指代某个具体的 gpio 端口, 内有以下属性文件：\n\n| Attribution | Read/Write | Value                          | Function     |\n| ----------- | ---------- | ------------------------------ | ------------ |\n| direction   | RW         | in,out;low,high                | 设置输入输出       |\n| value       | RW         | 0,非零                           | 读取或者写入 IO 电平 |\n| edge        | RW         | none , rising , falling , both | 配置中断触发方式     |\n| active_low  | RW         | 0,非零                           | 设置低电平有效      |\n\n- gpiochipN 指代 gpio 控制器:  gpiochipN 表示的就是一个 gpio_chip, 用来管理和控制一组 gpio 端口的控制器，该目录下存在以下属性文件：\n\n| Attribution | Function                      |\n| ----------- | ----------------------------- |\n| base        | 和N相同，表示控制器管理的最小的端口编号。         |\n| lable       | 诊断使用的标志，寄存器地址，1c20800.pinctrl |\n| ngpio       | 表示控制器管理的 gpio 端口数量，A~G，224    |\n\n### LED 测试\n\n使用 sysfs 操作 GPIO 的例子：\n\n```shell\nls -l /sys/class/gpio/ # show gpio\necho 238 > /sys/class/gpio/export  #export PH14(238), State_LED\nls -l /sys/class/gpio/ # show gpio\n# output test\necho \"out\" > /sys/class/gpio/gpio238/direction # set gpio mode: direction\necho 0 > /sys/class/gpio/gpio238/value # set gpio output level: low\necho 1 > /sys/class/gpio/gpio238/value # set gpio output level: height\n# input test\necho \"in\" > /sys/class/gpio/gpio238/direction #设置为输入\ncat /sys/class/gpio/gpio192/value #读取电平\n\n```\n\n```bash\nll /sys/devices/platform/soc/r_pio/\n```\n\n## Python-gpiod\n\n![](./asserts/v831_gpio.png)\n\n```python\nimport gpiod\nc = gpiod.chip(\"gpiochip1\")\n# pylint: disable=missing-docstring\nimport sys\nimport time\nimport pytest\nfrom gpiod import chip, line, line_request\n\ntry:\n    if len(sys.argv) > 2:\n        LED_CHIP = sys.argv[1]\n        LED_LINE_OFFSET = int(sys.argv[2])\n    else:\n        raise Exception()\n# pylint: disable=broad-except\nexcept Exception:\n    print(\n        \"\"\"Usage:\n    python3 -m gpiod.test.blink <chip> <line offset>\"\"\"\n    )\n    sys.exit()\n\nc = chip(LED_CHIP)\n\nprint(\"chip name: \", c.name)\nprint(\"chip label: \", c.label)\nprint(\"number of lines: \", c.num_lines)\n\nprint()\n\nled = c.get_line(LED_LINE_OFFSET)\n\nprint(\"line offset: \", led.offset)\nprint(\"line name: \", led.name)\nprint(\"line consumer: \", led.consumer)\nprint(\n    \"line direction: \",\n    \"input\" if led.direction == line.DIRECTION_INPUT else \"output\",\n)\nprint(\n    \"line active state: \",\n    \"active low\" if led.active_state == line.ACTIVE_LOW else \"active high\",\n)\nprint(\"is line used: \", led.is_used)\nprint(\"is line open drain: \", led.is_open_drain)\nprint(\"is_open_source: \", led.is_open_source)\nprint(\"is line requested: \", led.is_requested)\n\nprint(\"\\nrequest line\\n\")\n\nconfig = line_request()\nconfig.consumer = \"Blink\"\nconfig.request_type = line_request.DIRECTION_OUTPUT\n\nled.request(config)\n\nprint(\"line consumer: \", led.consumer)\nprint(\n    \"line direction: \",\n    \"input\" if led.direction == line.DIRECTION_INPUT else \"output\",\n)\nprint(\n    \"line active state: \",\n    \"active low\" if led.active_state == line.ACTIVE_LOW else \"active high\",\n)\nprint(\"is line used: \", led.is_used)\nprint(\"is line open drain: \", led.is_open_drain)\nprint(\"is_open_source: \", led.is_open_source)\nprint(\"is line requested: \", led.is_requested)\n\nwhile True:\n    led.set_value(0)\n    time.sleep(0.1)\n    led.set_value(1)\n    time.sleep(0.1)\n```\n\n```python\npython test_blink.py gpiochip0 238\n```"}, "/soft/maixpy3/zh/api/maix/pwm.html": {"title": "MaixII M2dock PWM 调试", "content": "---\ntitle: MaixII M2dock PWM 调试\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: MaixII M2dock PWM 调试\n---\n\n## PWM介绍\n\nPWM（Pulse Width Modulation）控制——脉冲宽度调制技术，通过对一系列脉冲的宽度进行调制，来等效地获得所需要波形（含形状和幅值）.PWM控制技术在逆变电路中应用最广，应用的逆变电路绝大部分是PWM型，PWM控制技术正是有赖于在逆变电路中的应用，才确定了它在电力电子技术中的重要地位。V831的PWM功能是由硬件产生的,所以我们只用配置好硬件寄存器即可.芯片寄存器请参考[V833／V831 Datasheet V1.0.pdf](https://linux-sunxi.org/images/b/b9/V833%EF%BC%8FV831_Datasheet_V1.0.pdf).\n\n\n\n## V831 Dock PWM 引脚\n\n如下图所示,V831有8个引脚可以输出PWM波,但是由于复用关系,我们并不能随心所欲的使用这8个引脚.所以我们要注意他们的复用关系,以PH0为例,但是这个引脚被SPI功能所占用,所以我们使用时,需要改变PWM功能所在引脚的复用功能才能正常使用PWM功能.能够被我们正常使用的功能引脚是`PH6`、`PH7` 和 `PH8`引脚,其他引脚使用时需要注意引脚复用关系.如需一定要使用,请参考 [改变引脚复用关系](/soft/maixpy3/zh/module/linux/pwm.html#V831-Dock-改变引脚复用关系).\n\n![](./../../assets/linux/PWM/2021-09-22_10-27.png)\n\n| PIN Number  | PIN      | function                                   | 设备树配置     | 功能        | 备注  |\n| ----------- | -------- | ------------------------------------------ | --------- | --------- | --- |\n| 238(224+14) | PH14     | SPI1_CS0TWI3_SDAPH_EINT14                  |           | State_LED |     |\n| ---         | ---      |                                            |           | ---       | --- |\n| 166(160+6)  | PF6      | PF_EINT6                                   |           |           |     |\n|             | RST      |                                            |           |           |     |\n| 199(192+7)  | PG7      | UART1_RXPG_EINT7                           |           |           |     |\n| 198(192+6)  | PG6      | UART1_TXPG_EINT6                           |           |           |     |\n| 236(224+12) | PH12     | JTAG_CKRMII_TXENSPI1_MOSITWI2_SDAPH_EINT12 | TWI2_SDA  |           |     |\n| 235(224+11) | PH11     | JTAG_MSRMII_TXCKSPI1_CLKTWI2_SCKPH_EINT11  | TWI2_SCK  |           |     |\n| 238(224+14) | PH14     | JTAG_DIMDIOSPI1_CS0TWI3_SDAPH_EINT14       |           |           |     |\n| 237(224+13) | PH13     | JTAG_DOMDCSPI1_MISOTWI3_SCKPH_EINT13       |           |           |     |\n| 234(224+10) | PH10     | RMII_TXD0TWI3_SDAUART0_RXPH_EINT10         |           |           |     |\n|             | CPUX-RX  |                                            |           |           |     |\n|             | UART0-TX | PWM_9RMII_TXD1TWI3_SCKUART0_TXPH_EINT9     |           |           |     |\n| ---         | ---      |                                            |           | ---       | --- |\n|             | GND      |                                            |           |           |     |\n|             | 5V       |                                            |           |           |     |\n| 230(224+6)  | PH6      | PWM_6RMII_RXD0TWI2_SDAUART2_RXPH_EINT6     |           |           |     |\n| 231(224+7)  | PH7      | PWM_7RMII_CRS_DVUART0_TXUART2_RTSPH_EINT7  |           |           |     |\n| 232(224+8)  | PH8      | PWM_8RMII_RXERUART0_RXUART2_CTSPH_EINT8    |           |           |     |\n|             | GPADC0   |                                            |           |           |     |\n| 224(224+0)  | PH0      | PWM_0I2S0_MCLKSPI1_CLKUART3_TXPH_EINT0     | SPI1_CLK  |           |     |\n| 225(224+1)  | PH1      | PWM_1I2S0_BCLKSPI1_MOSIUART3_RXPH_EINT1    | SPI1_MOSI |           |     |\n| 226(224+2)  | PH2      | PWM_2I2S0_LRCKSPI1_MISOUART3_CTSPH_EINT2   | SPI1_MISO |           |     |\n| 227(224+3)  | PH3      | PWM_3I2S0_DOUTSPI1_CS0UART3_RTSPH_EINT3    | SPI1_CS0  |           |     |\n\n\n\n\n\n## PWM LED 测试\n\n使用 sysfs 操作 PWM 的例子：\n     \n<!-- 678 -->\n\n```shell\n#首先打开PWM6通道\ncd /sys/devices/platform/soc/300a000.pwm/pwm/pwmchip0\n\nroot@sipeed:/sys/devices/platform/soc/300a000.pwm/pwm/pwmchip0# echo 6 > export \n\nroot@sipeed:/sys/devices/platform/soc/300a000.pwm/pwm/pwmchip0# ls\ndevice     export     npwm       pwm6       subsystem  uevent     unexport\n\n#设置PWM周期\ncd /sys/devices/platform/soc/300a000.pwm/pwm/pwmchip0/pwm6\nroot@sipeed:/sys/devices/platform/soc/300a000.pwm/pwm/pwmchip0/pwm6# echo 1000000 > period \n\n#设置PWM占空比\nroot@sipeed:/sys/devices/platform/soc/300a000.pwm/pwm/pwmchip0/pwm6# echo 10000 > duty_cycle\n\n#开启PWM功能\nroot@sipeed:/sys/devices/platform/soc/300a000.pwm/pwm/pwmchip0/pwm6# echo 1 > enable\n\n#用示波器或者LED灯观察PH0端口是否有PWM波输出\n```\n\n## Python-PWM\n\n```python\nimport time\nfrom maix import pwm\nimport signal\n\n\ndef handle_signal_z(signum,frame):\n    print(\"APP OVER\")\n    exit(0)\n\n\nsignal.signal(signal.SIGINT,handle_signal_z)\n\n\nwith pwm.PWM(6) as pwm6:\n        pwm6.period = 1000000\n        pwm6.duty_cycle = 10000\n        pwm6.enable = True\n        duty_cycle = 10000\n        while True:\n            for i in range(1,10):\n                pwm6.duty_cycle = 10000 * i\n                time.sleep(1)\n```\n\n\n## V831 Dock 改变引脚复用关系\n\n以PH0为例,查询v831的datasheet手册我们能得到:\n![](./../../assets/linux/PWM/2021-09-22_10-37.png)\n![](./../../assets/linux/PWM/2021-09-22_10-35.png)\n`0x0300B0FC`寄存器的最低三位是控制PH0的引脚复用关系的,我们通过linux指令进行查看该寄存器中的值.\n\n~~~ shell\nroot@sipeed:/sys/class/sunxi_dump# ls\ncompare  dump     rw_byte  write\nroot@sipeed:/sys/class/sunxi_dump# echo 0x0300B0FC > dump \nroot@sipeed:/sys/class/sunxi_dump# cat dump \n0x77114444\n~~~\n由寄存器中的值我们知道最低两位是00,为此我们改变最低位的值,然后再写回去.\n\n~~~ shell\nroot@sipeed:/sys/class/sunxi_dump# echo 0x0300B0FC 0x77114442 > write \nroot@sipeed:/sys/class/sunxi_dump# cat dump \n0x77114442\n~~~\n修改成功后,我们就可以正常使用PWM0通道的PWM波输出了.\n\n\n~~~ python\n#使用PWM0的python3模块,使用其他复用引脚可以参考该写法\n#import PWM就可以使用\n\"\"\"Linux PWM driver sysfs interface\"\"\"\n\nimport os\nimport struct\n__author__ = 'Scott Ellis'\n__version__ = '1.0'\n__license__ = 'New BSD'\n__copyright__ = 'Copyright (c) 2016 Scott Ellis'\nfrom types import (\n    TracebackType,\n)\nfrom typing import (\n    Optional,\n    Type,\n)\nclass PWM(object):\n    \"\"\"\n    A class to work with the Linux PWM driver sysfs interface\n    \"\"\"\n\n    def __init__(self, channel: int = 0, chip: int = 0) -> None:\n        \"\"\" Specify channel and chip when creating an instance\n        The Linux kernel driver exports a sysfs interface like this\n            /sys/class/pwm/pwmchip<chip>/pwm<channel>\n        A <chip> can have multiple <channels>.\n        The channel and chip are determined by the kernel driver.\n        For example the two PWM timers from the RPi kernel driver\n        show up like this\n            /sys/class/pwm/pwmchip0/pwm0\n            /sys/class/pwm/pwmchip0/pwm1\n        To use the RPi timers create instances this way\n            pwm0 = PWM(0) or PWM(0,0)\n            pwm1 = PWM(1) or PWM(1,0)\n        \"\"\"\n        self._channel = channel\n        self._chip = chip\n        self.base = '/sys/class/pwm/pwmchip{:d}'.format(self._chip)\n        self.path = self.base + '/pwm{:d}'.format(self._channel)\n        #调整引脚复用功能\n        with open(\"/sys/class/sunxi_dump/dump\",\"wb\") as f:\n            f.write(b'0x0300B0FC')\n        with open(\"/sys/class/sunxi_dump/dump\",\"rb\") as f:\n            self.gpio = f.read()\n            self.gpio = self.gpio[:-1]\n        with open(\"/sys/class/sunxi_dump/write\",\"wb\") as f:\n            gpio_H0 = int(self.gpio,16)\n            gpio_H0 &= ~0x00000007\n            gpio_H0 |= 0x00000002\n            gpio_io = b'0x0300B0FC ' + bytes(hex(gpio_H0), 'ascii')\n            f.write(gpio_io)\n        if not os.path.isdir(self.base):\n            raise FileNotFoundError('Directory not found: ' + self.base)\n\n    # enable class as a context manager\n    def __enter__(self) -> 'PWM':\n        self.export()\n        return self\n\n    def __exit__(self,\n            exc_type: Optional[Type[BaseException]],\n            exc_value: Optional[BaseException],\n            traceback: Optional[TracebackType]) -> None:\n        self.enable = False\n        self.inversed = False\n        self.unexport()\n        #还原引脚复用功能\n        with open(\"/sys/class/sunxi_dump/dump\",\"wb\") as f:\n            f.write(b'0x0300B0FC')\n        with open(\"/sys/class/sunxi_dump/dump\",\"rb\") as f:\n            self.gpio_o = f.read()\n            self.gpio_o = self.gpio[:-1]\n        with open(\"/sys/class/sunxi_dump/write\",\"wb\") as f:\n            gpio_H0 = int(self.gpio,16)\n            gpio_H0 &= 0x00000007\n            gpio_H0_o = int(self.gpio_o,16)\n            gpio_H0_o &= ~0x00000007\n            gpio_H0_o |= gpio_H0\n            gpio_io = b'0x0300B0FC ' + bytes(hex(gpio_H0_o), 'ascii')\n            f.write(gpio_io)\n        return\n\n    def export(self) -> None:\n        \"\"\"Export the channel for use through the sysfs interface.\n        Required before first use.\n        \"\"\"\n        if not os.path.isdir(self.path):\n            with open(self.base + '/export', 'w') as f:\n                f.write('{:d}'.format(self._channel))\n\n    def unexport(self) -> None:\n        \"\"\"Unexport the channel.\n        The sysfs interface is no longer usable until it is exported again.\n        \"\"\"\n        if os.path.isdir(self.path):\n            with open(self.base + '/unexport', 'w') as f:\n                f.write('{:d}'.format(self._channel))\n\n    @property\n    def channel(self) -> int:\n        \"\"\"The channel used by this instance.\n        Read-only, set in the constructor.\n        \"\"\"\n        return self._channel\n\n    @property\n    def chip(self) -> int:\n        \"\"\"The chip used by this instance.\n        Read-only, set in the constructor.\n        \"\"\"\n        return self._chip\n\n    @property\n    def period(self) -> int:\n        \"\"\"The period of the pwm timer in nanoseconds.\"\"\"\n        with open(self.path + '/period', 'r') as f:\n            value = f.readline().strip()\n\n        return int(value)\n\n    @period.setter\n    def period(self, value: int) -> None:\n        with open(self.path + '/period', 'w') as f:\n            f.write('{:d}'.format(value))\n\n    @property\n    def duty_cycle(self) -> int:\n        \"\"\"The duty_cycle (the ON pulse) of the timer in nanoseconds.\"\"\"\n        with open(self.path + '/duty_cycle', 'r') as f:\n            value = f.readline().strip()\n\n        return int(value)\n\n    @duty_cycle.setter\n    def duty_cycle(self, value: int) -> None:\n        with open(self.path + '/duty_cycle', 'w') as f:\n            f.write('{:d}'.format(value))\n\n    @property\n    def enable(self) -> bool:\n        \"\"\"Enable or disable the timer, boolean\"\"\"\n        with open(self.path + '/enable', 'r') as f:\n            value = f.readline().strip()\n\n        return True if value == '1' else False\n\n    @enable.setter\n    def enable(self, value: bool) -> None:\n        with open(self.path + '/enable', 'w') as f:\n            if value:\n                f.write('1')\n            else:\n                f.write('0')\n\n    @property\n    def inversed(self) -> bool:\n        \"\"\"normal polarity or inversed, boolean\"\"\"\n        with open(self.path + '/polarity', 'r') as f:\n            value = f.readline().strip()\n\n        return True if value == 'inversed' else False\n\n    @inversed.setter\n    def inversed(self, value: bool) -> None:\n        with open(self.path + '/polarity', 'w') as f:\n            if value:\n                f.write('inversed')\n            else:\n                f.write('normal')\n~~~"}, "/soft/maixpy3/zh/api/maix/camera.html": {"title": "", "content": ""}, "/soft/maixpy3/zh/api/maix/imagee.html": {"title": "", "content": ""}, "/soft/maixpy3/zh/api/maix/display.html": {"title": "", "content": ""}, "/soft/maixpy3/zh/api/maix/v831_wifi.html": {"title": "MaixII M2dock wifi 调试", "content": "---\ntitle: MaixII M2dock wifi 调试\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: MaixII M2dock wifi 调试\n---\n\n\n## V831 WIFI 调试\n\n在 /etc/wpa_supplicant.conf 中新增用户 WIFI \n\n```text\nctrl_interface=/tmp/wpa_supplicant\nupdate_config=1\n\nnetwork={\n    ssid=\"Sipeed\"\n    psk=\"123456789\"\n}\n# 自己可以配置多个 wifi\nnetwork={\n    ssid=\"Geek-mi\"\n    psk=\"Geek.99110099\"\n}\n```\n\n重启系统（重新上电）之后板子就能自动连接 WIFI\n\n***\n\n## 调试使用\n\n开启 WIFI 网络相关工具包的编译\n\n开启 WIFI， 连接网络过程\n\n1. 挂载网卡\n\n```text\ninsmod /lib/modules/4.9.118/8189fs.ko\n```\n\n2. 开启网口 wlan0\n\n```text\nifconfig wlan0 up\n```\n\n3. 添加/修改网络配置文件\n\n```text\nvi /etc/wpa_supplicant.conf\n```\n\n\n\n在 /etc/wpa_supplicant.conf 中新增内容(该步骤可省略)\n\n```text\nctrl_interface=/tmp/wpa_supplicant\nupdate_config=1\n\nnetwork={\n    ssid=\"Sipeed\"\n    psk=\"1234567890\"\n}\n# 自己可以配置多个 wifi\nnetwork={\n    ssid=\"Geek-mi\"\n    psk=\"Geek.99110099\"\n}\n```\n\n\n\n4. 启用配置文件，连接网络\n\n```text\nwpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant.conf\n```\n\n\n\n5. 启用 DHCP 分配 IP\n\n> 注意：需要先安装好天线\n\n```text\nudhcpc -i wlan0\n```\n\n6. 测试 ping\n\n```text\nping www.baidu.com\n```\n\n### 配置 WIFI 自动连接\n\n\n\n在用户自定义路径下新建文件内容如下：\n\n> 文件路径: ` /root/develop/wifi_connect.sh`\n\n```text\nmkdir -p /root/develop/ # 创建路径\nvim /root/develop/wifi_connect.sh # 创建 sh 文件\nchmod +x /root/develop/wifi_connect.sh # 修改脚本权限\n\n```\n\n\n\n```text\ninsmod /lib/modules/4.9.118/8189fs.ko\nsleep 1s\n\nifconfig wlan0 up\nsleep 1s\n\nwpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant.conf\nsleep 3s\n\nkillall udhcpc\nsleep 1s\n\nudhcpc -i wlan0\n```\n\n\n\n```text\necho -e  \"sh /root/develop/wifi_connect.sh\" >> /etc/init.d/rcS\n```\n\n```text\n# 1. 挂载网卡驱动\ninsmod /lib/modules/4.9.118/8189fs.ko\nsleep 1s\n# 2. 开启网口 wlan0\nifconfig wlan0 up\nsleep 1s\n# 3. 启用配置文件，连接网络\nwpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant.conf\nsleep 3s\n# 4. 杀死以前的dhcp进程\nkillall udhcpc\nsleep 1s\n# 5. 启用 DHCP 分配 IP\nudhcpc -i wlan0\n```\n\n\n\n```text\n# 关闭有线连接\nifconfig eth0 down\n# 打开无线连接\nifconfig wlan0 up\n# 杀死以前配置进程\nkillall wpa_supplicant\n# 启动wifi配置，使文件生效\nwpa_supplicant -B -Dwext -iwlan0 -c/etc/wpa_supplicant.conf\n# 启动有点慢，等一下启动完毕\nsleep 3s\n# 杀死以前的dhcp进程\nkillall udhcpc\n# 启动dhcp获取ip\nudhcpc -b -i wlan0\n# static ip\n# ifconfig wlan0 192.168.134.250 netmask 255.255.255.0\n# route add default gw 192.168.134.1\n\n```\n\n\n\n## WIFI 带宽/延迟测试\n\n使用 iperf3 测试网络带宽\n\niperf3,默认端口: 5210\n\n\n\n服务端（这里使用 PC）：\n\n```text\niperf3 -s\n```\n\n客户端（这里使用 V831）：\n\n```text\niperf3 -c [serve ip] -p [port]\n```\n\n测试项目：\n\n- WIFI 吞吐量（带宽测试）\n\n- WIFI 丢包/时延测试"}, "/soft/maixpy3/zh/api/maix/nn.html": {"title": "MaixPy3 nn模块(maix.nn)", "content": "---\ntitle: MaixPy3 nn模块(maix.nn)\nkeywords: MaixPy3, maix.nn, MaixPy3运行模型, maix.nn API\ndesc: MaixPy3 nn模块 API文档, 以及使用说明\n---\n\n>! API 仍处于非完全稳定状态, 可能在未来会有小幅改动, 如果你遇到了语法错误， 记得回来看更新哦~\n\n## maix.nn 基本使用介绍\n\n* 准备模型\n\n比如从 maixhub 下载, 这里以边缘检测模型为例, 先[下载模型](https://maixhub.com/modelInfo?modelId=24)(需要先注册登录)\n\n* 准备一张 `224 x 224` 分辨率的图像, 比如这里放到了开发板文件系统的`/root/test.png`位置\n\n* 运行代码, 将下面的代码保存到开发板的`test_model.py`中, 然后运行`python test_model.py`\n\n其中最重要的就是`m = nn.load`和`m.forward()`两个函数, 即加载模型, 和进行模型前向推理\n\n```python\nfrom maix import nn, display\nfrom PIL import Image\nimport numpy as np\n\ntest_jpg = \"/root/test.png\"\n\nmodel = {\n    \"param\": \"/root/models/sobel_int8.param\",\n    \"bin\": \"/root/models/sobel_int8.bin\"\n}\n\ninput_size = (224, 224, 3)\noutput_size = (222, 222, 3)\n\noptions = {\n    \"model_type\":  \"awnn\",\n    \"inputs\": {\n        \"input0\": input_size\n    },\n    \"outputs\": {\n        \"output0\": output_size\n    },\n    \"mean\": [127.5, 127.5, 127.5],\n    \"norm\": [0.0078125, 0.0078125, 0.0078125],\n}\nprint(\"-- load model:\", model)\nm = nn.load(model, opt=options)\nprint(\"-- load ok\")\n\nprint(\"-- read image\")\nimg = Image.open(test_jpg).resize(input_size[:2])\nprint(\"-- read image ok\")\nprint(\"-- forward model with image as input\")\nout = m.forward(img, quantize=True)\nprint(\"-- forward ok\")\nout = out.astype(np.float32).reshape(output_size)\nout = (np.abs(out) * 255 / out.max()).astype(np.uint8)\nimg2 = Image.fromarray(out, mode=\"RGB\")\n\ndisplay.show(img2)\n```\n\n## 方法 maix.nn.load()\n\n加载模型, 返回 `maix.nn.Model` 对象\n\n### 参数\n\n* `model_path`: 模型路径, 可以是字符串或者字典的形式, 目前只支持字典形式\n比如:\n```python\n{\n    \"param\": \"/root/models/sobel_int8.param\",\n    \"bin\": \"/root/models/sobel_int8.bin\"\n}\n```\n\n* `opt`: 设置项, 字典形式, 包括了:\n  * `model_type`: 模型类别, 目前仅支持 `awnn`\n  * `inputs`: 输入层, 字典形式, 关键字是层名称, 为字符串, 如果是加密模型, 需要使用整型; 值是层形状, 为一个`tuple`类型:`(h, w, c)`. 目前只支持单层输入层(未来会支持多层输入, 欢迎提交 `PR`)\n  比如:\n```python\n    # 未加密模型\n    \"inputs\": {\n        \"input0\": (224, 224, 3)\n    }\n    # 加密模型\n    \"inputs\": {\n        0: (224, 224, 3)\n    }\n```\n  * `outputs`: 输出层, 同理输入层. 支持多层输出\n  * `mean`: 如果在`forward`使参数`quantize=True`, 则会使用这个参数对输入数据进行归一化, 计算方法为`(x - mean) * norm`; 格式为`list` 或者 `float`(未支持, 欢迎提交 PR)\n  * `norm`: 看`mean`\n\n### 返回值\n\n返回 `maix.nn.Model` 对象\n\n\n## 类 maix.nn.Model\n\n包含了一系列神经网络操作,  `maix.nn.load()` 会返回其对象\n\n### maix.nn.Model.forward()\n\n只能由具体的对象调用, 不能类直接调用\n\n#### 参数\n\n* `inputs`: 输入, 可以是`Pillow`的`Image`对象, 也可以是`HWC`排列的`bytes`对象, 也可以是`HWC`排列的`numpy.ndarray`对象(还未支持), 多层输入使用`list`(还未支持)\n>! 这个参数未来可能会进行优化\n* `quantize`: 为`True`, 会使用 `load()` 时 `opt` 的`mean norm`参数对数据进行归一化, 并进行`int8`量化； `False`则不会对输入数据进行处理, 则输入需要先自己手动规范量化到`-128~127`范围.  \n>! 这个参数未来可能会进行优化, 将归一化和量化分开\n\n* `layout`: `\"hwc\"` 或者 `\"chw\"`(默认, 推荐)\n* `debug`: 输出`debug`信息, 包含了底层`forward`用时等\n\n#### 返回值\n\n特征图, 如果是单层输出, 是一个浮点类型的 `numpy.ndarray` 对象, 如果是多层输出, 会是一个`list`对象, 包含了多个`numpy.ndarray`对象.\n\n\n### maix.nn.Model.__del__()\n\n删除对象, 内存回收时会自动调用这个函数, 会释放模型占用的资源\n```python\ndel m\n```\n\n## 模块 maix.nn.decoder\n\n`nn` 后处理模块, 集成了常见的模型的后处理, 使用 `forward` 进行模型推理后得到特征图输出, 使用这个模块下的方法对输出的特征图进行后处理\n\n### 类 maix.nn.decoder.Yolo2\n\n`YOLO V2` 的后处理模块, 使用时需要创建一个对象,调用`run`方法对模型推理输出进行解码得到物体的坐标和类别.\n\n等价于如下`python`伪代码:\n\n```python\nclass Yolo2:\n    def __init__(self, class_num, anchors, net_in_size=(224, 244), net_out_size=(7, 7)):\n        pass\n\n    def run(self, fmap, nms = 0.3, threshold = 0.5, img_size = None):\n        boxes = []\n        probs = []\n        for x, y, w, h, _probs in valid_results:\n            if img:\n                x *= img_size[0]\n                y *= img_size[1]\n                w *= img_size[0]\n                h *= img_size[1]\n                x, y, w, h = int(x), int(y), int(w), int(h)\n            boxes.append([x, y, w, h])  # item type is float if img_size == 0, else int type\n            probs.append([max_probs_index, _probs]) # probs is list type, item type is float\n        return [boxes, probs]\n\n```\n\n使用时:\n\n```python\nfrom maix.nn import decoder\n\nlabels = [\"A\", \"B\", \"C\"]\nanchors = [1.19, 1.98, 2.79, 4.59, 4.53, 8.92, 8.06, 5.29, 10.32, 10.65]\n\nyolo2_decoder = decoder.Yolo2(len(labels), anchors)\nyolo2_decoder.run(bytes([0]*10))\n\n...\n\nout = m.forwar(img, layout=\"hwc\")\nboxes, probs = yolo2_decoder.run(out, thres=0.5, nms=0.3, img_size=(img.width, img.height))\nfor i, box in enumerate(boxes):\n    class_id = probs[i][0]\n    prob = probs[i][1][class_id]\n    disp_str = \"{}:{:.2f}%\".format(labels[class_id], prob*100)\n    print(\"final box: {}, {}\".format(box, disp_str))\n\n```\n\n#### maix.nn.decoder.Yolo2.__init__()\n\n构造对象时会自动调用\n\n##### 参数\n\n\n* `class_num`: 类别数量\n* `anchors`: 预选框, `list` 类型, 数量为偶数, 必须要和训练时使用的`anchors` 相同, 也就是说跟模型绑定的参数, 如果你不知道, 请找提供模型的人提供\n* `net_in_size`: 网络输入层分辨率, 默认`(224, 244)`\n* `net_out_size`: 网络输出层分辨率, 默认 `(7, 7)`\n\n\n\n#### maix.nn.decoder.Yolo2.run()\n\n执行解码(后处理), 只能对象进行调用, 不能类直接调用\n\n##### 参数\n\n* `fmap`: 网路输出的特征图, 一般是`forward` 函数的结果\n* `nms`: 非极大值抑制(Non-Maximum Suppression), 用来去掉重复的框, `IOU`(两个框的重叠区域)大于这个值就只取概率大的一个, 取值范围:`[0, 1]`, 默认值为 `0.3`\n* `threshold`: 置信度阈值, 大于这个值才认为物体有效, 取值范围:`[0, 1]`, 默认 `0.5`\n* `img_size`: 源图像大小, `tuple`类型, 比如`(320, 240)`, 这会使返回值的`box` 坐标自动计算为相对于源图的坐标, 并且类型为整型, 默认`None` 则不会计算, `box` 返回相对值(百分比), 浮点类型, 范围:`[0, 1]`\n\n\n##### 返回值\n\n`[boxes, probs]`, `list` 类型, 可以参考上面的使用例子, 其中:\n\n* `boxes`: `list` 类型, 每个元素也是一个`list`, 包含`[x, y, w, h]`, 分别代表了框左上角坐标, 以及框的宽高\n* `probs`: `list` 类型, 每个元素也是一个`list`, 包含`[max_prob_idx, all_classes_probs]`\n  * `all_classes_probs`: `list` 类型, 包含了该框所有类别的置信度\n  * `max_prob_idx`: 整型, 代表了`all_classes_probs`中最大值的下标, 取值范围: `[0, classes_num - 1]`\n\n\n\n\n\n## 模块 maix.nn.app\n\n应用模块， 包含了一些有意思的应用模块\n\n### 模块 maix.nn.app.classifier\n\n自学习分类器（视觉）， 无需训练模型， 只使用特征提取模型， 在运行时学习多个物体特征，然后即可对物体进行分类识别。 适用于简单的分类场景。\n\n`maix.nn.app.classifier`的`python`伪代码:\n\n```python\nclass Classifier:\n    def __init__(self, model, class_num, sample_num, feature_len, input_w, input_h):\n        pass\n\n    def add_class_img(self, img):\n        return idx\n\n    def add_sample_img(self, img):\n        return idx\n\n    def train(self):\n        pass\n\n    def predict(self, img):\n        return idx, min_dist\n\n    def save(self, path):\n        pass\n\ndef load(model, path):\n    return Classifier()\n\n```\n\n#### 类 Classifier\n\n使用时需要指定类别数量，通过`add_class_img`函数传入物体图像来获得物体的特征值， 然后通过`add_sample_img`获取这几个类别的图像，用以对开始采集的图像特征值进行优化， `sample`的图像和开始采集的类别图像可以有一定的差异， 但是不要相差太大， 采集的顺序无所谓；\n然后调用`train`方法进行训练(其实就是`kmeans` 聚类)， 就可以得到使用`sample`图像特征值优化过后的几个分类的特征值；\n最后使用`predict`就可以对输入图像的类别进行识别\n\n##### 构造方法： __init__(self, model, class_num, sample_num, feature_len, input_w, input_h)\n\n* 参数：\n  * `model`: `maix.nn.Model`对象， 用于获得图片的特征值\n  * `class_num`: 要学习的物体类别数量， 比如 `3`\n  * `sample_num`: 用以学习特征的物体数量， 比如`3*5 => 15`\n  * `feature_len`: 特征值的长度， 取决于特征提取模型的输出形状， 比如例程使用`resnet18 1000 分类`模型， 倒数第二层输出长度是`512`\n  * `input_w`: 输入的图像的宽度\n  * `input_h`: 输入的图像的高度\n\n##### 方法: add_class_img(self, img)\n\n添加分类图片， 会自动调用模型推理获取图片的特征值\n\n* 参数：\n  * `img`: 输入图像， 可以是`Pillow`的`Image`对象, 也可以是`HWC`排列的`bytes`对象\n\n* 返回值： `int` 类型, 代表返回成功添加第几个类别的特征值， 取值∈`[0, class_num)`\n\n* 抛出错误： 如果出现错误， 比如添加图片超过类别数量等， 会抛出错误信息\n\n\n##### 方法: add_sample_img(self, img)\n\n添加样本图片， 会自动调用模型推理获取图片的特征值\n\n* 参数：\n  * `img`: 输入图像， 可以是`Pillow`的`Image`对象, 也可以是`HWC`排列的`bytes`对象\n\n* 返回值： `int` 类型, 代表返回成功添加第几个样本图片的特征值， 取值∈`[0, sample_num)`\n\n* 抛出错误： 如果出现错误， 比如添加图片超过设置的样本数量等， 会抛出错误信息\n\n\n##### 方法: train(self)\n\n训练样本（本质上是聚类分类）， 需要在`add_class_img`和`add_sample_img`完成后才能调用，否则会出现误差\n\n\n* 抛出错误： 如果出现错误， 比如类别或者样本采集未完成， 会抛出错误信息\n\n\n##### 方法： predict(self, img)\n\n预测给定的图片所属的类别\n\n* 参数：\n  * `img`: 输入图像， 可以是`Pillow`的`Image`对象, 也可以是`HWC`排列的`bytes`对象\n\n* 返回值：\n  * `idx`: `int` 类型, 代表给定的图片的特征和这个分类最接近， 取值∈`[0, sample_num)`\n  * `min_dist`: 图片的特征和`idx`类别的特征的距离， 距离越小则代表和该类越相似\n\n* 抛出错误： 如果出现错误， 比如参数错误等， 会抛出错误\n\n\n##### 方法： save(self, path)\n\n保存当前的特征值参数到文件， 方便断电保存并下次加载使用\n\n* 参数：\n  * `path`: 保存的路径， 字符串\n\n* 抛出错误： 保存出错， 会抛出错误信息\n\n\n#### 方法 load(model, path)\n\n加载保存的特征值参数文件， 获得[类 Classifier](#类-Classifier)的对象， 加载完成后可直接使用`predict`函数\n\n* 参数：\n  * `model`: `maix.nn.Model`对象， 用于获得图片的特征值， 需要和保存的时候使用的模型相同\n  * `path`: 保存参数的路径\n\n* 返回值： 获得[类 Classifier](#类-Classifier)的对象\n\n\n### 模块 maix.nn.app.face\n\n人脸识别模块， [这里](https://github.com/sipeed/MaixPy3/blob/main/ext_modules/_maix_nn/example/face_recognize.py)有一个`Face_Recognizer`类提供了人脸识别的简单封装， 推荐使用\n\n#### 类 FaceRecognize\n\n伪代码：\n\n```python\nclass FaceRecognize:\n  def __init__(self, model_detect, model_fea, fea_len, input_shape, threshold, nms, max_face_num)\n    pass\n\n  def get_faces(self, img, std_img = False):\n    return [ prob, [x,y,w,h], [[x,y], [x,y], [x,y], [x,y], [x,y]], feature ]\n\n  def compare(self, feature_a, feature_b):\n    return score\n```\n\n[这里](https://github.com/sipeed/MaixPy3/blob/main/ext_modules/_maix_nn/example/face_recognize.py)有一个`Face_Recognizer`类提供了人脸识别的简单封装， 推荐使用\n\n使用的模型可以到[这里下载](https://maixhub.com/modelInfo?modelId=29)\n\n##### 构造方法: __init__(self, model_detect, model_fea, fea_len, input_shape, threshold, nms, max_face_num)\n\n\n* 参数\n  * `model_detect`: 检测模型， [maix.nn.Model](#类-maix.nn.Model) 对象\n  * `model_fea`: 特征提取模型， [maix.nn.Model](#类-maix.nn.Model) 对象\n  * `fea_len`: 人脸特征的长度，比如 `256`\n  * `input_shape`: 输入图像的形状，`(w, h, c)`格式， 比如`(224, 224, 3)`\n  * `threshold`: 人脸检测阈值， 默认`0.5`\n  * `nms`: 人脸检测非极大值抑制值，即用来防止重复框一个人脸， 默认`0.3`\n  * `max_face_num`: 支持的同时框的人脸数量，取`1`或者更多\n\n##### 获取人脸信息: get_faces(self, img, std_img = False)\n\n获取人脸信息， 包括位置和特征值等\n\n* 参数\n  * `img`: 输入图像， 分辨率需要和检测模型的输入相同，  比如`224 x 224`， 可以是`PIL.Image.Image`对象， 或者`bytes`对象\n  * `std_img`: 取值`True`或者`False`, 选择是否返回纠正过的标准人脸图片\n\n* 返回值: 返回一个 `list` 对象，`[ prob, box, landmarks, feature, std_img ]`，其中`std_img`根据构造函数的参数`std_img`决定是否存在\n  * `prob`: 检测到人脸的概率， 比设置的`threshold`大\n  * `box`: 人脸框， 值为`[x,y,w,h]` ， 分别代表左上角坐标和框的宽高\n  * `landmarks`: 人脸关键点， 共`5`个点, 格式`[[x,y], [x,y], [x,y], [x,y], [x,y]]`，分别代表了左眼、右眼、鼻子、左嘴角、右嘴角的坐标\n  * `feature`: 人物脸的特征值， 一个`list`，`list`中的项目值类型为`float`（未来有可能会有`feature`为`bytes`的可选项）\n  * `std_img`: 人脸图像，`PIL.Image.Image`对象， 只有当构造函数的参数`std_img`为`True`时才会有这个返回值\n\n##### 对比人脸特征: compare(self, feature_a, feature_b)\n\n对比两个人脸特征值相似度，并返回相似度百分比\n\n* 参数\n  * `feature_a`: `get_faces`函数的返回值, 一个`list`对象或者`bytes`对象\n  * `feature_b`: `get_faces`函数的返回值, 一个`list`对象或者`bytes`对象\n\n* 返回值： 返回两个人脸特征值的对比相似度分数（百分比），取值范围 `∈` `[0.0, 100.0]`"}, "/soft/maixpy3/zh/api/maix/i2c.html": {"title": "MaixII M2dock I2C 调试", "content": "---\ntitle: MaixII M2dock I2C 调试\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: MaixII M2dock I2C 调试\n---\n\nV831 镜像中默认包含 **i2c-tools**, i2c-tools 包含如下四条命令\n\n## 1. i2cdetect\n\n**查询 I2C 用法**\n\n```shell\nUsage: i2cdetect [-y] [-a] [-q|-r] I2CBUS [FIRST LAST]\n       i2cdetect -F I2CBUS\n       i2cdetect -l\n  I2CBUS is an integer or an I2C bus name\n```\n\n**查询 I2C 总线**\n\n```shell\ni2cdetect -l\n```\n\n\n\n**查询 I2C 总线上挂载的设备**\n\n| -y   | 取消交互过程，直接执行指令 |\n| ---- | ------------- |\n| twi2 | I2C 总线编号      |\n\n```shell\ni2cdetect -y 1\n```\n\n\n\n## 2. i2cdump\n\n扫描寄存器内容：\n\n```shell\ni2cdump -y 1 0x68\n```\n\n\n\n## 3. i2cget\n\n```shell\ni2cget -y 1 0x68 0x00\n```\n\n| -y   | 取消交互过程，直接执行指令                 |\n| ---- | ----------------------------- |\n| 1    | I2C 总线编号                      |\n| 0x68 | I2C 设备地址，此处表示 DS3231 RTC 时钟芯片 |\n| 0x00 | 代表存储器地址                       |\n\n\n\n## 4. i2cset\n\n**寄存器内容写入：**\n\n```shell\ni2cset -y 1 0x68 0x00 0x13\n```\n\n| -y   | 取消交互过程，直接执行指令                 |\n| ---- | ----------------------------- |\n| 1    | I2C 总线编号                      |\n| 0x68 | I2C 设备地址，此处表示 DS3231 RTC 时钟芯片 |\n| 0x00 | 寄存器地址                         |\n| 0x13 | 需要写入的寄存器值                     |\n\n## python\n\n```python\nfrom maix import i2c\ni2c = i2c.I2CDevice('/dev/i2c-2', 0x26)\nprint(i2c)\nprint(i2c.read(0x1, 1))\n```"}, "/soft/maixpy3/zh/recommend_articles.html": {"title": "", "content": "# Maixpy3 精选文章"}, "/soft/maixpy3/zh/origin/difference.html": {"title": "MaixPy 与 MaixPy3 的区别", "content": "---\ntitle: MaixPy 与 MaixPy3 的区别\nkeywords: MaixPy, MaixPy3, Python, Python3, MicroPython\ndesc: maixpy doc: MaixPy3\n---\n\n## 区别是？\n\n因为使用 MaixPy 的同学可能有两类人群，一类是从 MicroPython 一路使用过来的，另一类是从 Python3 过来的，所以针对两边的差异，分别做一下说明。\n\n可以这样理解，它们都是专门为 AIoT 提供的 Python 开发环境，提供了各种各样的模块。\n\n- MaixPy 指的是基于 MicroPython 的环境制作的。\n\n- MaixPy3 指的是基于 Linux Python3 的环境制作的。\n\n> 前者是基于 MCU 无系统的，后者是基于 Linux 系统。\n\n除了基本的 Python3 语法一致，在提供的模块方面的存在着不小的差异。\n\n### Python3 与 MicroPython 的区别\n\n大多数时候，Python 的发展以 Python3 为主，以下列出一些与 Python3 的差异化信息。\n\n- MicroPython 和 Python3 在 Python 语法上保持高度的一致性，常用的标准语法命令都已经支持。\n\n- MicroPython 虽然只实现了 Python3 的标准库和容器库的一些部分，常见容器库有同类功能，但不同名的模块，但大多算法类的 Python 逻辑代码是可以拿来即用的。\n\n- MicroPython 兼容实现的 Python3 的异常机制、没有实现元类（metaclass）机制，独立的 GC 机制。\n\n- 在许当不同的硬件微芯片（最低在 nRF51）的移植上， MicroPython 代码接口缺乏一致性，呈现碎片化。\n\n- MicroPython 编译（mpy-corss）后得到的是 mpy ，而不是 Python3 的 pyc 文件。\n\n- MicroPython 在移植 Python3 代码时，经常缺少各种方法，所以要习惯寻找同类接口，而它们的使用方法除了看文档外就只能看源码。\n\n### 总结\n\n- MaixPy 相比 MaixPy3 功能要更简单（简陋）。\n- MaixPy 和 MaixPy3 的开发工具不同。\n- MaixPy 标准库（MicroPython）相比 MaixPy3 有一定的不足。\n- MaixPy 的外设驱动模块具体函数存在差异。\n- 不同的芯片执行效率有差异，MaixPy 和 MaixPy3 的有着不同的内存与性能消耗。\n\n> 如有更多欢迎补充。"}, "/soft/maixpy3/zh/origin/python.html": {"title": "什么是 Python ？", "content": "---\ntitle: 什么是 Python ？\nkeywords: MaixPy, Python, AIOT, 边缘计算\ndesc: maixpy doc: Python\n---\n\n## 说起 Python 语言\n\n> 只提及一些重点，更详细的就请到一些 Python 教程网站学习吧。\n\n为了让从程序员从~~秃头~~事业中解脱，在开源世界里诞生了名为大蟒蛇（Python）的编程语言。\n\n它带来了什么？\n\n- 提供了完整的软件开发标准库。\n- 适应多种编程方式。\n- 用尽量少的代码完成更多工作。\n- 适应时间短、变化快的需求。\n- 让编程工作看起来更像是在“搭积木”。\n- 开源社区长期贡献了大量的第三方库。\n- 可拓展 C 、 C++ 等其他语言编写的模块。\n- 满足了想偷懒的愿望。\n\n它是一门易用的动态编程语言，可以看作现代入门编程语言的起点，程序员平时或多或少都需要使用 Python 代码帮助完成一些日常、简单、重复的脚本操作。\n\n相比其他编程语言，它看起来会很容易理解和使用，对于非专业人士也可以轻松使用起来，以 “Hello, World” 为例。\n\n- C \n\n```c\n#include <stdio.h>\n\nint main(void) {\n  printf(\"Hello, World!\\n\");\n  return 0;\n}\n```\n\n- C++\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n  cout << \"Hello, World!\" << endl;\n  return 0;\n}\n```\n\n- Java\n\n```java\nclass HelloWorld {\n  public static void main(String[] args) {\n    System.out.println(\"Hello, World!\");\n  }\n}\n```\n\n- JavaScript\n\n```javascript\nalert(\"Hello World\")\n```\n\n```javascript\ndocument.write(\"Hello World\")\n```\n\n```javascript\nconsole.log(\"Hello World\")\n```\n\n- Python\n\n```python\nprint(\"Hello, World!\")\n```\n\n不难看出，从人类自然语言的角度来看 Python 语法简单直接，减少了不必要的讯息。\n\n## 它是怎样工作的呢？\n\n在编辑框上编写的 Python 代码，实际上是依次输入到实时运行的解释器程序当中的。\n\n例如下述代码：\n\n```python\ntmp = 1 + 1\nprint(tmp)\n```\n\n运行它后就会输出 2 ，其中 tmp （变量）等于 2 ，如果这时候再运行下述代码。\n\n```python\ntmp = tmp + 1\nprint(tmp)\n```\n\n这时候就会输出 3 ，表示 tmp （变量）等于 3 了。\n\n这是因为每一次运行的 Python 程序都并非是一个全新的开始，它是一直存在于一段程序当中的，只有当解释器程序退出后，才是真的结束程序，所以上一次运行的结果并没有清除，这也是程序不需要编译的原因。\n\n这是与 C / C++ / JAVA 一类编程语言相冲突的地方，我们基于这个差异将 Python 称为动态语言，与此关联的还有 JavaScript 和 Lua 等编程语言。\n\n实时上还有各种各样支持 Python 语言的解释器，虽然写的都是 Python 代码，但并非同一个事物。\n\n我们常用的 Python 编程环境通常指 C 语言实现的 Python 解释器，涵盖 Python2.7 ~ Python3.10 的语法。\n\n而在其他领域来说，有各式各样的 Python 语言的实现，如下：\n\n- MicroPython 使用 Python3.5 语法\n\n- Jython 使用 Java 实现的 Python 语言\n\n- PyPy 通过 JIT 优化的 Python 语言\n\n- IPython 基于 Python 语言的交互接口\n\n也就是说 Python 这个名词，不一定是说 Python 编程语言，还可能是解释器，也可能是程序，这可能会有利于你理解 Python 这个事物背后可能存在的事物。\n\n> 2020 年后不再提及 Python2.7 的任何内容，今后描述的 Python 以 Python3 的语法为准。\n\n## 这一切都这么美好？\n\n并不是。\n\n在这么多编程语言中，Python 对于初学者来说是很上手且简单的，对于一些调用各种库的代码、不在意运行效率，甚至是代码的可维护性也可以忽略的场合，随手一写就可以完成任务。\n\n但代价就是想提升你瞎写程序的性能，你要付出更多的时间去做优化。\n\n> 写出文章不难，写好文章才难。\n\n因为最初不了解 Python 所写出的代码，就像小孩子的涂鸦，到处复制粘贴，以至于写出来的代码东拼西凑整合起来的。\n\n到了这时候，你会发现，一旦你想要改进它是很难做到的，从一开始就不了解它，又谈何改进。\n\n所以这里提及一下，传统的编程语言入门要经历的过程：\n\n- 学习计算机历史\n- 学习计算机语法\n- 学习编程范式\n- 学习使用开发工具\n- 学习使用调试代码\n- 学习程序设计\n\n而使用 Python 语言速成入门培养兴趣和获得成就感的代价就是以后从事这份职业会花费额外的时间补计算机的基础。\n\n> 至少 Python 能让你点火先把火箭飞起来，而不用把火箭制造原理研究透彻了再起飞。\n\n## 学哪个语言更好？\n\n至于哪个更好，这里无法做出评价，建议顺应时代潮流，先解决问题，其他的再说。\n\n- 黑猫白猫抓住老鼠就是好猫。\n- 实践是检验事实的唯一标准。\n\n最终怎么选择，就取决于你自己了。"}, "/soft/maixpy3/zh/question/how_to_ask.html": {"title": "", "content": ""}, "/soft/maixpy3/zh/question/driver_issue.html": {"title": "常见问题", "content": "# 常见问题\n## 问题\n> 21.06.24 目前暂时不支持使用etcher进行系统的烧录，会出现烧录之后无法进入系统，推荐使用dd命令进行烧录"}, "/soft/maixpy3/zh/question/maixpy3_issue.html": {"title": "", "content": ""}, "/soft/maixpy3/zh/python/loop_python.html": {"title": "", "content": "> 本文是给有一点 Python 基础但还想进一步深入的同学，有经验的开发者建议跳过。\n\n## 前言\n\n上文讲述了如何认识开源项目和一些编程方法的介绍，这节主要来说说 Python 代码怎么写的一些演化过程和可以如何写的参考，在现在的 Sipeed 开源社区/社群里，有太多的新手不知道如何写好 Python 代码，尤其是嵌入式中的 Python 代码也是有不少的技巧和观念需要注意的，至少让这篇文章从循环开始说起。\n\n> 可以把本文当作一篇经验之谈，主要是探讨代码稳定性与性能，以及一些计算机知识的拓展。\n\n## 循环执行代码\n\n当写下第一行代码的时候，在电脑上的 Python 解释器运行效果是这样的。\n\n```python\nprint('Hello World')\n```\n\n![](./asserts/win_python.png)\n\n而嵌入式设备上的 python 是通过串口（serial）传出来。\n\n![](./asserts/maix_python.png)\n\n当写完了第一行 `Hello World` 的 `print` 函数，总不能一直复制、粘贴代码吧。\n\n```python\n\nprint('Hello World')\nprint('Hello World')\nprint('Hello World')\nprint('Hello World')\nprint('Hello World')\n\n```\n\n也不是只运行验证功能就好了吧，所以加上了循环（`while`）执行代码。\n\n```python\n\nwhile True:\n    print('Hello World')\n\n```\n\n如果想要稳定一些，最好还要为它加入异常机制，保证它不会因为 Python 代码的运行出错而停下来。\n\n```python\n\nwhile True:\n    try:\n        print('Hello World')\n    except Exception as e:\n        pass\n\n```\n\n### 循环代码中为什么需要异常机制\n\n是不是以为 print 这样的代码就不会出错？其实不然，其实程序越接近底层硬件越容易出错。\n\n从功能上说上文两者之间并没有什么区别，都是输出，但你会发现串口输出可能会出现下面几类情况。\n\n- 串口芯片损坏或线路断路、串口到芯片的通路损坏导致的串口没有数据输出。\n- 串口线路数据不稳定、串口协议（波特率、停止位）等配置错误导致的数据乱码。\n\n这就意味着你会遇到很多来自硬件上的问题，所以要注意到这些意外。\n\n那在软件代码上会发生什么有关于硬件上的意外呢？\n\n通常有无响应、无应答、未连接等不成功的错误，它们是来自 IO 的错误。\n\n- 当网络连接失败后需要超时重连，传输数据通道闲置时需要定时检查心跳数据包。\n- 当配置文件写入后通常会读出来确认真的写入了，也是为了防止出错，可能是存储介质出错，也可能是逻辑出错。\n- 当用户向输入框填了错误数据，不用写怎么判断和处理，不合法的数据抛出异常就行。\n\n因为这些现象太多不确定的可能性，才会需要对代码进行异常捕获机制，来决定是否放过这次意外，可能会在下一次的循环就恢复了，这样就能够基本保证了 Python 代码循环的稳定性了。\n\n### 来自外部/硬件上异常机制\n\n这样就足够了吗？\n\n事实上有些错误不源于 Python 代码，可能来自于底层 C 代码，或其他程序，上文说的异常机制只能捕获 Python 异常，不能捕获来自其他语言的异常。\n\n所以实际情况比想象的要更严峻一些，当你无法解决不稳定的系统带来其他异常的时候，通常在服务器程序上设计会在外部附加一个守护程序（如调试程序）来定时检查自己的程序，例如可以检查下面的一些情况。\n\n- 检查当前的系统是否能联网\n- 检查数据库的通路是否正常\n- 检查指定的程序是否在运行\n\n总得来说，你要为你的程序做一个监控程序，可以是守护程序，也可以是看门狗。\n\n> 具体怎么实现，可以了解一些守护进程的实现。\n\n### 看门狗（watchdog）是什么？\n\n如上述的守护程序是靠一个软件去监控另一个软件的状态，而看门狗的工作行为描述如下：\n\n假设有一条需要定时吃饭（更新）的狗、如果不定时喂它（feed）就会饿着肚子叫。那么问题来了，什么时候狗会叫呢？因为人（芯片）死了，没人喂它了。（这也许是一个冷笑话）\n\n看门狗是要求芯片程序负责定时喂狗，如果没有喂狗就狗就饿死了，作为报复狗会把芯片重启。让它可以继续喂狗。\n\n任何硬件产品都有可能出现意外和错误，看门狗相当于芯片上的最后一层保障机制，通常它可能会发生在函数栈的指针参数执行出错，导致后续的喂狗操作再也执行不到了，具体怎么实现，可以查阅不同芯片提供的程序接口或寄存器。\n\n### 优化！优化！！优化！！！\n\n当你的程序已经跑起来以后，你会发现程序并没有达到令人满意的效果，在性能、内存上都没有经过任何考虑，只是实现了最起码的功能而已，那么完成了功能以后，可以如何继续呢？\n\n当然，在优化程序之前得先建立计算代码执行时间的观念，建立起最简单的性能指标，如在代码加上时间计算。\n\n```python\ndef func():\n    i = 20**20000\n\nimport time\nlast = time.time()\nfunc()\ntmp = time.time() - last\nprint(tmp)\n```\n\n在 CPU I5-7300HQ 的计算机上见到每一次的循环的时间间隔约为 0.000997781753540039 不足 1ms 即可完成。\n\n```bash\nPS C:\\Users\\dls\\Documents\\GitHub\\MaixPy3> & C:/Users/dls/anaconda3/python.exe c:/Users/dls/Documents/GitHub/MaixPy3/test.py\n0.000997781753540039\n```\n\n注意不要写到 `print(time.time() - last)` ，因为重定向后的 print 是相当耗时的，尤其是当内容输出到串口终端或网页前端的时候，如下使用 M2dock 设备来演示一下串口输出。\n\n> 重定向指改变内容要输出的地方\n\n```bash\nroot@sipeed:/# python3\nPython 3.8.5 (default, Jan 17 2021, 06:07:56)\n[GCC 6.4.1] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> def func():\n...     i = 20**20000\n...\n>>> import time\n>>> last = time.time()\n>>> func()\n>>> tmp = time.time() - last\n>>> print(tmp)\n0.09001994132995605\n>>>\n>>>\n>>> def func():\n...     i = 20**20000\n...\n>>> import time\n>>> last = time.time()\n>>> func()\n>>> print(time.time() - last)\n1.480057954788208\n>>>\n```\n\n可以看到相差可能有 1 秒，而事实上只需要 90ms 就可以完成 func 函数的运算，这就产生了误差导致不准确，若是使用 jupyter 输出就会看到 0.026456356048583984 需要 26ms 可以较为准确的推算出它的真实运算结果。\n\n![](./asserts/time_python.png)\n\n为什么会造成这种差异的原因是因为串口依次输入命令输出结果需要时间，所以依次输入语句执行自然会存在误差，而 jupyter 是通过网络 socket 连接传输显示到屏幕上，所以耗时误差只会发生在运算重定向输出结果的时候，最终结果会较为贴近真实运算结果，通过保存下述代码文件来运行即可得知真实情况下约为 26 ~ 28ms 完成。\n\n```bash\nroot@sipeed:/# cat test.py\ndef func():\n    i = 20**20000\n\nimport time\nlast = time.time()\nfunc()\ntmp = time.time() - last\nprint(tmp)\n\nroot@sipeed:/# python test.py\n0.028677940368652344\nroot@sipeed:/#\n```\n\n所以从现在建立起最基础的计算耗时，并且认知到在计算机的世界里，毫秒其实已经很慢了，然后可以类比一种感受，人眼感到流畅的画面至少是 24 fps ，而平时的视频在 15 fps 的流动是不会让你感受到卡顿的，如果低于这个阈值，则会出现卡顿造成心理上的不愉快，这个 15 fps 意味着每秒 15 张存在变化的画面，如果用程序来类比就是 1000 ms / 15 = 66 ms ，也就是每个流程操作最好是在 66ms 内完成，这样用户才不会觉得卡顿，同理，当 1000ms / 24 = 41ms 就可以确保用户体验这个软件的时候会觉得流畅。\n\n有了基本的性能指标，就有了优化的对比参考，如果是一些测试框架会帮助你自动完成每个函数的耗时统计，但在没有现成框架工具的时候就要稍微辛苦一下自己了。\n\n#### 讲一些经典案例\n\n在日常中存在最多操作就是循环和判断，显然好的优化就是减少不必要的指令操作，可以通过改变代码的执行结构来进行优化，下面就来具体分析吧。\n\n如某个向网络上发送数据的操作，最初可能会按人类直觉写出以下的代码，这是一种不用思考也可以很容易写出来的同步阻塞式的结构，每一条语句都是满足了某些条件再继续执行。\n\n```python\n\ndef xxxx_func():\n    import random\n    return random.randint(0, 1)\n\nwhile True:\n    is_idle = True\n    if is_idle is True:\n        print('try start')\n        is_ready = xxxx_func()\n        if is_ready is True:\n            print('try ready')\n            is_connected = xxxx_func()\n            if is_connected is True:\n                print('try connect')\n                is_send = xxxx_func()\n                if is_send is True:\n                    print('try send')\n                    is_reply = xxxx_func()\n                    if is_reply is True:\n                        print('wait reply')\n                        is_exit = xxxx_func()\n                        if is_exit is True:\n                            print('operate successfully')\n```\n\n而优化只需要加状态变量改写成状态机结构（fsm）就可以了，所有代码都可以平行化执行，并根据执行频率的重要程度（权重）调整各项判断的顺序，尤其是移除一些不必要的判断。\n\n```python\ndef xxxx_func():\n    return 1\n\n# state value\nis_idle, is_ready, is_connected, is_send, is_reply, is_exit = 0, 1, 2, 3, 4, 5 \nstate = is_idle\n\nwhile state != is_exit:\n\n    if state is is_reply:\n        print('wait reply')\n        state = is_exit if xxxx_func() else is_send\n        continue\n\n    if state is is_send:\n        print('try send')\n        state = is_reply if xxxx_func() else is_connected\n        continue\n\n    if state is is_connected:\n        print('try connect')\n        state = is_send if xxxx_func() else is_ready\n        continue\n\n    if state is is_ready:\n        print('try ready')\n        state = is_connected if xxxx_func() else is_idle\n        continue\n\n    if state is is_idle:\n        print('try start')\n        state = is_ready\n        continue\n```\n\n这样改造执行结构后，每个代码之间的上下文关系并不强烈，是否执行某个语句取决于系统对于某个状态是否满足，如果状态失败也不会倒退回最初的判断，也就不需要每次都对各个状态做检查，检查只会发生在出错的时候状态跌落（state - 1）。\n\n缺点就是需要消耗一些记录状态的变量(●'◡'●)，不过代码的拓展性和维护性就上来了。\n\n> 可以根据实际情况增加状态的判断或是减少状态的转移（调整状态转移范围），如直接设置 state = is_ready，假设某些操作是已知的就可以跳过，可以添加 continue 跳过一些不可能发生的状态。\n\n#### 还有吗？\n\n进一步优化还可以干掉 if 直接将状态与函数联合索引执行，简化代码如下。\n\n```python\n\nis_a, is_b, is_c = 0, 1, 2\n\nstate = is_a\n\ndef try_b():\n    global state\n    state = is_c\n\ndef try_a():\n    global state\n    state = is_b\n\nfunc = [try_a, try_b]\n\nwhile state != is_c:\n    func[state]()\n    # print(state)\n\n```\n\n基于上述结构给出一个示例代码参考。\n\n```python\n\nclass xxxx_fsm:\n            \n    is_start, is_ready, is_connected, is_send, is_reply, is_exit = 0, 1, 2, 3, 4, 5\n\n    def xxxx_func(self):\n        return 1\n\n    def __init__(self):\n        self.func = [self.try_start, self.try_ready, self.try_connect, self.try_send, self.wait_reply]\n        self.state = __class__.is_start # state value\n\n    def wait_reply(self):\n        self.state = __class__.is_exit if self.xxxx_func() else __class__.is_send\n\n    def try_send(self):\n        self.state = __class__.is_reply if self.xxxx_func() else __class__.is_connected\n\n    def try_connect(self):\n        self.state = __class__.is_send if self.xxxx_func() else __class__.is_ready\n\n    def try_ready(self):\n        self.state = __class__.is_connected if self.xxxx_func() else __class__.is_start\n\n    def try_start(self):\n        self.state = __class__.is_ready\n\n    def event(self):\n        self.func[self.state]()\n\n    def check(self):\n        return self.state != __class__.is_exit\n\ntmp = xxxx_fsm()\n\nwhile tmp.check():\n\n    tmp.event()\n\n    # print(tmp.state)\n```\n\n其实上述的有限状态机并非万能的代码结构，只是刚好很适合拆分已知的复杂业务逻辑的同步阻塞代码，那么还有什么结构可以选择吗？有的，此前说的都是同步阻塞的代码，所以还有所谓的异步执行的代码。\n\n#### 说说异步的执行方式\n\n在这之前的代码都是按每个循环的步骤有序执行完成功能（同步执行），但现实生活中的操作一定是按顺序发生的吗？其实不然，其实很多操作可能会在任意时刻发生。\n\n想象一个程序，它会响应来自网络的数据，也会响应来自人类的按键输入操作，这两个操作如果按上述的结构来写，可能会是下面这样。\n\n```python\nimport time, random\n\ndef check_http():\n    time.sleep(random.randint(0, 3))\n    return random.randint(0, 1)\n\ndef http_recv():\n    while True:\n        if check_http():\n            print('http_recv')\n            break\n\ndef check_key():\n    time.sleep(random.randint(0, 2))\n    return random.randint(0, 1)\n\ndef key_press():\n    while True:\n        if check_key():\n            print('key_press')\n            break\n\nwhile True:\n    http_recv()\n    key_press()\n```\n\n可以看到 http_recv 和 key_press 两个事件的检查会各自占据一段不知何时会触发或结束的检测的时间，程序只能循环等待这些事件会不会发生（或称轮询）。\n\n这是个看起来可以工作但浪费了很多时间的程序，现实里接收到许多用户的网络连接，而服务程序不可能只服务某个用户的连接。\n\n所以改写异步的第一步就是简化代码中不必要的循环，将每个需要循环等待的部分拆分成非阻塞的函数。\n\n> 非阻塞意味着某个操作会在有限的时间内结束，期望某个函数能够在较短的时间（10ms）内退出，退出不代表功能结束，只是需要把这个时间让出去给其他函数调用。\n\n```python\nimport time, random\n\nhttp_state, key_state = 0, 0\n\ndef http_recv():\n    global http_state\n    if http_state:\n        print('http_recv')\n\ndef key_press():\n    global key_state\n    if key_state:\n        print('key_press')\n\ndef check_state():\n    global key_state, http_state\n    time.sleep(random.randint(0, 1))\n    key_state, http_state = random.randint(0, 2), random.randint(0, 2)\n\nwhile True:\n    check_state()\n    http_recv()\n    key_press()\n```\n\n从逻辑上移除了等待，再通过统一的（check_state）检查每个操作的状态再决定是否唤醒该操作，变成只有满足某个状态才执行该操作，将此前的多个循环拆分出来。\n\n但你会发现这样写还是有问题，这样岂不是意味着所有代码都要按这个接口来写了吗？那么多的代码，不可能全都可以拆分吧。\n\n所以是时候加入异步 IO （asyncio）的 async 和 await 语法了！先来点简单的。\n\n```python\nimport asyncio\n\nasync def test_task(name, tm):\n    await asyncio.sleep(tm)\n    print('%s over...' % name)\n\nasync def main(name):\n    import time\n    last = time.time()\n    await asyncio.gather(\n        test_task(name + 'A', 0.1),\n        test_task(name + 'B', 0.2),\n        test_task(name + 'C', 0.3),\n    )\n    print(name, time.time() - last)\n\nloop = asyncio.get_event_loop()\ntasks = [ main('l: '), main('r: ') ]\nloop.run_until_complete(asyncio.wait(tasks))\n\n```\n\n运行结果如下：\n\n```bash\nPS python.exe test.py\nr: A over...\nl: A over...\nr: B over...\nl: B over...\nr: C over...\nl: C over...\nr:  0.3076450824737549\nl:  0.3076450824737549\n```\n\n可以看到代码总共耗时为 0.3s 完成，但运行了两次不同所属的 main 函数以及各自调用三次不同延时的 test_task 任务，而 await asyncio.sleep(tm) 延时期间实际上是被 asyncio 拿去运行其他的 async 函数了，基于此结构可以这样改写。\n\n```python\n\nimport asyncio, random\n\nasync def key_press():\n    await asyncio.sleep(0.1)\n    key_state = random.randint(0, 1)\n    if key_state:\n        return 'have key_press'\n\nasync def http_recv():\n    await asyncio.sleep(0.2)\n    http_state = random.randint(0, 1)\n    if http_state:\n        return 'have http_recv'\n\nasync def run():\n    import time\n    while True:\n        task_list = [http_recv(), key_press()]\n        done, pending = await asyncio.wait(task_list, timeout=random.randint(0, 1) / 2)\n        print(time.time(), [done_task.result() for done_task in done])\n        await asyncio.sleep(0.2) # remove to run too fast.\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(run())\n```\n\n执行效果如下。\n\n```bash\n1615141673.93252 [None, None]\n1615141674.134 [None, 'have http_recv']\n1615141674.3350334 [None, None]\n1615141674.7361133 ['have key_press', 'have http_recv']\n1615141674.9365196 [None, None]\n1615141675.1399093 ['have http_recv', None]\n```\n\n可以看到在运行 run 函数延时 `await asyncio.sleep(0.2)` 后就会循环加载异步事件函数执行，配置 asyncio.wait 函数的参数 `timeout` 会导致 `random.randint(0, 1) / 2` 秒后就会自行超时退出，退出的时候会收集当前的 `key_press` 和 `http_recv` 函数的运行结果，如果期间异步函数成功返回值（`return 'have http_recv'`），最终结果就会输出 `1615138982.9762554 ['have http_recv']` 表示有事件触发并执行了，否则为 None ，这将在下一次循环重新提交异步函数列表 `[http_recv(), key_press()]` 执行。\n\n> 注意 Python 3.7 以前的版本使用 loop = asyncio.get_event_loop() & loop.run_forever() & loop.run_until_complete() ，而后采用 asyncio.run() 了。每个编程语言都有自己的异步框架和语法特色，请根据实际情况选用。\n\n### 考虑一下封装模块给其他人使用吧？\n\n随着代码越写越多，项目越来越大，大到可能不是你一个人写的时候，你就要开始注意工程项目的管理了，这与个人写代码时的优化略微不同，主要强调的是不同代码之间的接口分离，尽量不干涉到他人的实现和提交，所以在写代码的时候，不妨为自己准备一个独立模块，以方便与其他人写的分离或是导入其他（import）模块。\n\n若是在某个目录（`mod`）下存在一个 `__init__.py` 的话，它就会变成 Python 模块，且名为 `mod` ，其中 `__init__.py` 的内容可能如下：\n\n```python\ndef code():\n    print('this is code')\n```\n\n而且在该目录下还存在一个额外的代码文件（如 `tmp.py` ）内容如下：\n\n```python\ninfo = 'nihao'\n```\n\n对于开发者或用户来说，在 `import mod` 的时候会调用 `mod` 目录下的 `__init__.py` ，而 `from mod import tmp` 会调用 `mod` 目录下的 `tmp.py` 代码。\n\n```python\n>>> import mod\n>>> mod\n<module 'mod' from 'C:\\\\mod\\\\__init__.py'>\n>>> mod.code()\nthis is code\n>>> from mod import tmp\n>>> tmp\n<module 'mod.tmp' from 'C:\\\\mod\\\\tmp.py'>\n>>> tmp.info\n'nihao'\n>>>\n```\n\n这样你写的代码就可以作为一个模块被其他人所使用了，注意 import 只会加载并执行一次，想要再次加载请使用 reload 函数。\n\n### 如何进行内存上的分析？\n\n这里就推荐 [memory_profiler](https://github.com/pythonprofilers/memory_profiler) 开源工具，快去体验吧。\n\n使用方法：`python -m memory_profiler example.py`\n\n```python\nfrom memory_profiler import profile\n\n@profile\ndef my_func():\n    a = [1] * (10 ** 6)\n    b = [2] * (2 * 10 ** 7)\n    del b\n    return a\n```\n\n运行结果：\n\n```bash\nLine #    Mem usage    Increment  Occurences   Line Contents\n============================================================\n     3   38.816 MiB   38.816 MiB           1   @profile\n     4                                         def my_func():\n     5   46.492 MiB    7.676 MiB           1       a = [1] * (10 ** 6)\n     6  199.117 MiB  152.625 MiB           1       b = [2] * (2 * 10 ** 7)\n     7   46.629 MiB -152.488 MiB           1       del b\n     8   46.629 MiB    0.000 MiB           1       return a\n```\n\n## 总结\n\n其实所谓的优化就是在程序上不断追求无延迟、零等待、鲁棒性、艺术品、最佳实践等指标。\n\n当完成了自己的某个作品，多少都会希望自己的作品是最好的，又或是越做越好的。熬夜辛苦写下的程序，用尽自己的脑力和各种逻辑思维来不断打磨它，尽可能的把它变成一件艺术品，然后为之自豪和兴奋，恨不得向它人炫耀自己的成果。\n\n但愿你不会在往后的一堆垃圾代码中失去了最初喜欢上编程的心情。\n\n### 附录：多线程？多进程？该不该使用？\n\n事实上多线程和多进程都是建立在操作系统之上的概念，由于操作系统中存在不同优先级的中断函数，其中优先级较高的函数栈会打断优先级低的函数栈执行，并且优先级高的操作结束就会轮到优先级低的操作，优先级高的操作通常都会被设计成尽快结束退出（哪怕是失败），不然用户程序就会像老爷爷一样缓慢运行了。\n\n多线程是由拥有内存空间进程（某个程序）创造出来的，多线程函数“看上去”是彼此并行的，并且共用所属进程的内存数据，而不同进程之间申请的内存空间并不互通，所以当你想要实现守护进程的程序，是需要对其他进程进行通信的（如卸载程序时会检查并发送信号停止要卸载的程序），并非是在代码中修改一个变量那么简单。\n\n事实上我并不鼓励用户在 Python 上使用多线程，因为全局解释器锁（GIL）的存在，CPython 解释器中执行的每一个 Python 线程，都会先锁住自己，以阻止别的线程执行。而 CPython 解释器会去轮询检查线程 GIL 的锁住情况，每隔一段时间，Python 解释器就会强制当前线程去释放 GIL，这样别的线程才能有执行的机会。总得来说 CPython 的实现决定了使用多线程并不会带来太大的性能提升，反而会带来更多线程安全的问题，尤其是需要线程资源同步了。\n\n> 警告：请不要在每个线程中都写上不会退出的死循环，多线程的并不是拿来偷懒的工具。"}, "/soft/maixpy3/zh/python/hello_world.html": {"title": "Hello World", "content": "---\ntitle: Hello World\nkeywords: Hello World, MaixPy3, Python, Python3\ndesc: maixpy doc: Hello World\n---\n\n> 本文是给有一点 Python 基础但还想进一步深入的同学，有经验的开发者建议跳过。\n\n## 前言\n\n在写这篇案例系列的时候 [junhuanchen](https://github.com/junhuanchen) 期望能够引导用户如何成为专业的开发者，不是只会调用代码就好，所以在 MaixPy3 开源项目上期望为你带来值得学习和容易上手的开源项目，所以开篇会引导用户学习一些长期有利于编程工作上好的做法和观念，就先从最简单的认知项目开始吧。\n\n第一次接触需要编程的开源硬件项目，要做的第一件事就是先有一个好的开始，例如运行 Hello World 程序，意味着你必须能够先将这个事物跑起来才能够继续后续的内容，它可能是硬件、软件、工具等可编程的载体。\n\n> 但这里先不强调立刻开始运行程序，而是强调如何熟悉一个开源项目。\n\n要先找到它提供的开发文档（例如本文），先纵览全文，站在专业的角度来看，你需要先关注它提供了哪些资源，可以在哪里反馈你的问题，这样就有利于你后续开发过程中出现问题后，该如何迅速得到解决，避免自己之后在学习和开发过程中耽误时间。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/OSDC_Resource_Main_Page.png)\n\n有哪些资源是值得关注的？\n\n- 学会搜索！！！！！\n- 找到它的开源项目（如：[github.com/sipeed](https://github.com/sipeed)），获取它所提供的一系列源码。\n- 找到它提供的用户手册、应用案例、数据手册等等一系列开发所需要的文档。\n- 找到它的开发、编译、烧录、量产等一系列配套工具链，为后续软件开发活动中做准备。\n- 找到它的公开交流的环境，如 bbs、github、twitter、facebook、qq、wechat 等社交平台。\n\n现在你可以放心的编程了，但你还需要遵守一些在开源软件上的规则，认知到开源协议的存在，不要随意地做出侵犯他人软件的行为，哪怕没有法律责任的问题。\n\n在开源软件的世界里，鼓励人们自由参与和贡献代码，而不是鼓励如何免费白嫖，自由不等于免费，免费不等于服务，将软件源码公开是为了让用户更好更具有针对性的提交和反馈项目中存在的问题，不是为了更好服务你，请不要以服务自己的产品为中心。\n\n请尊重所有在开源环境里工作的朋友们，尊重他们（或是未来的你）的劳动成果。\n\n最后在开源的世界里，学会技术，学会成长，学会参与项目，学会分享成果！\n\n## Hello World\n\n> 关于本机怎样安装运行 Python 的基础知识，建议从其他网站教程得知。\n\n说了这么多，不如先来运行一段 Python3 代码吧。\n\n```python\nprint(\"hello world\")\n```\n\n> 点击下方的 run 按钮即可运行，如果有条件就在本机运行测试。\n\n<div align=\"center\" >\n    <iframe src=\"https://tool.lu/coderunner/embed/aEj.html\" style=\"width:90%; height:320px;\" frameborder=\"0\" mozallowfullscreen webkitallowfullscreen allowfullscreen></iframe>\n</div>\n\n> 在线 Python 编程 [runoob-python](https://www.runoob.com/try/runcode.php?filename=HelloWorld&type=python3) [google-colab](https://colab.research.google.com) 备用地址。\n\n但这样的代码是不够的，稍微认真一点写。\n\n```python\n# encoding: utf-8\n\ndef unit_test():\n    '''\n    this is unit_test\n    '''\n    print(\"hello world\")\n    raise Exception('unit_test')\n\nif __name__ == \"__main__\":\n    try:\n        unit_test()\n    except Exception as e:\n        import sys, traceback\n        exc_type, exc_value, exc_obj = sys.exc_info()\n        traceback.print_tb(exc_obj)\n        print('have a error:', e)\n\n```\n\n运行结果：\n\n```bash\nPS C:\\Users\\dls\\Documents\\GitHub\\MaixPy3> & C:/Users/dls/anaconda3/python.exe c:/Users/dls/Documents/GitHub/MaixPy3/test.py\nhello world\n  File \"c:/Users/dls/Documents/GitHub/MaixPy3/test.py\", line 12, in <module>\n    unit_test()\n  File \"c:/Users/dls/Documents/GitHub/MaixPy3/test.py\", line 8, in unit_test\n    raise Exception('unit_test')\nhave a error: unit_test\n```\n\n代码瞬间就变得复杂了起来？其实不然，这么写必然有它的用意，那这么写都考虑到了哪些情况呢？\n\n### 注意字符编码和代码缩进格式\n\n初学者经常会出现缩进不对齐的语法问题，代码的语法出现问题过于基础就不详谈，检查代码的小技巧就是 `CTAL + A` 全选代码，按 TAB 键右缩进，再配合 SHIFT + TAB 左缩进来发现哪段代码存在问题。\n\n首行的 `# encoding: utf-8` 是为了避免在代码中存在中文或其他语言的字符编码导致的运行出错的问题。\n\n> 在 python3 的字符串类型中 str 与 bytes 是一对欢喜冤家，例如 print(b'123') 打印出来的是 b'123' ，而实际上就是 '123' 的 bytes 字符串，前缀 b 只是为了和 str 区分，因为用途不同，在不同的接口对数据类型的需求不对，例如传递 str 字符串时候是不允许输入 '\\xFF' (0xFF) 字符的（会在转换过程中丢失），但 bytes 可以存储和表达。\n\n### 给代码加入单元测试和异常捕获\n\n想要写出一套稳定可用的代码，需要围绕接口可重入可测试的设计来编写封装，任何人写的代码都可能存在缺陷，在不能确定是哪里产生的问题之前，要能够恢复现场也要能够定位具体位置，以求问题能够最快得到反馈。\n\n所以在代码功能还没写之前，先把测试和异常的模板写好，再开始写功能，边写边测，确保最终交付的软件代码就算出问题也可以随时被测试（定位）出来。\n\n```python\n\ndef unit_test():\n    '''\n    this is unit_test\n    '''\n    print(\"hello world\")\n\nif __name__ == \"__main__\":\n    unit_test()\n```\n\n这样的代码可以保证任何人在任何时候运行该代码的时候都可以复现当时写下的场合所做的内容，然后 `if __name__ == \"__main__\":` 意味着该代码被其他模块包含的时候，不会在 import 该 Python 模块（可取名成 `hello` ）模块时调用，而是根据自己的代码需要执行相应的单元测试进行测试。\n\n```python\nimport hello\nhello.unit_test() # print(\"hello world\")\n```\n\n接着加入异常机制（try: except Exception as e:）保护代码段，表示该段代码出错的时候，能够不停下代码继续运行，像硬件资源访问的代码常常会发生超时、找不到、无响应的错误状态，这种情况下，一个跑起来的系统程序通常不需要停下来，出错了也可以继续运行下一件事，然后把当时的错误记录下来，通过 print 或 logging 日志模块记录下来，拿着错误结果（日志）反馈给开发者，这样开发者就可以分析、定位和解决问题，这其中也包括你自己。\n\n```python\ntry:\n    raise Exception('unit_test')\nexcept Exception as e:\n    import sys, traceback\n    exc_type, exc_value, exc_obj = sys.exc_info()\n    traceback.print_tb(exc_obj)\n    print('have a error:', e)\n```\n\n单元测试是每个程序都尽可能保持的基本原则，虽然人会偷懒，但最起码的代码格式还是要有的。\n\n> 注：traceback 可以抓取最后一次运行出现的错误而不停止运行，但该模块不存在 MicroPython(MaixPy) 中，它有类似的替代方法。\n\n## 封装代码接口成通用模块的方法\n\n世上本没有路，走的人多了，也便成了路。\n\n这里说的路实际上就是一种封装和参考，它意味着你写的代码成为一种事实上的通用操作。\n\n在 Python 上有很多封装参考，主要是为了形成抽象的函数模块。\n\n所以出现了一些经典的编程思想，如面向过程、面向对象、面向切面、面向函数等编程方法，哪一种更好就不比较和讨论了。\n\n这里就简单叙述一下这些编程方法的逐渐发展与变化的过程，可以如何做出选择。\n\n### 面向过程\n\n用面向过程的思维写代码，强调的是这份代码做的这件事需要分几步完成，例如最开始写代码都是这样的。\n\n```python\none = 1\ntwo = 2\nthree = one + two\nprint(three)\n```\n\n这是用人类直觉的过程来写代码，后来意识到可以这样写成通用功能，这是最初的代码封装成某个函数。\n\n```python\ndef sum(num1, num2):\n    return num1 + num2\none, two = 1, 2\nprint(sum(one, two)) # 1 + 2 = 3\n```\n\n于是你多写了个类似的乘法操作。\n\n```python\ndef mul(num1, num2):\n    return num1 * num2\none, two = 1, 2\nprint(mul(one, two)) # 1 * 2 = 2\n```\n\n这时的代码是按照每一个代码操作流程来描述功能的。\n\n### 面向对象\n\n面向对象是相对于面向过程来讲的，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式，一切事物皆对象，通过面向对象的方式，将现实世界的事物抽象成对象，现实世界中的关系抽象成类、[继承](https://baike.baidu.com/item/继承)，帮助人们实现对现实世界的[抽象](https://baike.baidu.com/item/抽象)与数字建模。\n\n在看了一些面向对象的描述后，你会意识到上节面向过程的函数操作可能很通用，应该不只适用于一种变量类型，所以可以通过面向对象（class）的方法来封装它，于是可以试着这样写。\n\n```python\nclass object:\n    def sum(self, a, b):\n        return a + b\n    def mul(self, a, b):\n        return a * b\nobj = object()\nprint(obj.sum(1, 2)) # 1 + 2 = 3\nprint(obj.mul(1, 2)) # 1 * 2 = 2\n```\n\n这样会意识到似乎还不只是数字能用，感觉字符串也能用。\n\n```python\nclass object:\n    def sum(self, a, b):\n        return a + b\n    def mul(self, a, b):\n        return a * b\nobj = object()\nprint(obj.sum('1', '2')) # 1 + 2 = 3\nprint(obj.mul('1', '2')) # 1 * 2 = 2\n```\n\n但这么写会出问题的，字符串相加的时候可以，但相乘的时候会报错误，因为是字符串这个类型的变量是不能相乘的。\n\n```bash\n12\nTraceback (most recent call last):\n  File \"c:/Users/dls/Documents/GitHub/MaixPy3/test.py\", line 8, in <module>\n    print(obj.mul('1', '2')) # 1 * 2 = 2\n  File \"c:/Users/dls/Documents/GitHub/MaixPy3/test.py\", line 5, in mul\n    return a * b\nTypeError: can't multiply sequence by non-int of type 'str'\n```\n\n显然这样写代码就不合理了，但这时运用的面向对象的思想是可行的，只是实现的方式不够好而已，所以重新设计类结构，例如可以写成下面的类结构。\n\n```python\nclass obj:\n    def __init__(self, value):\n        self.value = value\n    def __add__(self, obj):\n        return self.value + obj\n    def __mul__(self, obj):\n        return self.value * obj\n\nprint(obj(1) + 2) # 3\nprint(obj(1) * 2) # 2\n```\n\n其中 `__add__` 和 `__mul__` 是可重载运算符函数，意味着这个类实例化的对象在做 + 和 * 运算操作的时候，会调用类（class）重载函数，接着可以提升可以运算的对象类型，进一步继承对象拓展功能（`class number(obj):`）和访问超类的函数（`super().__add__(obj)`），其中 `if type(obj) is __class__:` 用于判断传入的参数对象是否可以进一步处理。\n\n```python\n\nclass number(obj):\n    def __add__(self, obj):\n        if type(obj) is __class__:\n            return self.value + obj.value\n        return super().__add__(obj)\n    def __mul__(self, obj):\n        if type(obj) is __class__:\n            return self.value * obj.value\n        return super().__mul__(obj)\n\nprint(number(1) + 2)\nprint(number(1) * 2)\nprint(number(1) + number(2))\nprint(number(1) * number(2))\n\n```\n\n这时候会发现可以进一步改写成字符串数值运算。\n\n```python\n\nclass str_number(obj):\n    def __init__(self, value):\n        self.value = int(value)\n    def __add__(self, obj):\n        if type(obj) is __class__:\n            return str(self.value + int(obj.value))\n        return str(super().__add__(int(obj)))\n    def __mul__(self, obj):\n        if type(obj) is __class__:\n            return str(self.value * int(obj.value))\n        return str(super().__mul__(int(obj)))\n\nprint(str_number('1') + '2')\nprint(str_number('1') * '2')\nprint(str_number('1') + str_number('2'))\nprint(str_number('1') * str_number('2'))\n```\n\n现在就可以解决了最初的同类操作适用不同的数据类型，把最初的一段操作通用到数值和字符串了，可以受此启发，它不仅仅只是加法或乘法，还有可能是其他操作，关于面向对象的内容就说到这里，感兴趣的可以查阅相关资料深入学习，本节只讲述可以怎样使用面向对象的思维写代码，而不是单纯把 Class 当 Struct 来使用。\n\n> 像最初写的代码，如果不通过对象继承分解函数，最终将会形成一个巨大的 Struct 结构。\n\n### 面向切面\n\n现在到了选择更多编程思维方式了，关于面向切面编程方法的场景是这样提出的，有一些函数，它在产品调试的时候会需要，但在产品上线的时候是不需要的，那这样的函数应该如何实现比较好？接下来不妨直接看代码，以日志输出的代码为例来说说面向切面，介绍一下如何使用装饰器进行编程的方法。\n\n```python\n\ndef log(param):\n    # simple\n    if callable(param):\n        def wrapper(*args, **kw):\n            print('%s function()' % (param.__name__,))\n            param(*args, **kw)\n        return wrapper\n    # complex\n    def decorator(func):\n        import functools\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            print('%s %s():' % (param, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\ndef now():\n    print(\"2019\")\n\n@log\ndef now1():\n    print(\"2020\")\n\n@log(\"Is this year?\")\ndef now2():\n    print(\"2021\")\n\nnow()\nnow1()\nnow2()\n\n```\n\n运行结果：\n\n```bash\nPS C:\\Users\\dls\\Documents\\GitHub\\MaixPy3> & C:/Users/dls/anaconda3/python.exe c:/Users/dls/Documents/GitHub/MaixPy3/test.py\n2019\nnow1 function()\n2020\nIs this year? now2():\n2021\nPS C:\\Users\\dls\\Documents\\GitHub\\MaixPy3>\n```\n\n对于产品上线时不需要的函数，注释掉就可以了，更进一步还可以重新设计某些函数满足于某些条件后再运行。\n\n- 在执行某段操作前，先打印当前的系统状态记录下来，确保出错时可以追溯到出错的地方。\n- 在发送网络数据前，要先检查网络通路是否存在，网卡是否还在工作。\n- 在运行操作前，先检查内存够不够，是否需要释放内存再继续操作。\n\n可以看到，当想要不改变某些现成库代码的条件下拓展系统的功能，就不免需要面向切面的设计方法。\n\n>  注意！面向切面提出的是编程思想，实现的方法不一定是装饰函数，可以是回调函数，也可以是重载函数。\n\n### 面向函数\n\n关于面向函数的场景是由于有些问题是被数学公式提出的，所以对于一些数学问题，并不一定要按过程化的思维来写，如实现阶乘函数（factorial），它的功能就是返回一个数的阶乘，即`1*2*3*...*`该数。\n\n```python\ndef fact(n):\n    if n == 3:\n        return 3*2*1\n    if n == 2:\n        return 2*1\n    if n == 1:\n        return 1\nprint(fact(3))\nprint(fact(2))\nprint(fact(1))\n```\n\n不难看出用最初的面向过程来写是写不下去的，不可能去定义所有的可能性，所以要找出规律，可以通过递归的方式实现。\n\n```python\ndef fact(n):\n    return 1 if n == 1 else n * fact(n - 1)\nprint(fact(1))\nprint(fact(5))\nprint(fact(100))\n```\n\n这样功能就完整了，简单来说函数式编程是让编程思维追求程序中存在的公式。\n\n## 试试快速迭代的敏捷开发？\n\n现代开源软件在经历了产测、内测、公测等环节后，直至更新到用户的手里，从前到后的过程通常在一周内就可以完成，所以在设计程序接口的时候，可以接受当下接口设计的不完美，等到未来有一个更好的替代功能接口的时候，就可以将其迭代替换下来，这意味着可以不用设计好整体的软件系统再开始工作，而是边做边改进，这套理论适用于初期需要频繁更新业务逻辑的开源软件。\n\n这里简单引用一段小故事来说明这个现象。\n\n快速迭代，不是说一定要产品做好了，才能上线，半成品也能上线。\n\n在没有上线之前，你怎么知道哪好那不好。所以半成品也是可以出门的，一定不要吝惜在家，丑媳妇才需要尽早见公婆。尽早的让用户去评判你的想法，你的设计是否可以赢得用户的喜爱。快速发出，紧盯用户反馈。百度完成了第一版的搜索引擎，也是让用户去做的选择。用百度 CEO 李彦宏（Robin）的话来说“你怎么知道如何把这个产品设计成最好的呢？只有让用户尽快去用它。既然大家对这版产品有信心，在基本的产品功能上我们有竞争优势，就应该抓住时机尽快将产品推向市场，真正完善它的人将是用户。他们会告诉你喜欢哪里不喜欢哪里，知道了他们的想法，我们就迅速改，改了一百次之后，肯定就是一个非常好的产品了。”\n\n## 准备一个好的开始\n\n看到这里的你，可能会困惑，可能会看不懂，会觉得很复杂，这是认知上的偏差，实际上本文所讲述的都是编程思想上的基础，如果想专业起来，不认真是不行的。\n\n不妨自己动手试试看吧。"}, "/soft/maixpy3/zh/index.html": {"title": "什么是 MaixPy3 ？", "content": "---\ntitle: 什么是 MaixPy3 ？\nkeywords: Maixpy3官方文档\ndesc: maixpy doc: MaixPy3 是什么？能做什么？\n---\n\n![MIT](https://img.shields.io/badge/license-MIT-blue.svg) [![PyPI version](https://badge.fury.io/py/maixpy3.svg)](https://badge.fury.io/py/maixpy3) ![Python](https://img.shields.io/badge/Python-3.5↗-ff69b4.svg) [![issue](https://img.shields.io/github/issues/sipeed/maixpy3.svg)](https://github.com/sipeed/maixpy3/issues)\n\n> Maixpy3和文档在不断的更新中，可能个别代码运行的时候会有错误，请确保 Maixpy3 是最新的版本，如还是存在就到论坛中反馈，我们看到了，有空就去弄的\n\nMaixPy3 是基于 [cpython](https://github.com/python/cpython) 的 Python3 工具包，意在通过 Python 编程语言简化在 Linux 边缘设备上开发 AIoT （人工智能物联网） = AI（人工智能） + IoT（物联网）应用。\n\n\n<div align=\"center\" >\n    <img src=\"./assets/images/main.png\" style=\"width:480px; height:320px;\" />\n</div>\n\n## 前言\n\n物联网（Internet of Things，简称 IOT ）是指通过各种信息传感器、射频识别技术、全球定位系统、红外感应器、激光扫描器等各种装置与技术，实时采集任何需要监控、 连接、互动的物体或过程，采集其声、光、热、电、力学、化 学、生物、位置等各种需要的信息，通过各类可能的网络接入，实现物与物、物与人的泛在连接，实现对物品和过程的智能化感知、识别和管理。\n\nAI 的介入让 IoT 有了连接的“大脑”。当 AI 、 IoT “一体化”后，“人工智能”逐渐向“应用智能”发展。深度学习需要物联网的传感器收集，物联网的系统，也需要靠人工智能做到正确的辨识、发现异常、预测未来。\n\n而 2021 年 AIoT 边缘设备可能有如下应用场景：\n\n涵盖领域：智能制造、工业物联网、智慧物流、智慧家居、智慧交通、智慧农业、智慧园区、智慧政务、智慧医疗、智慧零售等智能物联网各应用场景。\n\n**所以 MaixPy3 会在 Python3 的基础上提供易用的 AI 功能模块**，如【**物体分类**】和【**人脸识别**】功能。\n\n> 会优先适配 MaixPy 的物体检测、物体识别、物体分类等。由于芯片差异，部分功能可能不被实现。\n\n## 以往嵌入式 Linux 设备是如何编程的？\n\n当拿到一台嵌入式 Linux 边缘设备（例如：手机），与一台桌面计算机不同的是无法进行软件编译活动，那么要如何对它编程呢？\n\n- 准备对应平台的交叉编译链\n- 编写一段经典的 `hello world` 的 C 代码进行编译\n- 链接各种依赖库\n- 将编译好的程序送到目标设备上进行调试。\n\n```c\n#include <stdio.h>\nint main() \n{\n    printf(\"Hello, world\\n\");\n    return 0\n}\n```\n\n不出意外的话，你应该要花费不少时间学习如下内容。\n\n- 学习如何编译程序\n- 学习 C 语言语法\n- 学习调试程序 Bug\n\n那现在呢？\n\n## “人生苦短，我用 Python 。”\n\n如果你是下述人群，那么 Python 将会非常适合你。\n\n- 对编程感兴趣却无从下手的\n- 想轻松入门 AIoT 开发的\n- 不了解，也不关心底层的\n- 想愉快写代码（偷懒）的\n- 想快速验证软硬件功能的\n\n让我们使用 Python 编写一段经典的 `hello world` 程序吧！\n\n```python\nprint('hello world')\nprint('1 + 1 = ?', 1 + 1)\n```\n\n### 体验一下？\n\n<div align=\"center\" >\n    <iframe src=\"https://tool.lu/coderunner/embed/awD.html\" style=\"width:90%; height:320px;\" frameborder=\"0\" mozallowfullscreen webkitallowfullscreen allowfullscreen></iframe>\n</div>\n\n> 在线 Python 编程 [runoob-python](https://www.runoob.com/try/runcode.php?filename=HelloWorld&type=python3) [google-colab](https://colab.research.google.com) 备用地址。\n\n没错，现在你已经开始 Python 编程了。\n\n## 就这？就这？？？\n\n基于上述事实使用 MaixPy3 会给你带来如下编程体验。\n\n- 使用 Python3 标准编程环境，而非 MicroPython 解释器。\n- 提供专为 AIoT 应用开发有关的底层拓展模块。\n- 支持不同芯片的 Linux 平台，自底向上的优化 Python 性能。\n- 访问硬件外设的 Python 驱动代码，常见于各类传感器。\n- 在 GitHub 开源的 [MaixPy3](https://github.com/sipeed/MaixPy3) 仓库。\n\n说了这么多，不妨来看一些示例代码。\n\n### 在屏幕上显示摄像头捕获的图像。\n\n```python\nfrom maix import display, camera\n\nimage = camera.capture()\n\ndisplay.show(image)\n```\n\n### 访问某个 I2C 外设，读写地址数据。\n\n```python\nfrom maix import i2c\n\ni2c_device = '/dev/i2c-2'\ndevice_address = 0x26\ndata_address = 0x01\n\ni2c = i2c.I2CDevice(i2c_device, device_address)\n\ni2c.write(data_address, b'\\xAA')\n\nprint(i2c.read(data_address, 1))\n```\n\n### 加载 AI 模型后输入图像验证结果。\n\n```python\nfrom PIL import Image\nfrom maix import nn\n\nm = nn.load({\n    \"param\": \"resnet.param\",\n    \"bin\": \"resnet.bin\"\n  }, opt={\n    \"model_type\":  \"awnn\",\n    \"inputs\": {\n        \"input0\": (224, 224, 3)\n    },\n    \"outputs\": {\n        \"output0\": (1, 1, 1000)\n    },\n    \"first_layer_conv_no_pad\": False,\n    \"mean\": [127.5, 127.5, 127.5],\n    \"norm\": [0.00784313725490196, 0.00784313725490196, 0.00784313725490196],\n})\n\nimg = Image.open(\"input.jpg\")\nout = m.forward(img, quantize=True)\nprint(out.shape)\nout = nn.F.softmax(out)\nprint(out.max(), out.argmax())\n```\n\n## 还想知道更多？\n\n那就点选（↘）下一章节，了解更多吧！\n\n> “Life is short. You need Python.”"}, "/soft/maixpy3/zh/question/Maixpy3_IDE.html": {"title": "MaixPy3 IDE 常见问题", "content": "##无法保存文件出现的提示信息：![](./assets/other_1.png)和![](./assets/other_2.png)这是IDE权限不足导致，在任务栏中IDE图标的右键菜单中勾选提权即可。##没有正常退出IDE通过任务栏中小图标的右键菜单重启IDE即可![](./assets/IDE.png)##开发板与电脑连接没有U盘设备添加信息弹出1、检查USB线和USB口是可以进行数据传输的。2、检查是否接上了开发板上的OTG接口。3、系统镜像是否在0.3.5以上。4、打开设备管理器，找到AndroidADBInterface设备，右键卸载改设备并删除其驱动，然后拔插一下开发板，等待系统安装新驱动即可##在运行上述代码的时候出现以下信息![842bf6204549825d5c0bb9c85b53edf.png](attachment:842bf6204549825d5c0bb9c85b53edf.png)![e5c650a86849719557dd5097d96fa6d.jpg](attachment:e5c650a86849719557dd5097d96fa6d.jpg)1、检查USB线和USB口是正常可用的。2、检查驱动正确安装成功。3、检查板子通电并已插入电脑。4、请更新镜像到至少0.3.5以上。5、搜索电脑是否存在其他adb.exe文件，请将其全部删除，并重装此IDE。>因为不同的版本的adb工具存在连接上的差异，导致部分adb工具不适配开发板。##新建文件时出现报错报错如图：![](./assets/IDE_1.png)解决办法：这是权限不足导致的，可以通过任务栏中图标右键菜单勾选提权，即可解决![](./assets/IDE_2.png)"}}